settings
{
	main
	{
		Description: "Work cooperatively to escape death row. Escape prison with all heroes to finish the game.\n\nThis is the Global Effects version of PRISON ESCAPE."
		Mode Name: "PRISON ESCAPE [GFX]"
	}

	lobby
	{
		Allow Players Who Are In Queue: Yes
		Map Rotation: After A Game
		Match Voice Chat: Enabled
		Max Spectators: 12
		Max Team 1 Players: 9
		Max Team 2 Players: 0
		Return To Lobby: Never
		Swap Teams After Match: No
	}

	modes
	{
		Skirmish
		{
			disabled maps
			{
				Workshop Chamber
				Workshop Expanse
				Workshop Expanse Night
				Workshop Green Screen
				Workshop Island
				Workshop Island Night
			}
		}

		General
		{
			Allow Hero Switching: Off
			Enemy Health Bars: Off
			Game Mode Start: Immediately
			Health Pack Respawn Time Scalar: 10%
			Hero Limit: Off
			Respawn As Random Hero: On
			Respawn Time Scalar: 40%
			Spawn Health Packs: Enabled
		}
	}

	heroes
	{
		Team 1
		{
			Bastion
			{
				Configuration: Tank Weapon Knockback Scalar: 300%
				Health: 135%
				Infinite Ultimate Duration: On
				Self-Repair Maximum Time: 200%
				Self-Repair Recharge Rate: 150%
			}
		}

		Team 2
		{
			Bastion
			{
				Configuration: Tank Weapon Knockback Scalar: 300%
				Health: 135%
				Infinite Ultimate Duration: On
				No Ammunition Requirement: On
				Quick Melee: Off
				Self-Repair Maximum Time: 200%
				Self-Repair Recharge Rate: 150%
				Ultimate Ability Configuration: Tank: Off
			}
		}

		General
		{
			Ability Cooldown Time: 30%
			No Ammunition Requirement: On
			Ultimate Generation: 10%
			Ultimate Generation - Combat: 0%
			Ultimate Generation - Passive: 0%

			Ana
			{
				Sleep Dart Cooldown Time: 500%
			}

			Baptiste
			{
				Healing Received: 10%
				Health: 10%
				Immortality Field Cooldown Time: 15%
				No Ammunition Requirement: On
				Projectile Gravity: 0%
				Projectile Speed: 500%
				Regenerative Burst Cooldown Time: 15%
			}

			Hanzo
			{
				Lunge Distance Scalar: 125%
				Storm Arrows Quantity: 12
			}

			Mercy
			{
				Secondary Fire: Off
				Weapons Enabled: Caduceus Staff Only
			}

			Orisa
			{
				Ultimate Ability Supercharger: Off
			}

			Roadhog
			{
				Chain Hook: Off
			}

			Sombra
			{
				Translocator Cooldown Time: 0%
			}

			Symmetra
			{
				Sentry Turret: Off
			}

			Torbj√∂rn
			{
				Deploy Turret: Off
				Overload Cooldown Time: 250%
				Overload Duration Scalar: 500%
				Weapons Enabled: Forge Hammer Only
			}

			Widowmaker
			{
				Infinite Ultimate Duration: On
			}

			Winston
			{
				Infinite Ultimate Duration: On
				Primal Rage Melee Knockback Scalar: 200%
			}

			Zarya
			{
				Jump Vertical Speed: 140%
				Particle Cannon Secondary Knockback Scalar: 200%
			}

			Zenyatta
			{
				Healing Dealt: 200%
				Health: 175%
				Orb of Discord: Off
			}
		}
	}

	extensions
	{
		Explosion Sounds
		Play More Effects
		Spawn More Dummy Bots
	}
}

variables
{
	global:
		0: ScoreboardArray
		1: EndPosition
		2: BastionBotCount
		3: IsGEEnabledWS
		4: GEChoice
		5: IsDVADebug
		6: IsDebugMode
		7: BastionDamages
		8: GEText
		9: JumpPadLocList
		10: JumpPadPowerList
		11: HeroList
		12: First
		13: Second
		14: Third
		15: AllBastionPositions
		16: TempVar
		17: IsGEIntervalRandomWS
		18: GEIntervalWS
		20: IsBastionLastHeroWS
		21: BacktrackMinMaxListWS
		22: HeroListTypeWS
		23: BacktrackDeathsWS
		25: HeroDataSaveIndexWS
		26: TempVar2
		27: GameSettingsHUDWT
		28: SavedIndex
		29: SavedHero
		30: SavedDeaths
		31: SavedWinners
		32: SavedBacktrackDeaths
		33: BlizzWorldSpawnLoc
		34: WinnerCountToCycleWS
		35: HollywoodSpawns
		36: RBPDefaultMaps
		37: isTeleporterEnabled
		38: JumpPadRadius
		39: TempVar3
		40: TempVar4
		41: GEMinPlayerReq
		42: GEName
		43: GEHelpText
		44: GameSettingTextVec
		45: CanStartGE
		46: IsGETimerStart
		47: GEEndTime
		48: GEWaitTime
		49: GERadius
		50: GECarriers
		51: GEViewAngle
		52: GERequiredNum
		53: WinnerHeroesList
		54: GEBallPosition
		55: GEBallID
		56: GEMeleeDistance
		57: GEMultiChoice
		58: GESpawnDistance
		59: GECurReqNum
		60: GETarget
		61: GEBallSpeed
		62: WinnerHeroesRingStats
		63: WinnerResetRingStats
		64: GECameraChoice
		65: IsBastionUpgradableWS
		66: BUExtraScale
		67: BastionPosLocType
		68: BastionPosDistance
		69: BastionPosIntervalMinMaxWS
		70: BastionPosTypeWS
		71: GEAffectedPlayer
		72: RBPIndex
		73: BacktrackSteps
		74: GEMaxNum
		75: GEMaxBacktrackSteps
		76: CurWinnerCount
		77: GameOptTextVec
		78: GameOptTextSpacing
		80: GEPatrolChoice
		81: GETempVar5
		82: GEToggles
		83: BUChoices

	player:
		0: IsWinner
		1: GECameraStats
		2: temp
		3: CurrentHero
		4: BUPlayersNearby
		5: Deaths
		6: DVADebugStates
		8: BacktrackDeaths
		9: randBacktrackNum
		10: hasPlayedSaveMessage
		11: playerToPushBack
		13: GEHelpTextIDs
		14: GETimerID
		15: GEID
		16: GEHUDID
		17: GETempVar
		18: GECount
		19: GEIsAffectedPlayer
		20: TargetHero
		21: loopNum
		23: IsGETBagStand
		24: IsGETBagCrouched
		26: Enemy
		27: AimPosition
		28: TurnSpeed
		29: TempAimPosition
		30: EnemyUnSeen
		31: InvisibleText
		32: Invis
		33: GEIsHeroCarrier
		34: GEHeroRider
		35: GEHeroCarrier
		36: GEGuardianAngel
		37: GEHumanProtect
		38: GESoulMate
		39: GEIsRecentlyHurt
		40: GEIsTagger
		41: GEIsTagged
		42: GELagType
		43: GELagDistance
		44: GELagPos
		45: WinnerHeroCursor
		46: IndieHeroList
		47: temp2
		48: BUTelePos
		49: BUTeleType
		50: BUTeleDistance
		51: WinnerDeathID
		52: BUIndex
		53: BUBulletEffectIDs
		54: BUExtraEffectIDs
		55: GETempVar2
}

subroutines
{
	0: SavePlayerData
	1: DestroyDVAMechHUD
	2: PlaySaveUnlockedMSG
	3: SpawnAtAltLoc
	4: InitCustomHeroOrder
	5: SpawnFriendlySoldier
	6: IncrementGameSettingsPos
	7: SelectGlobalEffect
	8: StartGETimer
	9: EndGlobalEffect
	10: GESetPongBallSpeed
	11: GEStartTypeA
	12: SpawnPatrolLoc
	13: GESpecificEndCleanUp
	14: GEStartTypeB
	15: GEStartTypeC
	16: GEStartTypeD
	17: GEStartTypeE
	18: GEStartTypeF
	19: GEStartTypeG
	20: GEStartTypeH
	21: GEResetHeroCarrierStats
	22: GEResetHeroRiderStats
	23: GECombineMaxHealth
	24: GESelectThrottle
	25: GEStartTypeI
	26: GEStartTypeJ
	27: AddBacktrackDeath
	28: SelectBastionBulletUpgrade
	29: SetKillSphereLoc
	30: SetNewBastionPosition
	31: ApplyWinnerStats
	32: SetupGameSettingsText
	33: CreateJumpPads
	34: CreateTeleporters
	35: PromoteHeroRider
	36: SetKeyLocation
	37: EscapeWithKey
	38: SelectWindDir
	39: SetWindSpeedRate
	40: BeforeNewBastionBulletUpgrade
	41: SelectAPatrol
	42: CleanUpPatrol
	43: SetPatrolDuration
	44: NewBastionPosOnEscape
	45: RBPCheckAndSet
	46: SetCameraView
	47: SelectBastionExtraUpgrade
	48: BastionExtraUpgradeReset
	49: SpawnAllAtAltLoc
	50: DisablePlayer
	51: EnablePlayer
	52: OneForAllGoal
	53: NextHero
	54: SetGEBastionDamage
	55: SetBoopDirection
	56: SetCloudLoc
}

rule("Workshop Settings")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.BacktrackDeathsWS = Workshop Setting Integer(Custom String("Backtracking"), Custom String(
			"# of deaths before backtracking (0=disable)"), 8, 0, 999, 0);
		Global.HeroDataSaveIndexWS = Workshop Setting Integer(Custom String("Game"), Custom String(
			"Unlock Save feature At Hero Number (0=disable)"), 5, 0, 32, 0) - 1;
		Global.BacktrackMinMaxListWS = Empty Array;
		Global.BacktrackMinMaxListWS[0] = Workshop Setting Integer(Custom String("Backtracking"), Custom String(
			"Minimum random number to backtrack by"), 1, 1, 31, 0);
		Global.BacktrackMinMaxListWS[1] = Workshop Setting Integer(Custom String("Backtracking"), Custom String(
			"Maximum random number to backtrack by"), 3, 1, 31, 1);
		Global.BacktrackMinMaxListWS = Array(Min(Global.BacktrackMinMaxListWS[0], Global.BacktrackMinMaxListWS[1]), Max(
			Global.BacktrackMinMaxListWS[0], Global.BacktrackMinMaxListWS[1]));
		Global.IsGEEnabledWS = Workshop Setting Toggle(Custom String("Global Effect Mode"), Custom String("Enabled"), True, 0);
		Global.GEIntervalWS = Workshop Setting Integer(Custom String("Global Effect Mode"), Custom String("Interval (in seconds)"), 60, 20,
			999, 1);
		Global.IsGEIntervalRandomWS = Workshop Setting Toggle(Custom String("Global Effect Mode"), Custom String(
			"Randomize the interval.  Between (0.5 * [INTERVAL]) & (1.5 * [INTERVAL])"), True, 2);
		Global.IsBastionUpgradableWS = Workshop Setting Toggle(Custom String("Global Effect Mode"), Custom String(
			"Can Bastions Receive Upgrades"), True, 3);
		Global.IsBastionLastHeroWS = Workshop Setting Toggle(Custom String("Hero Ordering"), Custom String(
			"Set Bastion as the last hero [random/independent only]"), False, 0);
		Global.HeroListTypeWS = Workshop Setting Combo(Custom String("Hero Ordering"), Custom String("Hero order to use"), 2, Array(
			Custom String("Normal"), Custom String("Random"), Custom String("Independent"), Custom String("Custom")), 0);
		Global.BastionPosIntervalMinMaxWS[0] = Workshop Setting Integer(Custom String("Bastion Position"), Custom String(
			"Minimum change interval (random only)"), 70, 30, 1000, 1);
		Global.BastionPosIntervalMinMaxWS[1] = Workshop Setting Integer(Custom String("Bastion Position"), Custom String(
			"Maximum change interval (random only)"), 160, 30, 1000, 2);
		Global.BastionPosIntervalMinMaxWS = Array(Min(Global.BastionPosIntervalMinMaxWS[0], Global.BastionPosIntervalMinMaxWS[1]), Max(
			Global.BastionPosIntervalMinMaxWS[0], Global.BastionPosIntervalMinMaxWS[1]));
		Global.BastionPosTypeWS = Workshop Setting Combo(Custom String("Bastion Position"), Custom String("Position Type"), 1, Array(
			Custom String("Original"), Custom String("Random"), Custom String("Random Once"), Custom String("On Escape")), 0);
		Global.WinnerCountToCycleWS = Workshop Setting Integer(Custom String("Game"), Custom String(
			"Winners needed to cycle map(0=disabled)"), 2, 0, 100, 0);
	}
}

rule("Init custom hero list")
{
	event
	{
		Subroutine;
		InitCustomHeroOrder;
	}

	actions
	{
		Global.HeroList = Empty Array;
		Global.HeroList[0] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 1"), Sombra, 0);
		Global.HeroList[1] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 2"), Tracer, 0);
		Global.HeroList[2] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 3"), Reaper, 0);
		Global.HeroList[3] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 4"), Symmetra, 0);
		Global.HeroList[4] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 5"), Moira, 0);
		Global.HeroList[5] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 6"), Doomfist, 0);
		Global.HeroList[6] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 7"), Genji, 0);
		Global.HeroList[7] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 8"), D.Va, 0);
		Global.HeroList[8] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 9"), Echo, 0);
		Global.HeroList[9] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 10"), Brigitte, 1);
		Global.HeroList[10] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 11"), Widowmaker, 1);
		Global.HeroList[11] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 12"), Mei, 1);
		Global.HeroList[12] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 13"), Baptiste, 1);
		Global.HeroList[13] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 14"), Soldier: 76, 1);
		Global.HeroList[14] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 15"), Wrecking Ball, 1);
		Global.HeroList[15] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 16"), Hanzo, 1);
		Global.HeroList[16] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 17"), Ashe, 1);
		Global.HeroList[17] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 18"), Cassidy, 1);
		Global.HeroList[18] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 19"), L√∫cio, 1);
		Global.HeroList[19] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 20"), Winston, 2);
		Global.HeroList[20] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 21"), Junkrat, 2);
		Global.HeroList[21] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 22"), Pharah, 2);
		Global.HeroList[22] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 23"), Mercy, 2);
		Global.HeroList[23] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 24"), Reinhardt, 2);
		Global.HeroList[24] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 25"), Zarya, 2);
		Global.HeroList[25] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 26"), Orisa, 2);
		Global.HeroList[26] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 27"), Sigma, 2);
		Global.HeroList[27] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 28"), Torbj√∂rn, 2);
		Global.HeroList[28] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 29"), Ana, 2);
		Global.HeroList[29] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 30"), Zenyatta, 3);
		Global.HeroList[30] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 31"), Roadhog, 3);
		Global.HeroList[31] = Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 32"), Bastion, 3);
	}
}

rule("init winner hero list")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.WinnerHeroesList == Null;
	}

	actions
	{
		Global.WinnerHeroesList = Array(Hero(Ana), Hero(Baptiste), Hero(Brigitte), Hero(Cassidy), Hero(D.Va), Hero(Genji), Hero(Hanzo),
			Hero(L√∫cio), Hero(Mei), Hero(Mercy), Hero(Moira), Hero(Orisa), Hero(Reinhardt), Hero(Sigma), Hero(Soldier: 76), Hero(Symmetra),
			Hero(Winston), Hero(Zarya), Hero(Zenyatta));
	}
}

rule("init hero list sequence")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"HeroListTypeWS: 0 = Normal, 1 = Random Order, 2 = Independent Order, 3 = Custom Order"
		If(Global.HeroListTypeWS == 3);
			Call Subroutine(InitCustomHeroOrder);
		Else;
			Global.HeroList = Array(Hero(Sombra), Hero(Tracer), Hero(Reaper), Hero(Symmetra), Hero(Moira), Hero(Doomfist), Hero(Genji), Hero(
				D.Va), Hero(Echo), Hero(Brigitte), Hero(Widowmaker), Hero(Mei), Hero(Baptiste), Hero(Soldier: 76), Hero(Wrecking Ball), Hero(
				Hanzo), Hero(Ashe), Hero(Cassidy), Hero(L√∫cio), Hero(Winston), Hero(Junkrat), Hero(Pharah), Hero(Mercy), Hero(Reinhardt), Hero(
				Zarya), Hero(Orisa), Hero(Sigma), Hero(Torbj√∂rn), Hero(Ana), Hero(Zenyatta), Hero(Roadhog), Hero(Bastion));
			If(Global.HeroListTypeWS == 1);
				Global.HeroList = Randomized Array(Global.HeroList);
				If(Global.IsBastionLastHeroWS == True);
					If(Last Of(Global.HeroList) != Hero(Bastion));
						Global.TempVar = Last Of(Global.HeroList);
						Global.HeroList[Index Of Array Value(Global.HeroList, Hero(Bastion))] = Global.TempVar;
						Global.HeroList[Count Of(Global.HeroList) - 1] = Hero(Bastion);
	}
}

rule("Global Stats & inits")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Disable Inspector Recording;
		Disable Built-In Game Mode Completion;
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("WORKSHOP.CODES/PRISON-ESCAPE-GFX | SERVER CPU: {0}%",
			Round To Integer(Server Load / 255 * 100, To Nearest)), Left, -1000, Color(White), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Set Slow Motion(90);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("Server hosted \"{1}\" for {0} seconds!\r\n \r\n ",
			Round To Integer(Total Time Elapsed, To Nearest), Current Map), Left, -1, Color(White), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(" \n \nEscape Status:"), Left, 10, Color(White), Color(White),
			Color(Aqua), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0}", !Has Spawned(Global.First) ? Custom String(" ")
			: Custom String("1. {0} {1} - {2}", Hero Icon String(Hero Of(Global.First)), Global.First, Global.First.TargetHero + 1)), Left,
			11, Color(White), Color(White), Color(Green), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0}", !Has Spawned(Global.Second) ? Custom String(" ")
			: Custom String("2. {0} {1} - {2}", Hero Icon String(Hero Of(Global.Second)), Global.Second, Global.Second.TargetHero + 1)),
			Left, 12, Color(White), Color(White), Color(Yellow), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0}", !Has Spawned(Global.Third) ? Custom String(" ")
			: Custom String("3. {0} {1} - {2}", Hero Icon String(Hero Of(Global.Third)), Global.Third, Global.Third.TargetHero + 1)), Left,
			13, Color(White), Color(White), Color(Orange), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("PRISON ESCAPE [GFX]"), Top, 0, Color(White), Color(White),
			Color(White), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Custom String("Code: N0B1R"), Null, Top, 1, Color(White), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Global.SavedWinners = Empty Array;
		Global.SavedIndex = Empty Array;
		Global.SavedHero = Empty Array;
		Global.SavedBacktrackDeaths = Empty Array;
		Global.JumpPadRadius = 2.500;
		Global.BacktrackSteps = 1;
		"[0] Location,[1] Radius, [2] RingID, [3] Text Height"
		Global.WinnerHeroesRingStats = Array(Null, 1.750, Null, Vector(0, 1, 0));
		Global.WinnerResetRingStats = Array(Null, 1.750, Null, Vector(0, 1, 0));
		"Maps with Players spawns using the game's default locations "
		Global.RBPDefaultMaps = Array(Map(Busan), Map(Eichenwalde), Map(Eichenwalde Halloween), Map(Hanamura), Map(Hanamura Winter), Map(
			Havana), Map(Horizon Lunar Colony), Map(King's Row), Map(King's Row Winter), Map(Numbani), Map(Oasis), Map(Paris), Map(Rialto),
			Map(Route 66), Map(Temple of Anubis), Map(Watchpoint: Gibraltar), Map(Volskaya Industries));
		"0 = I Need Healing"
		Global.GEToggles = Array(False);
		"0 = Bullets; 1 = Extra"
		Global.BUChoices = Array(0, 0);
		"0 = Initial Damage; 1 = New Base Damage; 2 = Extra Damage; "
		Global.BastionDamages = Array(150, 150, 0);
	}
}

rule("Init independent hero list")
{
	event
	{
		Player Joined Match;
		Team 1;
		All;
	}

	conditions
	{
		Global.HeroListTypeWS == 2;
		Event Player.IndieHeroList == Null;
	}

	actions
	{
		Event Player.IndieHeroList = Randomized Array(Global.HeroList);
		If(Global.IsBastionLastHeroWS == True);
			If(Last Of(Event Player.IndieHeroList) != Hero(Bastion));
				Event Player.temp2 = Last Of(Event Player.IndieHeroList);
				Event Player.IndieHeroList[Index Of Array Value(Event Player.IndieHeroList, Hero(Bastion))] = Event Player.temp2;
				Event Player.IndieHeroList[Count Of(Event Player.IndieHeroList) - 1] = Hero(Bastion);
	}
}

disabled rule("map setting (global arr p, global b, global d, global c) - [template]")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Insert map name here"
		Current Map == Null;
	}

	actions
	{
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		Global.AllBastionPositions = Array(Null, Null, Null, Null, Null, Null);
		"Goal position"
		Global.EndPosition = Left - Left;
		Start Forcing Spawn Room(Team 1, 2);
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(0, 0, 0);
		Global.WinnerResetRingStats[0] = Vector(0, 0, 0);
		"The text above the endgame rings for winners"
		Global.WinnerHeroesRingStats[3] = Vector(0, 0, 0);
		Global.WinnerResetRingStats[3] = Vector(0, 0, 0);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(0, 0, 0);
	}
}

disabled rule("Teleporter position init (global T) [template]")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.T == Empty Array;
		Current Map == Null;
	}

	actions
	{
		"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
		Global.T = Array(Vector(0, 0, 0), Vector(0, 0, 0));
	}
}

disabled rule("Jump pad position init (global J)(global K) [template]")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.JumpPadLocList == Empty Array;
		Current Map == Null;
	}

	actions
	{
		"Location of the jump pad"
		Modify Global Variable(JumpPadLocList, Append To Array, Left - Left);
		"How powerful the jump pad should be?"
		Modify Global Variable(JumpPadPowerList, Append To Array, Left - Left);
	}
}

rule("Cycle to next map (Map Cycling)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.WinnerCountToCycleWS != 0;
		Global.CurWinnerCount >= Global.WinnerCountToCycleWS;
	}

	actions
	{
		Big Message(All Players(Team 1), Custom String("     Winner Limit Reached!\n\nMap will cycle in 60 seconds!"));
		Wait(3, Abort When False);
		Wait(45, Abort When False);
		Big Message(All Players(Team 1), Custom String("Map will cycle in 15 seconds!"));
		Wait(2, Abort When False);
		Wait(12, Abort When False);
		Big Message(All Players(Team 1), Custom String("Cycling Map!"));
		Wait(3, Abort When False);
		Restart Match;
	}
}

rule("map setting (global arr p, global b, global d, global c) - oasis(all)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Insert map name here"
		Current Map == Map(Oasis);
	}

	actions
	{
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		Start Forcing Spawn Room(Team 1, 2);
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		"University"
		If(Count Of(Players Within Radius(Vector(-193.743, 21.300, 91.204), 40, Team 1, Off)) != 0);
			"The text above the endgame rings for winners"
			Global.WinnerHeroesRingStats[3] = Vector(0, 0.750, 0);
			Global.AllBastionPositions = Array(Vector(-168.599, 22.258, 68.245), Vector(-180.717, 16.300, 25.092), Vector(-183.567, 16.905,
				9.355), Vector(-200.438, 20.300, -4.854), Vector(-185.219, 16.296, -25.005), Vector(-175.947, 20.261, -48.694));
			"University goal position"
			Global.EndPosition = Vector(-188.063, 19.298, -63.705) - Vector(0, 2, 0);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(-178.052, 20.350, 81.100);
			Global.WinnerResetRingStats[0] = Vector(-197.983, 20.350, 81.201);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(-188.171, 20.300, 81.549);
		"Garden"
		Else If(Count Of(Players Within Radius(Vector(203.074, 8.038, -185.630), 40, Team 1, Off)) != 0);
			"The text above the endgame rings for winners"
			Global.WinnerHeroesRingStats[3] = Vector(0, 1, 0);
			Global.AllBastionPositions = Array(Vector(144.649, 4.488, -184.348), Vector(151.869, 8.800, -225.833), Vector(131.907, 16.581,
				-238.408), Vector(127.361, 8.772, -233.725), Vector(131.369, 10.300, -267.255), Vector(108.870, 13.853, -277.224));
			"Garden goal position"
			Global.EndPosition = Vector(71.347, 9.120, -279.602) - Vector(0, 2, 0);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(192.857, 9.038, -196.085);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(202.107, 6.719, -196.908);
			Global.WinnerResetRingStats[0] = Vector(204.878, 7.247, -199.526);
		"City Center"
		Else If(Count Of(Players Within Radius(Vector(66.241, 2.300, 324.072), 40, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(95.535, 2.200, 272.691), Vector(143.308, 3.448, 247.397), Vector(139.550, 11.298,
				251.107), Vector(147.400, 11.299, 243.810), Vector(209.108, 2.303, 213.907), Vector(157.325, 5.232, 213.538));
			"City Center goal position"
			Global.EndPosition = Vector(178.628, 2.276, 174.641) - Vector(0, 2, 0);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(73.560, 2.300, 327.104);
			Global.WinnerResetRingStats[0] = Vector(65.313, 2.300, 314.109);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(84.820, 2.148, 310.593);
			"The text above the endgame rings for winners"
			Global.WinnerHeroesRingStats[3] = Vector(0, 0.750, 0);
		End;
		Global.WinnerResetRingStats[3] = Vector(0, 0.750, 0);
	}
}

rule("map setting (global arr p, global b, global d, global c) - nepal(all)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Insert map name here"
		Current Map == Map(Nepal);
	}

	actions
	{
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		Start Forcing Spawn Room(Team 1, 2);
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		"Shrine"
		If(Count Of(Players Within Radius(Vector(-41.729, 19.079, -93.923), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(-70.186, 20.076, -40.441), Vector(-43.379, 19.417, -20.224), Vector(-43.716, 19.442,
				20.212), Vector(-52.963, 20.606, 44.634), Vector(-72.738, 12.476, 47.462), Vector(-30.099, 16.585, 51.459));
			"Shrine goal position"
			Global.EndPosition = Vector(-45.233, 16.300, 72.137) - Vector(0, 2, 0);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(-45.895, 18.079, -88.959);
			Global.WinnerResetRingStats[0] = Vector(-49.186, 18.079, -89.027);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(-37.556, 18.946, -88.505);
		"Sanctum"
		Else If(Count Of(Players Within Radius(Vector(82.236, 133.730, -90.834), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(92.358, 140.810, -47.405), Vector(84.485, 131.300, -12.016), Vector(107.637, 133.300,
				18.065), Vector(85.505, 131.675, 40.858), Vector(94.228, 138.254, 47.119), Vector(70.771, 129.837, 66.950));
			"Sanctum goal position"
			Global.EndPosition = Vector(81.344, 131.245, 70.547) - Vector(0, 2, 0);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(86.482, 133.595, -84.782);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(78.553, 132.729, -85.378);
			Global.WinnerResetRingStats[0] = Vector(75.105, 132.730, -85.197);
		"Village"
		Else If(Count Of(Players Within Radius(Vector(-160.389, -94.271, -84.060), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(-179.755, -88.685, -26.069), Vector(-204.373, -89.729, -12.570), Vector(-204.457,
				-89.727, 12.440), Vector(-195.496, -93.630, 45.155), Vector(-163.005, -88.821, 43.442), Vector(-147.271, -83.869, 50.381));
			"Village goal position"
			Global.EndPosition = Vector(-167.446, -97.633, 68.291) - Vector(0, 2, 0);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(-166.073, -95.271, -81.014);
			Global.WinnerResetRingStats[0] = Vector(-168.919, -95.271, -82.581);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(-159.261, -94.705, -76.760);
		End;
		"The text above the endgame rings for winners"
		Global.WinnerHeroesRingStats[3] = Vector(0, 1, 0);
		Global.WinnerResetRingStats[3] = Vector(0, 1, 0);
	}
}

rule("map setting (global arr p, global b, global d, global c) - ilios(all)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Insert map name here"
		Current Map == Map(Ilios);
	}

	actions
	{
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		Start Forcing Spawn Room(Team 1, 2);
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		"Well"
		If(Count Of(Players Within Radius(Vector(-152.014, -1.104, -93.120), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(-181.480, 0.300, -50.903), Vector(-197.571, 11.191, -13.818), Vector(-223.199, 6.427,
				7.091), Vector(-236.558, 6.300, -9.246), Vector(-262.055, -3.701, 31.839), Vector(-213.939, 3.300, 6.564));
			"Well goal position"
			Global.EndPosition = Vector(-271.140, -3.585, 33.279) - Vector(0, 2, 0);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(-157.019, -1.355, -89.945);
			Global.WinnerResetRingStats[0] = Vector(-160.308, -1.355, -91.403);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(-149.658, -1.587, -86.416);
		"Ruins"
		Else If(Count Of(Players Within Radius(Vector(131.609, 64.254, -159.135), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(91.562, 65.583, -174.582), Vector(66.927, 68.505, -169.264), Vector(28.390, 62.689,
				-148.659), Vector(-1.205, 65.524, -147.564), Vector(-33.746, 65.611, -173.263), Vector(-65.140, 61.666, -168.727));
			"Tower goal position"
			Global.EndPosition = Vector(-51.248, 67.259, -158.371) - Vector(0, 2, 0);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(127.484, 63.920, -154.025);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(128.139, 63.254, -161.875);
			Global.WinnerResetRingStats[0] = Vector(128.072, 63.254, -165.528);
		"Town"
		Else If(Count Of(Players Within Radius(Vector(322.692, -21.520, 42.832), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(355.021, -19.264, -4.231), Vector(330.019, -16.347, -30.497), Vector(350.081, -15.408,
				-56.854), Vector(304.817, -16.160, -73.229), Vector(294.972, -19.341, -75.245), Vector(276.960, -20.361, -83.065));
			"Town goal position"
			Global.EndPosition = Vector(290.229, -23.291, -88.556) - Vector(0, 3, 0);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(327.717, -21.520, 39.609);
			Global.WinnerResetRingStats[0] = Vector(331.080, -21.520, 41.121);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(320.494, -21.755, 36);
		End;
		"The text above the endgame rings for winners"
		Global.WinnerHeroesRingStats[3] = Vector(0, 0.250, 0);
		Global.WinnerResetRingStats[3] = Vector(0, 0.250, 0);
	}
}

rule("map setting (global arr p, global b, global d, global c) - lijiang tower(all)(lunar new year)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Current Map == Map(Lijiang Tower) || Current Map == Map(Lijiang Tower Lunar New Year)) == True;
	}

	actions
	{
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		Start Forcing Spawn Room(Team 1, 2);
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		"Data Center"
		If(Count Of(Players Within Radius(Vector(61.699, 268.879, 342.773), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(30.128, 270.151, 282.442), Vector(2.043, 280.231, 312.979), Vector(-0.085, 273.800,
				280.044), Vector(-2.029, 280.231, 313.200), Vector(-38.268, 268.300, 295.176), Vector(-28.765, 271.300, 340.361));
			"Data Center goal position"
			Global.EndPosition = Vector(-51.280, 266.300, 332.484) - Vector(0, 2, 0);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(59.981, 268.878, 336.868);
			Global.WinnerResetRingStats[0] = Vector(62.727, 268.878, 334.382);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(54.159, 268.545, 342.362);
		"Tower"
		Else If(Count Of(Players Within Radius(Vector(79.167, 97.863, 144.773), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(46.896, 96.452, 136.808), Vector(-0.070, 95.551, 158.403), Vector(0.028, 95.550,
				141.938), Vector(-36.303, 96.450, 137.238), Vector(53.242, 97.554, 169.195), Vector(-54.166, 95.551, 159.799));
			"Tower goal position"
			Global.EndPosition = Vector(-65.245, 95.552, 146.885) - Vector(0, 2, 0);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(75.006, 97.780, 150.128);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(74.991, 98.113, 142.005);
			Global.WinnerResetRingStats[0] = Vector(74.509, 98.113, 138.469);
		"Shrine"
		Else If(Count Of(Players Within Radius(Vector(78.273, 6.208, -30.659), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(59.281, 3.741, -12.995), Vector(6.914, 0.741, -39.069), Vector(-2.149, 9.756, -52.371),
				Vector(-34.343, 0.741, -12.038), Vector(-57.683, 3.745, -12.967), Vector(-53.844, 4.400, -30.280));
			"Shrine goal position"
			Global.EndPosition = Vector(-60.904, 7.743, -14.404) - Vector(0, 2, 0);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(74.181, 5.900, -34.525);
			Global.WinnerResetRingStats[0] = Vector(74.792, 5.900, -37.957);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(72.166, 5.786, -26.690);
		End;
		"The text above the endgame rings for winners"
		Global.WinnerHeroesRingStats[3] = Vector(0, 0, 0);
		Global.WinnerResetRingStats[3] = Vector(0, 0, 0);
	}
}

rule("map setting (global arr p, global b, global d, global c) - busan(all)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Insert map name here"
		Current Map == Map(Busan);
	}

	actions
	{
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		Start Forcing Spawn Room(Team 1, 2);
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		"Factory"
		If(Count Of(Players Within Radius(Vector(290.902, 12.396, 213.099), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(251.444, 13.395, 221.373), Vector(223.880, 19.332, 214.017), Vector(51.997, 7.309,
				-101.671), Vector(177.838, 12.395, 275.812), Vector(186.569, 13.395, 248.653), Vector(194.799, 22.393, 246.564));
			"Factory goal position"
			Global.EndPosition = Vector(163.996, 11.397 - 1.320, 259.067);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(292.254, 12.494, 219.868);
			Global.WinnerResetRingStats[0] = Vector(295.837, 12.494, 218.427);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(295.322, 11.595, 221.749);
		"Plaza"
		Else If(Count Of(Players Within Radius(Vector(-31.724, 18.300, -125.575), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(26.382, 23.990, -110.239), Vector(34.637, 16.300, -122.903), Vector(51.761, 7.309,
				-101.209), Vector(69.110, 16.300, -122.896), Vector(77.047, 24.050, -110.099), Vector(107.594, 18.314, -148.811));
			"Plaza goal position"
			Global.EndPosition = Vector(112.557, 17.246 - 1.320, -125.478);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(-43.861, 17.820, -125.438);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(-43.677, 18.253, -122.800);
			Global.WinnerResetRingStats[0] = Vector(-43.634, 18.253, -128.069);
		"Dojo"
		Else If(Count Of(Players Within Radius(Vector(-426.165, 12.407, 165.979), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(-365.499, 15.267, 130.545), Vector(-328.646, 18.403, 167.589), Vector(-329.006, 16.203,
				138.519), Vector(-307.520, 11.953, 139.141), Vector(-291.570, 13.334, 157.068), Vector(-252.461, 10.655, 152.426));
			"Dojo goal position"
			Global.EndPosition = Vector(-262.352, 10.460 - 1.320, 161.585);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(-411.092, 11.462, 174.379);
			Global.WinnerResetRingStats[0] = Vector(-412.805, 11.462, 154.558);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(-410.566, 11.463, 164.413);
		End;
		"The text above the endgame rings for winners"
		Global.WinnerHeroesRingStats[3] = Vector(0, 0, 0);
		Global.WinnerResetRingStats[3] = Vector(0, 0, 0);
	}
}

rule("map setting (global arr p, global b, global d, global c) - hanamura (winter)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Current Map == Map(Hanamura) || Current Map == Map(Hanamura Winter)) == True;
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-14.835, 7.540, -94.010), Vector(-23.327, -1, -47.090), Vector(13.117, 7.170, -50.253),
			Vector(24.812, 6, 9.457), Vector(46.742, 6, -13.957), Vector(68.033, -1.900, 12.950));
		Global.EndPosition = Vector(68.166, -2, -0.310);
		Start Forcing Spawn Room(Team 1, 2);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-30.205, 0.500, -105.354);
		Global.WinnerResetRingStats[0] = Vector(-37.960, 0.500, -97.845);
		"The text above the endgame rings for winners"
		Global.WinnerHeroesRingStats[3] = Vector(0, 2, 0);
		Global.WinnerResetRingStats[3] = Vector(0, 2, 0);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-33.825, 1.750, -101.375);
	}
}

rule("map setting (global arr p, global b, global d, global c) - gibraltar")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Watchpoint: Gibraltar);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(70.099, 9, 26.803), Vector(81.759, 6, 3.200), Vector(64.465, 9.690, -32.138), Vector(
			32.373, 3, -50.866), Vector(31.113, 7.300, -89.871), Vector(41.383, 4, -124.788));
		Global.EndPosition = Vector(46.558, 1, -146.808);
		Start Forcing Spawn Room(Team 1, 2);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(82.842, -8.700, 44.751);
		Global.WinnerResetRingStats[0] = Vector(77.831, -8.700, 49.404);
		"The text above the endgame rings for winners"
		Global.WinnerHeroesRingStats[3] = Vector(0, 2, 0);
		Global.WinnerResetRingStats[3] = Vector(0, 2, 0);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(77.495, -9.676, 44.697);
	}
}

rule("map setting (global arr p, global b, global d, global c) - numbani")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Numbani);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(179.102, 4.250, 13.115), Vector(154.224, -4.180, 13.616), Vector(118.815, 4.250, 3.556),
			Vector(78.459, 6.250, -11.527), Vector(-49.872, 11.283, -43.701), Vector(7.964, 1.270, -6.488));
		Global.EndPosition = Vector(6.984, -1, 5.778);
		Start Forcing Spawn Room(Team 1, 1);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(241.550, 1.665, 22.677);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(238.587, 1.455, 18.412);
		Global.WinnerResetRingStats[0] = Vector(238.587, 1.505, 26.771);
	}
}

rule("map setting (global arr p, global b, global d, global c) - volskaya industries")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Volskaya Industries);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-87.972, 2.020, 38.919), Vector(-67.835, 10.390, 49.479), Vector(-63.809, -0.410,
			77.730), Vector(-11.250, 1.270, 76.356), Vector(-16.279, 2.200, 41.017), Vector(-6.364, 8.240, 35.514));
		Global.EndPosition = Vector(-11.477, -6, 19.868);
		Start Forcing Spawn Room(Team 1, 0);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-108.629, -0.680, 27.504);
		Global.WinnerResetRingStats[0] = Vector(-117.908, -0.680, 36.678);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-112.517, -1.680, 32.352);
	}
}

rule("map setting (global arr p, global b, global d, global c) - route 66")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Route 66);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-95.624, 12.660, -5.541), Vector(-38.680, 12.750, -22.136), Vector(-15.784, 8.540,
			-12.685), Vector(36.467, 2.140, -4.003), Vector(48.707, 10.110, 25.063), Vector(26.871, 7.010, 2.468));
		Global.EndPosition = Vector(47.956, 5.200, 47.318);
		Start Forcing Spawn Room(Team 1, 1);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-106.441, 6, -58.824);
		Global.WinnerResetRingStats[0] = Vector(-108.447, 6, -62.336);
		"The text above the endgame rings for winners"
		Global.WinnerHeroesRingStats[3] = Vector(0, 0, 0);
		Global.WinnerResetRingStats[3] = Vector(0, 0, 0);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-108.281, 5.812, -50.656);
	}
}

rule("map setting (global arr p, global b, global d, global c) - rialto")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Rialto);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-64.421, 5.040, -125.927), Vector(-16.976, 1.660, -38.459), Vector(-36.002, 4.750,
			-77.344), Vector(59.058, 0.070, -8.103), Vector(54.797, 1.740, -59.938), Vector(87.874, -0.370, 0.268));
		Global.EndPosition = Vector(98.662, -1.500, -21.009);
		Start Forcing Spawn Room(Team 1, 2);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-49.550, 5.050, -171.124);
		Global.WinnerResetRingStats[0] = Vector(-63.679, 5.050, -170.880);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-57, 4.050, -156.838);
	}
}

rule("map setting (global arr p, global b, global d, global c) - horizon lunar colony")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Horizon Lunar Colony);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-15.287, 6, -127.244), Vector(16.250, 11.860, -106.756), Vector(70.800, 15, -76.840),
			Vector(62.340, 6, -34.740), Vector(19.496, 9, -1.439), Vector(66.687, 8.520, -37.241));
		Global.EndPosition = Vector(34.476, 12, -23.518);
		Start Forcing Spawn Room(Team 1, 0);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-43.492, 5.800, -156.776);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-37.170, 6.450, -161.895);
		Global.WinnerResetRingStats[0] = Vector(-38.639, 6.450, -165.470);
	}
}

rule("map setting (global arr p, global b, global d, global c) - havana")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Havana);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(117.332, 14.433, -58.091), Vector(140.438, 6.413, -16.667), Vector(31.288, 18.900,
			-75.331), Vector(-32.514, 7.150, -79.487), Vector(14.787, 7.300, -47.470), Vector(-71.110, 5.846, -72.362));
		Global.EndPosition = Vector(-71.203, 2, -50.678);
		Start Forcing Spawn Room(Team 1, 2);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(158.050, 12.302, -46.921);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(172.764, 12.300, -51.870);
		Global.WinnerResetRingStats[0] = Vector(172.695, 12.300, -41.247);
	}
}

rule("map setting (global arr p, global b, global d, global c) - dorado")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Dorado);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(170.288, 19.100, 45.051), Vector(118.262, 18.250, 1.209), Vector(78.973, 17.480, -6.843),
			Vector(34.074, 11.080, -17.958), Vector(26.361, 10.650, 20.115), Vector(126.713, 16.300, 17.517));
		Global.EndPosition = Vector(16.012, Empty Array, 5.874);
		Start Forcing Spawn Room(Team 1, 1);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(184.096, 7.840, 40.671);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(182.148, 8.390, 42.701);
		Global.WinnerResetRingStats[0] = Vector(183.660, 8.390, 37.902);
	}
}

rule("map setting (global arr p, global b, global d, global c) - king's row (winter)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Current Map == Map(King's Row) || Current Map == Map(King's Row Winter)) == True;
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-143.900, 7.130, 10.150), Vector(-120.990, 1.070, -12.080), Vector(-91.380, 1.140,
			-27.900), Vector(-55.460, -0.200, -29.830), Vector(5.980, 6.110, -30.350), Vector(-21.560, 2.580, -8.160));
		Global.EndPosition = Vector(-1.900, 5, -0.290);
		Start Forcing Spawn Room(Team 1, 1);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-173.483, 0.762, 36.414);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-178.034, 1.260, 43.774);
		Global.WinnerResetRingStats[0] = Vector(-180.556, 1.262, 30.807);
	}
}

rule("map setting (global arr p, global b, global d, global c) - blizzworld (winter)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter)) == True;
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-121.979, 0.148, 110.507), Vector(-93.733, -1.047, 110.100), Vector(-66.733, 7.079,
			110.571), Vector(-0.165, 7.421, 89.178), Vector(3.082, 3.900, 43.609), Vector(3.049, -4.850, 16.685), Vector(-30.574, 12.966,
			87.938));
		Start Forcing Spawn Room(Team 1, 1);
		Global.EndPosition = Vector(2.772, -6.500, -6.900);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-151.769, 1.648, 101.924);
		Global.BlizzWorldSpawnLoc = Vector(-169.871, 2.948, 96.498);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 7;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-152.835, 0.500, 106.112);
		Global.WinnerResetRingStats[0] = Vector(-150.326, 0.500, 98.171);
		"The text above the endgame rings for winners"
		Global.WinnerHeroesRingStats[3] = Vector(0, 2, 0);
		Global.WinnerResetRingStats[3] = Vector(0, 2, 0);
	}
}

rule("map setting (global arr p, global b, global d, global c) - eichenwalde (halloween)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Current Map == Map(Eichenwalde) || Current Map == Map(Eichenwalde Halloween)) == True;
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(123.333, 8.971, -27.303), Vector(89.318, 21.095, -62.697), Vector(38.021, 13.917,
			-79.821), Vector(23.799, 7.417, -53.839), Vector(-4.858, 6.957, -31.559), Vector(25.587, 6.300, -14.531));
		Global.EndPosition = Vector(-10.354, -2.149, -12.399);
		Start Forcing Spawn Room(Team 1, 2);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(129.339, 12.120, -2.655);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(135.825, 11.899, -2.692);
		Global.WinnerResetRingStats[0] = Vector(124.359, 11.898, 0.626);
	}
}

rule("map setting (global arr p, global b, global d, global c) - hollywood (halloween)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween)) == True;
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-26.166, 7.503, -134.609), Vector(-2.241, 12.161, -112.505), Vector(11.552, 6.303,
			-69.943), Vector(-7.480, 7.441, -43.441), Vector(-20.714, 8.050, 9.977), Vector(4.864, 7.147, 38.401));
		Start Forcing Spawn Room(Team 1, 2);
		Global.EndPosition = Vector(-12.002, -1.307, 69.489);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-32.049, 4.714, -155.052);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-27.106, 5.414, -157.424);
		Global.WinnerResetRingStats[0] = Vector(-22.370, 5.416, -158.670);
		"[0] = The CORRECT Hollywood spawn point; [1] = The WRONG Hollywood spawn point"
		Global.HollywoodSpawns = Array(Vector(-30.960, 7.254, -172.189), Vector(49.257, 4.050, -56.238));
	}
}

rule("map setting (global arr p, global b, global d, global c) - junkertown")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Junkertown);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-96.235, 13.672, -136.725), Vector(-72.380, 7.672, -144.151), Vector(-27.431, 13.780,
			-100.155), Vector(-32.236, 12.976, -29.143), Vector(-2.080, 11.366, -61.807), Vector(30.116, 13.407, -59.880));
		Global.EndPosition = Vector(30.248, 5.515, -81.733);
		Start Forcing Spawn Room(Team 1, 2);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-95.486, 12.245, -86.316);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-85.345, 11.812, -81.681);
		Global.WinnerResetRingStats[0] = Vector(-94.717, 11.800, -84.011);
		Global.WinnerResetRingStats[3] = Vector(0, 0, 0);
	}
}

rule("map setting (global arr p, global b, global d, global c) - paris")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Paris);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-95.984, 13.454, -83.535), Vector(-72.132, 11.976, -44.042), Vector(-41.725, 14.240,
			-2.920), Vector(34.074, 11.080, -17.958), Vector(-14.721, 14.250, -35.219), Vector(0.211, 10.174, -60.874));
		Global.EndPosition = Vector(9.563, 8.329, -59.980);
		Start Forcing Spawn Room(Team 1, 1);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-108.617, 15.800, -109.835);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-110.869, 16, -105.512);
		Global.WinnerResetRingStats[0] = Vector(-104.076, 16.445, -109.313);
	}
}

rule("map setting (global arr p, global b, global d, global c) - anubis")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Temple of Anubis);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-17.188, 11.237, 105.646), Vector(-12.218, 10.667, 52.835), Vector(-58.847, 6.810,
			41.419), Vector(-8.454, 1.153, 29.868), Vector(8.482, 4.898, 10.299), Vector(-23.218, 2.706, -26.863));
		Global.EndPosition = Vector(-0.866, -3.781, -10.919);
		Start Forcing Spawn Room(Team 1, 1);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-5.076, 5.576, 140.240);
		Global.WinnerResetRingStats[0] = Vector(-15.733, 5.585, 137.884);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-7.971, 5.570, 135.900);
	}
}

rule("Spawn players at alternative locations instead")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Call Subroutine(SpawnAtAltLoc);
	}
}

rule("init winners feature rings (END GAME)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.WinnerHeroesRingStats[2] == Null;
	}

	actions
	{
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		Create Effect(Filtered Array(All Players(Team 1), Current Array Element.IsWinner), Ring, Color(Rose),
			Global.WinnerHeroesRingStats[0], Global.WinnerHeroesRingStats[1], Visible To);
		Global.WinnerHeroesRingStats[2] = Last Created Entity;
		Create In-World Text(Filtered Array(All Players(Team 1), Current Array Element.IsWinner), Custom String(
			"[Jump]/[Crouch] to Change Hero"), Global.WinnerHeroesRingStats[0] + Global.WinnerHeroesRingStats[3], 1.300,
			Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		Create Effect(Filtered Array(All Players(Team 1), Current Array Element.IsWinner), Ring, Color(Rose),
			Global.WinnerResetRingStats[0], Global.WinnerResetRingStats[1], Visible To);
		Global.WinnerResetRingStats[2] = Last Created Entity;
		Create In-World Text(Filtered Array(All Players(Team 1), Current Array Element.IsWinner), Custom String("[Reload] to Start Over",
			Input Binding String(Button(Reload))), Global.WinnerResetRingStats[0] + Global.WinnerResetRingStats[3], 1.300,
			Clip Against Surfaces, Visible To, Color(White), Default Visibility);
	}
}

rule("Select the next winner hero using ring (END GAME)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.IsWinner == True;
		Global.WinnerHeroesRingStats[2] != Null;
		Is Button Held(Event Player, Button(Jump)) == True;
		Is True For Any(Players Within Radius(Global.WinnerHeroesRingStats[0], Global.WinnerHeroesRingStats[1], Team 1, Off),
			Current Array Element == Event Player) == True;
	}

	actions
	{
		If(Event Player.WinnerHeroCursor == Count Of(Global.WinnerHeroesList) - 1);
			Event Player.WinnerHeroCursor = 0;
		Else;
			Event Player.WinnerHeroCursor += 1;
		End;
		Start Forcing Player To Be Hero(Event Player, Global.WinnerHeroesList[Event Player.WinnerHeroCursor]);
		Wait(0.250, Abort When False);
	}
}

rule("Select the previous winner hero using ring (END GAME)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.IsWinner == True;
		Global.WinnerHeroesRingStats[2] != Null;
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is True For Any(Players Within Radius(Global.WinnerHeroesRingStats[0], Global.WinnerHeroesRingStats[1], Team 1, Off),
			Current Array Element == Event Player) == True;
	}

	actions
	{
		If(Event Player.WinnerHeroCursor == 0);
			Event Player.WinnerHeroCursor = Count Of(Global.WinnerHeroesList) - 1;
		Else;
			Event Player.WinnerHeroCursor -= 1;
		End;
		Start Forcing Player To Be Hero(Event Player, Global.WinnerHeroesList[Event Player.WinnerHeroCursor]);
		Wait(0.250, Abort When False);
	}
}

rule("Reset winner using ring (END GAME)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.IsWinner == True;
		Global.WinnerResetRingStats[2] != Null;
		Is Button Held(Event Player, Button(Reload)) == True;
		Is True For Any(Players Within Radius(Global.WinnerResetRingStats[0], Global.WinnerResetRingStats[1], Team 1, Off),
			Current Array Element == Event Player) == True;
	}

	actions
	{
		Event Player.BacktrackDeaths = 0;
		Event Player.IsWinner = False;
		Event Player.Deaths = 0;
		Event Player.WinnerHeroCursor = 0;
		Event Player.CurrentHero = 0;
		Event Player.TargetHero = 0;
		Modify Global Variable(SavedHero, Remove From Array By Index, Index Of Array Value(Global.SavedIndex, Custom String("{0}",
			Event Player)));
		Modify Global Variable(SavedDeaths, Remove From Array By Index, Index Of Array Value(Global.SavedIndex, Custom String("{0}",
			Event Player)));
		Modify Global Variable(SavedWinners, Remove From Array By Index, Index Of Array Value(Global.SavedIndex, Custom String("{0}",
			Event Player)));
		Modify Global Variable(SavedBacktrackDeaths, Remove From Array By Index, Index Of Array Value(Global.SavedIndex, Custom String(
			"{0}", Event Player)));
		Modify Global Variable(SavedIndex, Remove From Array By Value, Custom String("{0}", Event Player));
		Stop Forcing Player Outlines(Event Player, All Players(Team 1));
		Set Move Speed(Event Player, 100);
		If(Event Player.WinnerDeathID != Null);
			Destroy HUD Text(Event Player.WinnerDeathID);
			Event Player.WinnerDeathID = Null;
	}
}

rule("Spawn ALL players at alternate spawn location[SR]")
{
	event
	{
		Subroutine;
		SpawnAllAtAltLoc;
	}

	actions
	{
		If(Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter));
			Teleport(All Players(Team 1), Global.BlizzWorldSpawnLoc);
			Set Facing(All Players(Team 1), Forward + Left, To World);
		Else If(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween));
			Teleport(All Players(Team 1), Global.HollywoodSpawns[0]);
			Set Facing(All Players(Team 1), Right, To World);
		End;
	}
}

rule("Spawn players at alternate spawn location[SR]")
{
	event
	{
		Subroutine;
		SpawnAtAltLoc;
	}

	actions
	{
		If(Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter));
			Teleport(Event Player, Global.BlizzWorldSpawnLoc);
			Set Facing(Event Player, Forward + Left, To World);
		Else If(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween));
			Teleport(Event Player, Global.HollywoodSpawns[0]);
			Set Facing(Event Player, Right, To World);
		End;
	}
}

rule("Game settings world HUD")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		Call Subroutine(SetupGameSettingsText);
		For Global Variable(TempVar, Count Of(Global.GameSettingsHUDWT) - 1, -1, -1);
			Create In-World Text(All Players(Team 1), Global.GameSettingsHUDWT[Global.TempVar], Global.GameOptTextVec, 1.500,
				Clip Against Surfaces, Visible To, Color(Lime Green), Default Visibility);
			Call Subroutine(IncrementGameSettingsPos);
		End;
		"World game settings HUD"
		Create In-World Text(All Players(Team 1), Custom String("Game Settings"), Global.GameSettingTextVec, 2.750, Clip Against Surfaces,
			Visible To, Color(Rose), Default Visibility);
	}
}

rule("setup game option settings text for world HUD [SR]")
{
	event
	{
		Subroutine;
		SetupGameSettingsText;
	}

	actions
	{
		Global.GameSettingsHUDWT = Empty Array;
		Modify Global Variable(GameSettingsHUDWT, Append To Array, Custom String("Hero Order: [{0}]",
			Global.HeroListTypeWS == 0 ? Custom String("Normal") : (Global.HeroListTypeWS == 1 ? Custom String("Random") : (
			Global.HeroListTypeWS == 2 ? Custom String("Independent") : Custom String("Custom")))));
		Modify Global Variable(GameSettingsHUDWT, Append To Array, Custom String("Global Effect: [{0}]",
			Global.IsGEEnabledWS ? Custom String("Enabled") : Custom String("Disabled")));
		If(Global.BacktrackDeathsWS != 0);
			Modify Global Variable(GameSettingsHUDWT, Append To Array, Custom String("Backtrack Range: [{0}] <-----> [{1}]",
				Global.BacktrackMinMaxListWS[0], Global.BacktrackMinMaxListWS[1]));
		End;
		Modify Global Variable(GameSettingsHUDWT, Append To Array, Custom String("Bastion Position: [{0}]",
			Global.BastionPosTypeWS == 0 ? Custom String("Original") : (Global.BastionPosTypeWS == 1 ? Custom String("Randomized") : (
			Global.BastionPosTypeWS == 2 ? Custom String("Random Once") : Custom String("On Escape")))));
		Global.GameOptTextVec = Global.GameSettingTextVec;
		"Height of \"Game Setting\" title from options"
		Global.GameSettingTextVec += Vector(0, 0.150, 0);
		"The \"Next Map Cycle Option\""
		If(Global.WinnerCountToCycleWS != 0);
			Create In-World Text(All Players(Team 1), Custom String("WInners Until Next Map: [{0}] / [{1}]", Global.CurWinnerCount,
				Global.WinnerCountToCycleWS), Global.GameOptTextVec, 1.500, Clip Against Surfaces, Visible To and String, Color(Yellow),
				Default Visibility);
			Call Subroutine(IncrementGameSettingsPos);
		End;
	}
}

rule("Increment game settings HUD position[SR]")
{
	event
	{
		Subroutine;
		IncrementGameSettingsPos;
	}

	actions
	{
		"The spacing between each game setting in the HUD"
		Global.GameOptTextSpacing = Vector(0, 0.600, 0);
		Global.GameOptTextVec += Global.GameOptTextSpacing;
		Global.GameSettingTextVec += Global.GameOptTextSpacing;
	}
}

rule("Buff positions (Default) (Global T, Global J)")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.T = Empty Array;
		Global.JumpPadLocList = Empty Array;
		Global.JumpPadPowerList = Empty Array;
		Global.Y = -1;
	}
}

rule("Activate teleporters if spawn room doors is inaccessible - hollywood")
{
	event
	{
		Player Joined Match;
		Team 1;
		Slot 0;
	}

	conditions
	{
		(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween)) == True;
		"Bad spawn point"
		Distance Between(Event Player, Global.HollywoodSpawns[1]) <= 15;
	}

	actions
	{
		"Sometimes, the doors to spawn room 3 would be closed. These actions will force the players inside the room. The teleporters will allow players to leave the room at will."
		Global.isTeleporterEnabled = True;
		Call Subroutine(SpawnAtAltLoc);
	}
}

rule("Teleporter position init (global T) - paris")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.T == Empty Array;
		Current Map == Map(Paris);
	}

	actions
	{
		"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
		Global.T = Array(Vector(-23.879, 16.341, 15.498), Vector(-10.647, 15.349, -39.465));
	}
}

rule("Teleporter position init (global T) - nepal")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.T == Empty Array;
		Current Map == Map(Nepal);
	}

	actions
	{
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		"Village"
		If(Count Of(Players Within Radius(Vector(-160.389, -94.271, -84.060), 30, Team 1, Off)) != 0);
			"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
			Global.T = Array(Vector(-220.003, -94.746, -24.949), Vector(-220.392, -93.377, -10.542), Vector(-220.104, -94.205, 13.117), Vector(
				-220.205, -94.747, 25.866));
		"Sanctum"
		Else If(Count Of(Players Within Radius(Vector(82.236, 133.730, -90.834), 30, Team 1, Off)) != 0);
			Global.T = Array(Vector(96.787, 129.300, -0.132), Vector(105.339, 133.942, 32.889));
	}
}

rule("Teleporter position init (global T) - hollywood")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.isTeleporterEnabled == True;
		Global.T == Empty Array;
		(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween)) == True;
	}

	actions
	{
		Global.T = Array(Vector(-52.836, 5.050, -148.546), Vector(-52.562, 5.050, -147.402), Vector(-14.796, 5.050, -147.334), Vector(
			-15.813, 5.050, -146.567));
	}
}

rule("Teleporter position init (global T) - hanamura")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.T == Empty Array;
		(Current Map == Map(Hanamura) || Current Map == Map(Hanamura Winter)) == True;
	}

	actions
	{
		Global.T = Array(Vector(-28.532, 2.301, -57.827), Vector(-12.406, 2.299, -32.859), Vector(26.500, 1.200, 7.857), Vector(46.023,
			1.768, 38.157));
	}
}

rule("Teleporter position init (global T) - king's row")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.T == Empty Array;
		(Current Map == Map(King's Row) || Current Map == Map(King's Row Winter)) == True;
	}

	actions
	{
		"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
		Global.T = Array(Vector(-13.206, 1.700, 2.599), Vector(-26.548, 7.744, 8.545), Vector(-69.864, 1.050, 0.780), Vector(-67.829,
			1.550, 1.166), Vector(-56.445, 6.450, -11.168), Vector(-58.004, 6.122, -11.574));
	}
}

rule("Teleporter position init (global T) - illios")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.T == Empty Array;
		Current Map == Map(Ilios);
	}

	actions
	{
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		"Well"
		If(Count Of(Players Within Radius(Vector(-152.014, -1.104, -93.120), 30, Team 1, Off)) != 0);
			"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
			Global.T = Array(Vector(-219.430, 1.300, -22.312), Vector(-199.053, 2.315, -6.979), Vector(-196.207, 2.315, -4.372), Vector(
				-214.369, 1.300, -26.572));
		"Ruins"
		Else If(Count Of(Players Within Radius(Vector(131.609, 64.254, -159.135), 30, Team 1, Off)) != 0);
			"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
			Global.T = Array(Vector(59.421, 61.917, -140.094), Vector(41.130, 67.671, -144.216), Vector(-1.989, 61.668, -167.644), Vector(
				-0.496, 65.784, -170.078));
	}
}

rule("Jump pad position init (global J)(global K) - nepal")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.JumpPadLocList == Empty Array;
		Current Map == Map(Nepal);
	}

	actions
	{
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		"Shrine"
		If(Count Of(Players Within Radius(Vector(-41.729, 19.079, -93.923), 30, Team 1, Off)) != 0);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-27.684, 16.779, -62.910));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 16);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-45.142, 16.300, -60.279));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 12);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-28.075, 16.300, 81.503));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 16);
		"Village"
		Else If(Count Of(Players Within Radius(Vector(-160.389, -94.271, -84.060), 30, Team 1, Off)) != 0);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-216.263, -94.689, 24.938));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 12);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-194.944, -92.303, -10.583));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 16);
	}
}

rule("Jump pad position init (global J)(global K) - illios")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.JumpPadLocList == Empty Array;
		Current Map == Map(Ilios);
	}

	actions
	{
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		"Town"
		If(Count Of(Players Within Radius(Vector(322.692, -21.520, 42.832), 30, Team 1, Off)) != 0);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(370.190, -27.343, -56.901));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 20);
		"Well"
		Else If(Count Of(Players Within Radius(Vector(-152.014, -1.104, -93.120), 30, Team 1, Off)) != 0);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-230.206, 0.300, -32.998));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 16);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-224.623, 0.300, -38.636));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 16);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-198.022, 2.300, 5.441));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 16);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-218.367, 6.529, 15.425));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 12);
		"Ruins"
		Else If(Count Of(Players Within Radius(Vector(131.609, 64.254, -159.135), 30, Team 1, Off)) != 0);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(77.862, 60.082, -171.666));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 16);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-49.604, 61.667, -178.331));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 14);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-54.233, 61.619, -158.073));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 18);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-56.603, 66.734, -171.348));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 14);
	}
}

rule("Jump pad position init (global J) - havana")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.JumpPadLocList == Empty Array;
		Current Map == Map(Havana);
	}

	actions
	{
		Modify Global Variable(JumpPadLocList, Append To Array, Vector(103.926, 3.104, -25.884));
		Modify Global Variable(JumpPadPowerList, Append To Array, 18);
	}
}

rule("Jump pad position init (global J, global K) - hanamura")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.JumpPadLocList == Empty Array;
		(Current Map == Map(Hanamura) || Current Map == Map(Hanamura Winter)) == True;
	}

	actions
	{
		Modify Global Variable(JumpPadLocList, Append To Array, Vector(33.167, 3, -24.676));
		Modify Global Variable(JumpPadPowerList, Append To Array, 18);
	}
}

rule("disable ult")
{
	event
	{
		Player Died;
		All;
		All;
	}

	actions
	{
		Disallow Button(Event Player, Button(Ultimate));
	}
}

rule("bastion enable turret mode")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
		Is In Alternate Form(Event Player) == False;
		"Bastion Bullets"
		Global.BUChoices[0] != 4;
	}

	actions
	{
		Allow Button(Event Player, Button(Ability 1));
		Press Button(Event Player, Button(Ability 1));
		Teleport(Event Player, Global.AllBastionPositions[Slot Of(Event Player)]);
		Disable Nameplates(Event Player, All Players(All Teams));
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("bastion teleport and init (player E, global d)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Wait(0.250, Ignore Condition);
		Teleport(Event Player, Global.AllBastionPositions[Slot Of(Event Player)]);
		Set Status(Event Player, Null, Unkillable, 99999);
		Set Damage Dealt(Event Player, Global.BastionDamages[0]);
		Set Knockback Received(Event Player, 1);
	}
}

rule("Randomize Bastion positions (RBP)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Global.BastionPosTypeWS == 1 || Global.BastionPosTypeWS == 2) == True;
	}

	actions
	{
		If(Global.BastionPosTypeWS == 1);
			"Lag intervals"
			Wait(Random Real(Global.BastionPosIntervalMinMaxWS[0], Global.BastionPosIntervalMinMaxWS[1]), Ignore Condition);
			Big Message(All Players(Team 1), Custom String("Changing Bastion Positions...."));
			Wait(1.500, Ignore Condition);
		End;
		Global.RBPIndex = 0;
		While(Global.RBPIndex < Count Of(Global.AllBastionPositions));
			Call Subroutine(SetNewBastionPosition);
			Wait(0.200, Ignore Condition);
		End;
		Loop If(Global.BastionPosTypeWS == 1);
	}
}

rule("Set new randomized Bastion positions (RBP)[SR]")
{
	event
	{
		Subroutine;
		SetNewBastionPosition;
	}

	actions
	{
		Global.BastionPosLocType = Random Integer(0, 25);
		Global.BastionPosDistance = Random Real(1, 50);
		If(Global.BastionPosLocType == 0);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(
				Global.AllBastionPositions[Global.RBPIndex] + Forward * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 1);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Forward + Right) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 2);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(
				Global.AllBastionPositions[Global.RBPIndex] + Right * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 3);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Backward + Right) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 4);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(
				Global.AllBastionPositions[Global.RBPIndex] + Backward * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 5);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Backward + Left) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 6);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(
				Global.AllBastionPositions[Global.RBPIndex] + Left * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 7);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Forward + Left) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 8);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Forward + Down) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 9);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Forward + Up) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 10);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (Right + Up)
				* Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 11);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Right + Down) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 12);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Backward + Down) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 13);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Backward + Up) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 14);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (Left + Up)
				* Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 15);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (Left + Down)
				* Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 16);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Forward + Right + Up) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 17);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Forward + Right + Down) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 18);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Backward + Right + Down) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 19);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Backward + Right + Up) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 20);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Forward + Left + Up) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 21);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Forward + Left + Down) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 22);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Backward + Left + Down) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 23);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Backward + Left + Up) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 24);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(
				Global.AllBastionPositions[Global.RBPIndex] + Up * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 25);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(
				Global.AllBastionPositions[Global.RBPIndex] + Down * Global.BastionPosDistance);
		End;
		Call Subroutine(RBPCheckAndSet);
	}
}

rule("Check Bastion position before setting it (RPB)[SR]")
{
	event
	{
		Subroutine;
		RBPCheckAndSet;
	}

	actions
	{
		If(!Is In Spawn Room(Players In Slot(Global.RBPIndex, Team 2)));
			If((Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter)) && Distance Between(
				Global.AllBastionPositions[Global.RBPIndex], Global.BlizzWorldSpawnLoc) > 30);
				Global.RBPIndex += 1;
				Teleport(Players In Slot(Global.RBPIndex, Team 2), Global.AllBastionPositions[Global.RBPIndex]);
			Else If((Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween)) && Distance Between(
					Global.AllBastionPositions[Global.RBPIndex], Global.HollywoodSpawns[0]) > 26);
				Global.RBPIndex += 1;
				Teleport(Players In Slot(Global.RBPIndex, Team 2), Global.AllBastionPositions[Global.RBPIndex]);
			Else If(Current Map == Map(Dorado) && Distance Between(Global.AllBastionPositions[Global.RBPIndex], Vector(189.103, 8.041, 42.415))
					> 18);
				Global.RBPIndex += 1;
				Teleport(Players In Slot(Global.RBPIndex, Team 2), Global.AllBastionPositions[Global.RBPIndex]);
			Else If((Current Map == Map(Ilios) || Current Map == Map(Lijiang Tower) || Current Map == Map(Lijiang Tower Lunar New Year)
					|| Current Map == Map(Nepal)) && Distance Between(Global.AllBastionPositions[Global.RBPIndex], Random Value In Array(
					Spawn Points(Team 1))) > 25);
				Global.RBPIndex += 1;
				Teleport(Players In Slot(Global.RBPIndex, Team 2), Global.AllBastionPositions[Global.RBPIndex]);
			Else If(Current Map == Map(Junkertown) && Distance Between(Global.AllBastionPositions[Global.RBPIndex], Random Value In Array(
					Spawn Points(Team 1))) > 27);
				Global.RBPIndex += 1;
				Teleport(Players In Slot(Global.RBPIndex, Team 2), Global.AllBastionPositions[Global.RBPIndex]);
			Else If(Array Contains(Global.RBPDefaultMaps, Current Map) && Distance Between(Global.AllBastionPositions[Global.RBPIndex],
					Random Value In Array(Spawn Points(Team 1))) > 30);
				Global.RBPIndex += 1;
				Teleport(Players In Slot(Global.RBPIndex, Team 2), Global.AllBastionPositions[Global.RBPIndex]);
	}
}

rule("Change Bastion positions when player escapes (RBP)[SR]")
{
	event
	{
		Subroutine;
		NewBastionPosOnEscape;
	}

	actions
	{
		If(Global.BastionPosTypeWS == 3);
			Global.RBPIndex = 0;
			While(Global.RBPIndex < Count Of(Global.AllBastionPositions));
				Call Subroutine(SetNewBastionPosition);
				Wait(0.300, Ignore Condition);
			End;
	}
}

rule("push players back from team 2")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.IsWinner != True;
		Global.IsDebugMode == False;
		(Hero Of(Event Player) == Hero(Bastion) || Hero Of(Event Player) == Hero(Roadhog)) == True;
		Is True For Any(Players Within Radius(Position Of(Event Player), 3, Team 1, Off), Current Array Element != Null) == True;
	}

	actions
	{
		Event Player.playerToPushBack = Closest Player To(Position Of(Event Player), Team 1);
		Skip If(Is In Air(Event Player.playerToPushBack) == True, 1);
		Apply Impulse(Event Player.playerToPushBack, Position Of(Event Player.playerToPushBack) - Position Of(Event Player), 10, To World,
			Cancel Contrary Motion);
		Skip If(Is In Air(Event Player.playerToPushBack) == False, 1);
		Apply Impulse(Event Player.playerToPushBack, Position Of(Event Player.playerToPushBack) - Position Of(Event Player), 5, To World,
			Cancel Contrary Motion);
		Wait(0.150, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("teleport bastions back")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Distance Between(Event Player, Global.AllBastionPositions[Slot Of(Event Player)]) > 2;
	}

	actions
	{
		Teleport(Event Player, Global.AllBastionPositions[Slot Of(Event Player)]);
		Wait(0.100, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Display message to players attempting to shoot Bastion")
{
	event
	{
		Player Took Damage;
		Team 2;
		Bastion;
	}

	actions
	{
		Big Message(Attacker, Custom String("I'm invincible! Stop hurting me!"));
		Wait(2, Ignore Condition);
	}
}

rule("Display info about the goal of the game")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.CurrentHero == 0;
		Is In Spawn Room(Event Player) == True;
	}

	actions
	{
		Small Message(Event Player, Custom String("Mission --> Escape prison with all heroes!"));
		Wait(2.900, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Go to next hero [SR]")
{
	event
	{
		Subroutine;
		NextHero;
	}

	actions
	{
		Event Player.CurrentHero += 1;
		Event Player.TargetHero = Event Player.CurrentHero;
	}
}

rule("winner effects on reach to end")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.IsWinner != True;
		Y Component Of(Position Of(Event Player)) >= Y Component Of(Global.EndPosition);
		((Global.GEChoice == 36 && Event Player == Global.GEAffectedPlayer) || (Global.GEChoice != 36)) == True;
		Distance Between(Position Of(Event Player), Vector(X Component Of(Global.EndPosition), Y Component Of(Position Of(Event Player)),
			Z Component Of(Global.EndPosition))) <= 4;
	}

	actions
	{
		Call Subroutine(OneForAllGoal);
		Call Subroutine(EscapeWithKey);
		Call Subroutine(PromoteHeroRider);
		Respawn(Event Player);
		Wait(0.032, Ignore Condition);
		If(Event Player.CurrentHero < Count Of(Global.HeroList) && Event Player.CurrentHero == Event Player.TargetHero);
			Call Subroutine(NextHero);
		End;
		Event Player.BacktrackDeaths = 0;
		If(Event Player.CurrentHero == Count Of(Global.HeroList));
			Event Player.IsWinner = True;
			Skip If(Global.WinnerCountToCycleWS == 0, 1);
			Global.CurWinnerCount += 1;
			Skip If(Global.HeroDataSaveIndexWS == -1, 1);
			Modify Global Variable(SavedWinners, Append To Array, Custom String("{0}", Event Player));
			Big Message(All Players(Team 1), String("{0}!!!", String("{0}, {1}", String("Wow"), String("{0} {1}", Event Player, Custom String(
				"WINS WITH {0} DEATHS!", Event Player.Deaths)))));
		End;
		Play Effect(All Players(Team 1), Buff Explosion Sound, Color(White), Event Player, 200);
		Call Subroutine(SpawnAtAltLoc);
		Call Subroutine(SavePlayerData);
		"RANDOMIZE BASTION POSITION: On Escape mode"
		Call Subroutine(NewBastionPosOnEscape);
	}
}

rule("goal effects")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Create Effect(All Players(Team 1), Ring, Color(Team 1), Global.EndPosition, 4, Visible To Position and Radius);
		Create Effect(All Players(Team 1), Light Shaft, Color(Team 1), Global.EndPosition, 4, Visible To Position and Radius);
		Create Icon(All Players(All Teams), Global.EndPosition + Vector(Empty Array, 5, Empty Array), Flag, Visible To and Position, Color(
			Blue), True);
	}
}

rule("player hud")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsDebugMode == False;
	}

	actions
	{
		If(Global.HeroListTypeWS != 2);
			Create HUD Text(Event Player, Hero Icon String(Global.HeroList[Event Player.TargetHero + 1]), Custom String("Next Hero"),
				Global.HeroList[Event Player.TargetHero + 1], Left, 2, Color(Blue), Color(White), Color(White), Visible To and String,
				Default Visibility);
			Create HUD Text(Event Player, String("{0}: {1}", String("Hero"), !Event Player.IsWinner ? String("{0} / {1}",
				Event Player.CurrentHero + 1, Count Of(Global.HeroList)) : Custom String("Done!")), Null, Null, Left, 0, Color(White), Color(
				White), Color(White), Visible To and String, Default Visibility);
		Else;
			Create HUD Text(Event Player, Hero Icon String(Event Player.IndieHeroList[Event Player.TargetHero + 1]), Custom String(
				"Next Hero"), Event Player.IndieHeroList[Event Player.TargetHero + 1], Left, 2, Color(Blue), Color(White), Color(White),
				Visible To and String, Default Visibility);
			Create HUD Text(Event Player, String("{0}: {1}", String("Hero"), !Event Player.IsWinner ? String("{0} / {1}",
				Event Player.CurrentHero + 1, Count Of(Event Player.IndieHeroList)) : Custom String("Done!")), Null, Null, Left, 0, Color(
				White), Color(White), Color(White), Visible To and String, Default Visibility);
		End;
		Skip If(Global.BacktrackDeathsWS == 0, 1);
		Create HUD Text(Event Player, Custom String("Backtrack Deaths: {0}/{1}, [{2}x]", Event Player.BacktrackDeaths,
			Global.BacktrackDeathsWS, Global.BacktrackSteps), Null, Null, Left, 1, Color(Red), Color(White), Color(White),
			Visible To and String, Default Visibility);
	}
}

rule("infinity game")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is In Setup == False;
	}

	actions
	{
		Wait(300, Ignore Condition);
		Set Match Time(3599);
	}
}

rule("heal")
{
	event
	{
		Player Took Damage;
		Team 1;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Global.GEToggles[0] == False;
	}

	actions
	{
		Stop All Heal Over Time(Event Player);
		Wait(2, Abort When False);
		Play Effect(All Players(All Teams), Buff Impact Sound, Color(Yellow), Event Player, 2);
		Start Heal Over Time(Event Player, Event Player, 9999, 25);
	}
}

rule("deaths counter")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.IsWinner == False;
		Attacker != Null;
		Attacker != Event Player;
	}

	actions
	{
		Event Player.Deaths += 1;
		Call Subroutine(AddBacktrackDeath);
	}
}

rule("Backtrack a hero after many deaths")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.IsWinner == False;
		Global.BacktrackDeathsWS != 0;
		Event Player.BacktrackDeaths >= Global.BacktrackDeathsWS;
	}

	actions
	{
		Respawn(Event Player);
		Call Subroutine(SpawnAtAltLoc);
		Event Player.BacktrackDeaths = 0;
		If(Event Player.CurrentHero != 0);
			Event Player.randBacktrackNum = Random Integer(Global.BacktrackMinMaxListWS[0], Global.BacktrackMinMaxListWS[1]);
			If(Event Player.CurrentHero - Event Player.randBacktrackNum < 0);
				Event Player.CurrentHero = 0;
			Else;
				Event Player.CurrentHero = Event Player.CurrentHero - Event Player.randBacktrackNum;
			End;
			Event Player.TargetHero = Event Player.CurrentHero;
		End;
		Call Subroutine(SavePlayerData);
		Wait(3, Ignore Condition);
		If(Event Player.CurrentHero == 0);
			Small Message(Event Player, Custom String("Backtracked to the very first hero!"));
		Else If(Event Player.randBacktrackNum == 1);
			Small Message(Event Player, Custom String("Backtracked a single hero!"));
		Else If(Event Player.randBacktrackNum >= 7);
			Small Message(Event Player, Custom String("Yikes! Backtracked {0} heroes! Be careful next time!"));
		Else;
			Small Message(Event Player, Custom String("Backtracked {0} heroes!", Event Player.randBacktrackNum));
		End;
	}
}

rule("Increment backtrack death & save [SR]")
{
	event
	{
		Subroutine;
		AddBacktrackDeath;
	}

	actions
	{
		Skip If(Global.BacktrackDeathsWS == 0, 1);
		Event Player.BacktrackDeaths += Global.BacktrackSteps;
		Call Subroutine(SavePlayerData);
	}
}

rule("Destroy D.Va's mech goal HUD")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Is In Alternate Form(Event Player) == False;
		Event Player.H[1] != Null;
	}

	actions
	{
		Call Subroutine(DestroyDVAMechHUD);
	}
}

rule("Destroy goal HUD for D.Va mech [SR]")
{
	event
	{
		Subroutine;
		DestroyDVAMechHUD;
	}

	actions
	{
		If(Event Player.H[1] != Null);
			Wait(0.250, Abort When False);
			Destroy HUD Text(Event Player.H[1]);
			Event Player.H[1] = Null;
			If(Global.IsDVADebug == True);
				Modify Player Variable(Event Player, DVADebugStates, Append To Array, Custom String("Destroy Mech Goal HUD"));
			End;
	}
}

rule("Create D.Va's goal HUD for mech")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Is In Alternate Form(Event Player) == True;
		Event Player.H[1] == Null;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.M = Position Of(Event Player) * Vector(1, Empty Array, 1);
		Create HUD Text(Event Player, String("{0}: {1}", String("{0} {1}", String("Goal"), String("Distance")), Max(0,
			50 - Distance Between(Position Of(Event Player) * Vector(1, Empty Array, 1), Event Player.M))), Null, Null, Top, 5, Color(
			White), Color(White), Color(White), Visible To and String, Default Visibility);
		Event Player.H[1] = Last Text ID;
		If(Global.IsDVADebug == True);
			Modify Player Variable(Event Player, DVADebugStates, Append To Array, Custom String("Create Mech Goal HUD"));
		End;
	}
}

rule("if D.Va haven't reached 50 meters yet")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Is In Alternate Form(Event Player) == True;
		Is In Spawn Room(Event Player) == False;
		Event Player.H[1] != Null;
		Distance Between(Position Of(Event Player) * Vector(1, Empty Array, 1), Event Player.M) < 50;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 2 * Distance Between(Position Of(Event Player) * Vector(1, Empty Array, 1), Event Player.M));
		Wait(0.100, Ignore Condition);
		Loop If Condition Is True;
		If(Global.IsDVADebug == True);
			Modify Player Variable(Event Player, DVADebugStates, Append To Array, Custom String("Not Reached Goal"));
	}
}

rule("If D.Va passes 50 meters")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Is In Alternate Form(Event Player) == True;
		Is In Spawn Room(Event Player) == False;
		Event Player.H[1] != Null;
		Distance Between(Position Of(Event Player) * Vector(1, Empty Array, 1), Event Player.M) >= 50;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 100);
		If(Global.IsDVADebug == True);
			Modify Player Variable(Event Player, DVADebugStates, Append To Array, Custom String("Reached Goal"));
	}
}

rule("If D.Va calls mech")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Is In Alternate Form(Event Player) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Event Player.H[1] != Null;
	}

	actions
	{
		Allow Button(Event Player, Button(Ultimate));
		Wait(0.400, Ignore Condition);
		"Automatically place D.Va in her mech if she has her ultimate"
		Press Button(Event Player, Button(Ultimate));
		Loop If(Ultimate Charge Percent(Event Player) == 100);
		Disallow Button(Event Player, Button(Ultimate));
		If(Global.IsDVADebug == True);
			Modify Player Variable(Event Player, DVADebugStates, Append To Array, Custom String("Mech Called"));
		End;
	}
}

rule("If D.Va respawns in alternative form")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Is In Spawn Room(Event Player) == True;
		Is In Alternate Form(Event Player) == True;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 100);
		If(Global.IsDVADebug == True);
			Modify Player Variable(Event Player, DVADebugStates, Append To Array, Custom String("Respawn in Alt form"));
	}
}

disabled rule("D.Va states (debug)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Global.IsDebugMode == True;
	}

	actions
	{
		Event Player.DVADebugStates = Empty Array;
		Global.IsDVADebug = True;
	}
}

rule("Removes ult gained from D.Va while in mech")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Is In Alternate Form(Event Player) == False;
		Ultimate Charge Percent(Event Player) > 0;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 0);
	}
}

rule("If D.Va dies")
{
	event
	{
		Player Died;
		Team 1;
		D.Va;
	}

	actions
	{
		Set Move Speed(Event Player, 0);
		Wait(0.300, Ignore Condition);
		If(Is Alive(Event Player) && !Is In Spawn Room(Event Player));
			"This extra respawn is important!!! If Baby D.Va dies while getting into her mech, she will be permanently stuck at spawn point unrendered.  "
			Respawn(Event Player);
		End;
		If(Is In Alternate Form(Event Player) == True);
			Set Ultimate Charge(Event Player, 100);
		Else;
			Call Subroutine(DestroyDVAMechHUD);
			Event Player.H[1] = Null;
		End;
		Set Move Speed(Event Player, 100);
		If(Global.IsDVADebug == True);
			Modify Player Variable(Event Player, DVADebugStates, Append To Array, Custom String("Died"));
	}
}

rule("destroy hud if player is not D.Va anymore")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Hero Of(Event Player) != Hero(D.Va);
		Event Player.H[1] != Null;
	}

	actions
	{
		Destroy HUD Text(Event Player.H[1]);
		Wait(0.032, Ignore Condition);
		Event Player.H[1] = Null;
	}
}

rule("Create jump pad effects [SR]")
{
	event
	{
		Subroutine;
		CreateJumpPads;
	}

	actions
	{
		If(Global.Y < Count Of(Global.JumpPadLocList) && Global.JumpPadLocList != Empty Array);
			Create Effect(All Players(All Teams), Sparkles, Color(Green), Global.JumpPadLocList[Global.Y], Global.JumpPadRadius, Visible To);
	}
}

rule("Create teleport effects [SR]")
{
	event
	{
		Subroutine;
		CreateTeleporters;
	}

	actions
	{
		If(Global.Y < Count Of(Global.T) && Global.T != Empty Array);
			Skip If(Global.Y % 2 == 0, 1);
			Create Effect(All Players(All Teams), Bad Aura, Color(Red), Global.T[Global.Y], 1, Visible To);
			Skip If(Global.Y % 2 == 1, 1);
			Create Effect(All Players(All Teams), Good Aura, Color(Red), Global.T[Global.Y], 1, Visible To);
	}
}

rule("Chase Y from 0 to 100 to create effects")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.Y == -1;
	}

	actions
	{
		Global.Y += 1;
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		Call Subroutine(CreateJumpPads);
		Call Subroutine(CreateTeleporters);
		Wait(0.100, Ignore Condition);
		Loop If(Global.Y < 100);
	}
}

rule("If player near a portal")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.T != Empty Array;
		Is True For Any(Global.T, Distance Between(Current Array Element, Position Of(Event Player)) < 1.500) == True;
	}

	actions
	{
		Event Player.W = Filtered Array(Global.T, Distance Between(Current Array Element, Position Of(Event Player)) < 1.500);
		Skip If(Index Of Array Value(Global.T, Event Player.W) % 2 == 1, 1);
		Teleport(Event Player, Global.T[Index Of Array Value(Global.T, Event Player.W) + 1]);
		Play Effect(All Players(All Teams), Buff Impact Sound, Color(Yellow), Event Player, 1);
	}
}

rule("If player near a jump pad")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.JumpPadLocList != Empty Array;
		Is True For Any(Global.JumpPadLocList, Distance Between(Current Array Element, Position Of(Event Player)) <= Global.JumpPadRadius)
			== True;
	}

	actions
	{
		Apply Impulse(Event Player, Up, Global.JumpPadPowerList[Index Of Array Value(Global.JumpPadLocList, First Of(Filtered Array(
			Global.JumpPadLocList, Distance Between(Position Of(Event Player), Current Array Element) < Global.JumpPadRadius)))], To World,
			Cancel Contrary Motion);
		Play Effect(All Players(Team 1), Buff Impact Sound, Color(White), Event Player, 50);
	}
}

rule("Create current hero HUD (pl h)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.CurrentHero != Event Player.TargetHero;
	}

	actions
	{
		Wait(Random Real(0, 0.100), Ignore Condition);
		Create HUD Text(Event Player, Hero Icon String(Global.HeroList[Event Player.CurrentHero]), Custom String("Current Hero"),
			Global.HeroList[Event Player.CurrentHero], Left, 4, Color(Green), Color(White), Color(White), Visible To and String,
			Default Visibility);
		Event Player.H[0] = Last Text ID;
	}
}

rule("Destroy current hero HUD (pl h)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.CurrentHero == Event Player.TargetHero;
		First Of(Event Player.H) != Null;
	}

	actions
	{
		Destroy HUD Text(First Of(Event Player.H));
		Event Player.H[0] = Null;
	}
}

disabled rule("no dmg (debug)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsDebugMode == True;
	}

	actions
	{
		Set Status(Event Player, Null, Invincible, 9999);
		Set Move Speed(Event Player, 50);
	}
}

disabled rule("speed trigger on (player t0)(debug)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		First Of(Event Player.Z) == True;
		Global.IsDebugMode == True;
	}

	actions
	{
		Set Move Speed(Event Player, 200);
		Set Projectile Speed(Event Player, 200);
	}
}

disabled rule("speed button (debug)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Global.IsDebugMode == True;
	}

	actions
	{
		Event Player.Z[0] = !First Of(Event Player.Z);
	}
}

disabled rule("All positions (debug)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.IsDebugMode == True;
	}

	actions
	{
		Create HUD Text(All Players(All Teams), String("{0}: {1}", Event Player, Position Of(Event Player)), Null, Null, Left, 0, Color(
			White), Color(White), Color(White), Visible To and String, Default Visibility);
	}
}

disabled rule("Ball position (debug)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsDebugMode == True;
		Host Player == Event Player;
	}

	actions
	{
		Create HUD Text(Host Player, Custom String("Ball Position: {0}", Global.GEBallPosition), Null, Null, Left, 0, Color(White), Color(
			White), Color(White), Visible To and String, Default Visibility);
	}
}

disabled rule("======== set debug mode on/off")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.IsDebugMode = True;
		Enable Inspector Recording;
	}
}

disabled rule("Last Hero (debug)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsDebugMode == True;
	}

	actions
	{
		Event Player.CurrentHero = 31;
		Event Player.TargetHero = Event Player.CurrentHero;
	}
}

disabled rule("Fast Hero (debug)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsDebugMode == True;
		Is Button Held(Event Player, Button(Melee)) == True;
	}

	actions
	{
		If(Event Player.CurrentHero < 31);
			Call Subroutine(NextHero);
			Wait(0.625, Ignore Condition);
	}
}

rule("Add Bastion Bots")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Bastion))) < Global.BastionBotCount;
	}

	actions
	{
		Create Dummy Bot(Hero(Bastion), Team 2, -1, Random Value In Array(Spawn Points(Team 2)), Left - Left);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("No Hud")
{
	event
	{
		Player Joined Match;
		Team 1;
		All;
	}

	actions
	{
		Disable Game Mode HUD(Event Player);
		Disable Kill Feed(Event Player);
		Disable Scoreboard(Event Player);
	}
}

rule("Rename Bastion On Join")
{
	event
	{
		Player Joined Match;
		Team 2;
		Bastion;
	}

	actions
	{
		Start Forcing Dummy Bot Name(Event Player, Custom String("BASTION {0}", Slot Of(Event Player) + 1));
	}
}

rule("Bastion Bot Enemy Search")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Event Player.temp = Filtered Array(All Living Players(Opposite Team Of(Team Of(Event Player))), (Is In Line of Sight(Eye Position(
			Event Player), Eye Position(Current Array Element), Barriers Do Not Block LOS) == True || Is In Line of Sight(Eye Position(
			Event Player), Position Of(Current Array Element), Barriers Do Not Block LOS) == True) && Has Spawned(Current Array Element)
			&& Current Array Element.IsWinner == False && (Hero Of(Current Array Element) != Hero(Sombra) || !Is Using Ability 1(
			Current Array Element)) && (Hero Of(Current Array Element) != Hero(Reaper) || !Is Using Ability 1(Current Array Element)) && (
			Hero Of(Current Array Element) != Hero(Moira) || !Is Using Ability 1(Current Array Element)));
		Wait(0.016, Ignore Condition);
		Event Player.Enemy = Random Value In Array(Event Player.temp);
		Wait(Random Real(0.256, 0.512), Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Bastion Bot Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Event Player.Enemy != Null;
		Is Button Held(Event Player, Button(Primary Fire)) == False;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Primary Fire));
	}
}

rule("Bastion Bot Stop Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Event Player.Enemy == Null;
	}

	actions
	{
		Stop Holding Button(Event Player, Button(Primary Fire));
	}
}

rule("Bastion Bot Aim Position")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Event Player.Enemy != Null;
	}

	actions
	{
		Event Player.TempAimPosition = Vector(X Component Of(Eye Position(Event Player.Enemy)), Y Component Of(Position Of(
			Event Player.Enemy)) + (Y Component Of(Eye Position(Event Player.Enemy)) - Y Component Of(Position Of(Event Player.Enemy)))
			/ 2, Z Component Of(Eye Position(Event Player.Enemy)));
		If(Is In Line of Sight(Eye Position(Event Player), Event Player.TempAimPosition, Barriers Do Not Block LOS) == True);
			Event Player.AimPosition = Event Player.TempAimPosition;
		Else;
			If(Is In Line of Sight(Eye Position(Event Player), Eye Position(Event Player.Enemy), Barriers Do Not Block LOS) == True);
				Event Player.AimPosition = Eye Position(Event Player.Enemy);
			Else;
				Event Player.AimPosition = Position Of(Event Player.Enemy);
			End;
		End;
		Wait(0.032, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Bastion Bot Aim Position 2")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Event Player.Enemy == Null;
	}

	actions
	{
		Event Player.EnemyUnSeen = First Of(Sorted Array(Filtered Array(All Living Players(Opposite Team Of(Team Of(Event Player))),
			Has Spawned(Current Array Element) && Event Player.IsWinner != True && (Hero Of(Current Array Element) != Hero(Sombra)
			|| !Is Using Ability 1(Current Array Element))), Distance Between(Eye Position(Event Player), Eye Position(
			Current Array Element))));
		Skip If(Event Player.EnemyUnSeen == Null, 1);
		Event Player.AimPosition = Eye Position(Event Player.EnemyUnSeen) + Vector(Random Real(-1, 1), Random Real(-1, 1), Random Real(-1,
			1));
		Wait(Random Real(1, 4), Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Bastion Bot Aim Smoother")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Event Player.Enemy != Null;
	}

	actions
	{
		Event Player.TurnSpeed = Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player),
			Eye Position(Event Player.Enemy))) * 6;
		Event Player.TurnSpeed += Speed Of(Event Player.Enemy) * 6;
		Wait(Server Load Average / 1000, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Bastion Bot Aim Smoother 2")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Event Player.Enemy == Null;
		Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Position Of(
			Event Player.AimPosition))) >= 1;
	}

	actions
	{
		Event Player.TurnSpeed = Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player),
			Position Of(Event Player.AimPosition))) * 7;
		Wait(Server Load Peak / 1000, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Bastion Bot Start Facing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Event Player.AimPosition), Has Status(Event Player,
			Asleep) ? 0 : Event Player.TurnSpeed, To World, Direction and Turn Rate);
	}
}

rule("Bastion Bot Hello")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
		Is Communicating(Player Closest To Reticle(Event Player, Opposite Team Of(Team Of(Event Player))), Hello) == True;
	}

	actions
	{
		Wait(Random Real(1, 3), Ignore Condition);
		Communicate(Event Player, Hello);
	}
}

rule("Bastion Bot Hello 2")
{
	event
	{
		Player Earned Elimination;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
		Random Integer(1, 3) == 1;
	}

	actions
	{
		Wait(Random Real(1, 3), Ignore Condition);
		Communicate(Event Player, Hello);
	}
}

rule("Bastion Bot NULL ENEMY")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Alive(Event Player.Enemy) == False;
	}

	actions
	{
		Event Player.Enemy = Null;
		Event Player.EnemyUnSeen = Null;
	}
}

rule("Sombra Text")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Sombra;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Event Player.Invis = 100;
		Destroy Progress Bar HUD Text(Event Player.InvisibleText);
		Wait(0.032, Ignore Condition);
		Create Progress Bar HUD Text(Event Player.Invis < 100 ? Event Player : Null, Event Player.Invis, Custom String("{0} INVISIBILITY",
			Ability Icon String(Hero(Sombra), Button(Ability 1))), Top, 6, Color(Purple), Color(White), Visible To Values and Color,
			Default Visibility);
		Event Player.InvisibleText = Last Text ID;
	}
}

rule("Sombra Limited Ability 1")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Sombra;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Skip If(Event Player.Invis > 1, 1);
		Press Button(Event Player, Button(Ability 1));
		Skip If(Event Player.Invis <= 0, 1);
		Event Player.Invis -= 0.128;
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Sombra Limited Ability 2")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Sombra;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
		Is Using Ability 1(Event Player) == False;
		Event Player.Invis < 100;
	}

	actions
	{
		Event Player.Invis += 0.128;
		Wait(0.032, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Sombra Remove Text")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
		Hero Of(Event Player) != Hero(Sombra);
	}

	actions
	{
		Destroy Progress Bar HUD Text(Event Player.InvisibleText);
		Event Player.Invis = 100;
	}
}

rule("Spawn Dead Players")
{
	event
	{
		Player Died;
		All;
		All;
	}

	conditions
	{
		Is Dead(Event Player) == True;
		Count Of(Filtered Array(All Players(All Teams), Has Spawned(Current Array Element) && Hero Of(Current Array Element) == Hero(
			Mercy))) <= 0;
	}

	actions
	{
		Wait(0.048, Abort When False);
		Respawn(Event Player);
		Remove All Health Pools From Player(Event Player);
		If(Hero Of(Event Player) == Hero(Tracer));
			Set Ability Cooldown(Event Player, Button(Ability 2), 5);
		Else If(Hero Of(Event Player) == Hero(Sombra) && Is Using Ability 2(Event Player));
			Press Button(Event Player, Button(Interact));
		Else If(Hero Of(Event Player) == Hero(Symmetra) && Is Using Ability 2(Event Player));
			Press Button(Event Player, Button(Ability 2));
		End;
	}
}

rule("Brigitte Buff")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Brigitte;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Remove All Health Pools From Player(Event Player);
		Add Health Pool To Player(Event Player, Armor, 50, True, True);
	}
}

rule("Widowmaker Buff")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Widowmaker;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Remove All Health Pools From Player(Event Player);
		Add Health Pool To Player(Event Player, Health, 25, True, True);
	}
}

rule("Remove Buff")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Hero Of(Event Player) != Hero(Brigitte);
		Hero Of(Event Player) != Hero(Widowmaker);
	}

	actions
	{
		Remove All Health Pools From Player(Event Player);
		Wait(1, Ignore Condition);
		Remove All Health Pools From Player(Event Player);
	}
}

rule("Show Bastions Position")
{
	event
	{
		Player Dealt Final Blow;
		Team 2;
		All;
	}

	actions
	{
		Start Forcing Dummy Bot Name(Event Player, Custom String("BASTION {0}", Slot Of(Event Player) + 1));
		Start Forcing Player Outlines(Attacker, Victim, True, Color(Red), Always);
		Wait(12, Ignore Condition);
		Stop Forcing Player Outlines(Attacker, Victim);
	}
}

rule("Sym broke teleport")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Symmetra;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Wait(0.256, Ignore Condition);
		Press Button(Event Player, Button(Ability 2));
	}
}

rule("Sym tel limit")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Symmetra;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Wait(1, Ignore Condition);
		Skip If(!Is Using Ability 2(Event Player), 1);
		Press Button(Event Player, Button(Ability 2));
		Loop If Condition Is True;
	}
}

rule("Update Scoreboard")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(All Players(Team 1)) > 0;
	}

	actions
	{
		Global.ScoreboardArray = Sorted Array(Filtered Array(All Players(Team 1), Current Array Element.IsWinner == False),
			0 - Current Array Element.CurrentHero);
		Global.First = First Of(Global.ScoreboardArray);
		Global.Second = Global.ScoreboardArray[1];
		Global.Third = Global.ScoreboardArray[2];
		Wait(Random Real(2, 4), Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("SPAWN FIX")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		(Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter)) == True;
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Teleport(Event Player, Vector(-166.920, 2.948, 97.847));
		Set Facing(Event Player, Forward, To World);
	}
}

rule("Saving Player Data [SR]")
{
	event
	{
		Subroutine;
		SavePlayerData;
	}

	actions
	{
		If((Event Player.CurrentHero >= Global.HeroDataSaveIndexWS && Global.HeroDataSaveIndexWS != -1) || Array Contains(
			Global.SavedIndex, Custom String("{0}", Event Player)));
			"We're saving data as string, because we cant hold entity id's but we can hold entity names as string."
			Skip If(Array Contains(Global.SavedIndex, Custom String("{0}", Event Player)), 1);
			Modify Global Variable(SavedIndex, Append To Array, Custom String("{0}", Event Player));
			Wait(0.032, Ignore Condition);
			Global.SavedHero[Index Of Array Value(Global.SavedIndex, Custom String("{0}", Event Player))] = Event Player.CurrentHero;
			Global.SavedDeaths[Index Of Array Value(Global.SavedIndex, Custom String("{0}", Event Player))] = Event Player.Deaths;
			Global.SavedBacktrackDeaths[Index Of Array Value(Global.SavedIndex, Custom String("{0}", Event Player))
				] = Event Player.BacktrackDeaths;
			Call Subroutine(PlaySaveUnlockedMSG);
			Small Message(Event Player, Custom String("YOUR PROGRESS DATA WAS SAVED TO SERVER"));
	}
}

rule("Loading Player Data")
{
	event
	{
		Player Joined Match;
		Team 1;
		All;
	}

	conditions
	{
		Global.HeroDataSaveIndexWS != -1;
		Array Contains(Global.SavedIndex, Custom String("{0}", Event Player)) == True;
	}

	actions
	{
		Event Player.CurrentHero = Global.SavedHero[Index Of Array Value(Global.SavedIndex, Custom String("{0}", Event Player))];
		Event Player.TargetHero = Event Player.CurrentHero;
		Event Player.IsWinner = Array Contains(Global.SavedWinners, Custom String("{0}", Event Player));
		Skip If(Event Player.CurrentHero < Global.HeroDataSaveIndexWS, 1);
		Event Player.Deaths = Global.SavedDeaths[Index Of Array Value(Global.SavedIndex, Custom String("{0}", Event Player))];
		Skip If(Global.BacktrackDeathsWS == 0, 1);
		Event Player.BacktrackDeaths = Global.SavedBacktrackDeaths[Index Of Array Value(Global.SavedIndex, Custom String("{0}",
			Event Player))];
		Wait Until(Has Spawned(Event Player), 99999);
		Skip If(Event Player.CurrentHero < Global.HeroDataSaveIndexWS, 1);
		Big Message(Event Player, Custom String("Welcome Back, {0}!", Event Player));
		Call Subroutine(PlaySaveUnlockedMSG);
		Small Message(Event Player, Custom String("YOUR PROGRESS DATA WAS SUCCESSFULLY LOADED FROM THE SERVER"));
		Small Message(Filtered Array(All Players(Team 1), Event Player != Current Array Element), Custom String("HERO {0} LOADED FOR {1}",
			Hero Icon String(Global.HeroList[Event Player.CurrentHero]), Event Player));
	}
}

rule("Display save feature unlocked message [SR]")
{
	event
	{
		Subroutine;
		PlaySaveUnlockedMSG;
	}

	actions
	{
		If(Event Player.CurrentHero == Global.HeroDataSaveIndexWS && !Event Player.hasPlayedSaveMessage);
			Big Message(Event Player, Custom String("Unlocked Save Feature!"));
			Wait(3, Ignore Condition);
		End;
		Event Player.hasPlayedSaveMessage = True;
	}
}

rule("Green outlines for winners")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Event Player.IsWinner == True;
	}

	actions
	{
		Call Subroutine(ApplyWinnerStats);
	}
}

rule("Apply winner outlines [SR]")
{
	event
	{
		Subroutine;
		ApplyWinnerStats;
	}

	actions
	{
		If(Event Player.IsWinner);
			Start Forcing Player Outlines(Event Player, All Players(Team 1), True, Color(Green), Always);
			Disable Nameplates(Event Player, All Players(Team 1));
			Set Move Speed(Event Player, 120);
			If(Event Player.WinnerDeathID == Null);
				Create HUD Text(Event Player, Custom String("Total Deaths: {0}", Event Player.Deaths), Null, Null, Left, 2, Color(Turquoise),
					Color(White), Color(White), Visible To, Default Visibility);
				Event Player.WinnerDeathID = Last Text ID;
	}
}

rule("force player hero")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.IsWinner == False;
		Is Dummy Bot(Event Player) == False;
		((Global.HeroListTypeWS != 2 && Hero Of(Event Player) != Global.HeroList[Event Player.CurrentHero]) || (
			Global.HeroListTypeWS == 2 && Hero Of(Event Player) != Event Player.IndieHeroList[Event Player.CurrentHero])) == True;
	}

	actions
	{
		If(Global.HeroListTypeWS != 2);
			Start Forcing Player To Be Hero(Event Player, Global.HeroList[Event Player.CurrentHero]);
			Wait(0.250, Ignore Condition);
			Preload Hero(Event Player, Array Slice(Global.HeroList, Event Player.CurrentHero + 1, 12));
		Else;
			Start Forcing Player To Be Hero(Event Player, Event Player.IndieHeroList[Event Player.CurrentHero]);
			Wait(0.250, Ignore Condition);
			Preload Hero(Event Player, Array Slice(Event Player.IndieHeroList, Event Player.CurrentHero + 1, 12));
		End;
		Loop If Condition Is True;
		Small Message(Filtered Array(All Players(Team 1), Current Array Element != Event Player), Custom String("{0} is now {1}!",
			Event Player, Hero Icon String(Hero Of(Event Player))));
	}
}

rule("force winner player hero")
{
	event
	{
		Player Joined Match;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.IsWinner == True;
		((Global.HeroListTypeWS != 2 && Event Player.CurrentHero == Count Of(Global.HeroList)) || (
			Global.HeroListTypeWS == 2 && Event Player.CurrentHero == Count Of(Event Player.IndieHeroList))) == True;
	}

	actions
	{
		If(Global.HeroListTypeWS != 2);
			Start Forcing Player To Be Hero(Event Player, Last Of(Global.HeroList));
		Else;
			Start Forcing Player To Be Hero(Event Player, Last Of(Event Player.IndieHeroList));
		End;
		Start Forcing Player Outlines(Event Player, All Players(Team 1), True, Color(Green), Always);
	}
}

disabled rule("Spawn a lot of friendly soldiers. Stress Test (debug)")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Call Subroutine(SpawnFriendlySoldier);
		Call Subroutine(SpawnFriendlySoldier);
		Call Subroutine(SpawnFriendlySoldier);
		Call Subroutine(SpawnFriendlySoldier);
		Call Subroutine(SpawnFriendlySoldier);
		Call Subroutine(SpawnFriendlySoldier);
		Call Subroutine(SpawnFriendlySoldier);
		Call Subroutine(SpawnFriendlySoldier);
	}
}

rule("spawn a friendly soldier (debug)[SR]")
{
	event
	{
		Subroutine;
		SpawnFriendlySoldier;
	}

	actions
	{
		Wait(10, Ignore Condition);
		Create Dummy Bot(Hero(Soldier: 76), Team 1, -1, Eye Position(Host Player) + Facing Direction Of(Host Player) * 5,
			Facing Direction Of(Host Player) * -1);
		Wait(5, Ignore Condition);
		Teleport(Players In Slot(1, Team 1), Position Of(Players In Slot(0, Team 1)));
	}
}

rule("Global Effect (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.GEChoice == 0;
	}

	actions
	{
		"\"DEACTIVATE if not debugging\""
		disabled Call Subroutine(SpawnFriendlySoldier);
		If(Global.IsGEIntervalRandomWS);
			Wait(Random Integer(0.500 * Global.GEIntervalWS, 1.500 * Global.GEIntervalWS), Ignore Condition);
		Else;
			Wait(Global.GEIntervalWS, Ignore Condition);
		End;
		Call Subroutine(SelectGlobalEffect);
	}
}

rule("Select a global effect & configurate (GE)[SR]")
{
	event
	{
		Subroutine;
		SelectGlobalEffect;
	}

	actions
	{
		Global.TempVar = Random Integer(1, 49);
		Global.GEMinPlayerReq = 1;
		"Current NUMBER of players currently around. Used if global effect requires more than 1 player"
		Global.TempVar2 = 1;
		"DEBUG: Chose a specific global effect"
		disabled Global.TempVar = 49;
		If(Global.TempVar == 1);
			"The Patrol Guard to use"
			Global.GEPatrolChoice = Random Integer(0, 2);
			"DEBUGGING: Deactivate if not trying to debug this Global Effect"
			disabled Global.GEPatrolChoice = 1;
			Global.TempVar2 = Randomized Array(Filtered Array(All Players(Team 1), !Is In Spawn Room(Current Array Element)
				&& !Current Array Element.IsWinner));
			Global.TempVar3 = Custom String("Incoming patrols are here to cause mayhem!");
			Global.GEName = Custom String("Patrol Guards!");
			"Set the timer for the Global Effect"
			Call Subroutine(SetPatrolDuration);
		Else If(Global.TempVar == 2);
			Global.TempVar3 = Custom String("Some players will briefly be frozen!");
			Global.GEName = Custom String("Frozen!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(4, 12);
		Else If(Global.TempVar == 3);
			Global.TempVar3 = Custom String("The floor is HOT! Stay in the air!");
			Global.GEName = Custom String("Lava Floor!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(15, 40);
		Else If(Global.TempVar == 4);
			Global.GEMinPlayerReq = 2;
			Global.TempVar3 = Custom String("Some players will switch places!");
			"Switcharoo"
			Global.TempVar2 = Count Of(All Players(Team 1));
			Global.GEName = Custom String("Switcharoo!");
		Else If(Global.TempVar == 5);
			Global.TempVar3 = Custom String("Some players will be sent back to spawn. Yikes!");
			Global.GEName = Custom String("Oof Teleport!");
		Else If(Global.TempVar == 6);
			Global.TempVar3 = Custom String("Some players are invincible!");
			Global.GEName = Custom String("Invincible!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(10, 20);
		Else If(Global.TempVar == 7);
			Global.TempVar3 = Custom String("Say 'Hello','Thanks', 'No', etc. Wait 5 seconds \nbefore each usage..");
			Global.GEName = Custom String("Communicate or Die!");
			"Amount of times to communicate"
			Global.GERequiredNum = Random Integer(1, 3);
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Global.GERequiredNum * 6 + 10;
		Else If(Global.TempVar == 8);
			Global.TempVar3 = Custom String("Stay away from certain players, otherwise you will explode!");
			"I'm the bomb"
			Global.TempVar2 = Count Of(Filtered Array(All Living Players(Team 1), !Is In Spawn Room(Current Array Element)
				&& !Current Array Element.IsWinner));
			Global.GEMinPlayerReq = 2;
			Global.GEName = Custom String("I'm the Bomb!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(15, 20);
			"Bomb explosion radius"
			Global.GERadius = Random Integer(14, 22);
		Else If(Global.TempVar == 9);
			"Passenger"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.TempVar3 = Custom String("You are slow! Stay near a teammate to go FAST!");
			Global.GEMinPlayerReq = 3;
			Global.GEName = Custom String("Passenger!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 180);
			"Buff range"
			Global.GERadius = 4;
		Else If(Global.TempVar == 10);
			"Big Barrier Toggle"
			Global.TempVar3 = Custom String("Barriers are HUGE!");
			Global.GEWaitTime = Random Integer(30, 90);
			Global.GEName = Custom String("Big Barrier!");
		Else If(Global.TempVar == 11);
			Global.TempVar3 = Custom String("Bastion will spawn on top of a player. Watch out!");
			"Bastion Drop"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner && !Is In Spawn Room(
				Current Array Element)));
			Global.GEMinPlayerReq = 3;
			Global.GEName = Custom String("Bastion Drop!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 120);
		Else If(Global.TempVar == 12);
			Global.GEMinPlayerReq = 2;
			"Hacked"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.TempVar3 = Custom String("Some players are HACKED!");
			Global.GEName = Custom String("Hacked!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(20, 50);
		Else If(Global.TempVar == 13);
			Global.TempVar3 = Custom String("Emote or you will surely die!");
			Global.GEName = Custom String("Emote or Die!");
			Global.GERequiredNum = Random Integer(1, 3);
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Global.GERequiredNum * 6 + 10;
		Else If(Global.TempVar == 14);
			Global.GEMinPlayerReq = 2;
			"Personal Space"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Is In Spawn Room(Current Array Element)
				&& !Current Array Element.IsWinner));
			Global.TempVar3 = Custom String("Some players need space! They will push you away \nif you come too close.");
			Global.GEName = Custom String("Personal Space!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 90);
			"Amount of personal space"
			Global.GERadius = Random Integer(12, 21);
		Else If(Global.TempVar == 15);
			Global.TempVar3 = Custom String("Use voice lines or die! Wait at least 5 seconds before each voice line.");
			Global.GEName = Custom String("Voice Line or Die!");
			Global.GERequiredNum = Random Integer(1, 3);
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Global.GERequiredNum * 6 + 10;
		Else If(Global.TempVar == 16);
			Global.TempVar3 = Custom String("All Bastions are deactivated!");
			Global.GEName = Custom String("Deactivated Bastions!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(5, 12);
		Else If(Global.TempVar == 17);
			Global.TempVar3 = Custom String("Beware! When a player dies everyone nearby will too.");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 180);
			Global.GEName = Custom String("Die with Me!");
			Global.GEMinPlayerReq = 2;
			Global.TempVar2 = Count Of(All Players(Team 1));
			Global.GERadius = 8;
		Else If(Global.TempVar == 18);
			Global.TempVar3 = Custom String("Your max health has been increased!");
			Global.GEName = Custom String("More Health!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(45, 180);
		Else If(Global.TempVar == 19);
			Global.GEMinPlayerReq = 2;
			Global.TempVar3 = Custom String("Some players are Medusa's servants. Don't look at them!");
			Global.GEName = Custom String("Medusa!");
			"Medusa"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Is In Spawn Room(Current Array Element)
				&& !Current Array Element.IsWinner));
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 180);
			"Players' vision"
			Global.GEViewAngle = 45;
		Else If(Global.TempVar == 20);
			Global.TempVar2 = Count Of(All Players(Team 1));
			Global.TempVar3 = Custom String("Players are invisible and can phase through \nobjects!");
			Global.GEName = Custom String("Friendly Ghosts!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 150);
			Global.GEMinPlayerReq = 2;
		Else If(Global.TempVar == 21);
			"Sleepy Tbags"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.GEMinPlayerReq = 3;
			Global.TempVar3 = Custom String("TBag sleeping players to wake them and gain movement speed.");
			Global.GEName = Custom String("Sleepy TBags!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 120);
			"Tbag radius"
			Global.GERadius = 1.800;
			"TBag amount"
			Global.GERequiredNum = 5;
		Else If(Global.TempVar == 22);
			"Piggyback"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.GEMinPlayerReq = 2;
			Global.TempVar3 = Custom String("Some players can now carry other players.\nCarry limit is 1.");
			Global.GEName = Custom String("Piggyback!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 150);
			Global.GEViewAngle = 45;
			Global.GEMeleeDistance = 3;
		Else If(Global.TempVar == 23);
			"Guardian Angel"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.TempVar3 = Custom String(
				"Some players have guardian angels.\nInstead of dying, the guardian angel will take the blow instead.");
			Global.GEMinPlayerReq = 2;
			Global.GEName = Custom String("Guardian Angel!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 120);
		Else If(Global.TempVar == 24);
			"Soul Link"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.GEMinPlayerReq = 2;
			Global.TempVar3 = Custom String("Some players are soulmates. Health and Damage received \nare shared with your soulmate equally.");
			Global.GEName = Custom String("Soul Link!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 180);
		Else If(Global.TempVar == 25);
			Global.TempVar3 = Custom String("Players move in one direction. Forwards, backwards, sideways.");
			Global.GEName = Custom String("One Direction!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 60);
		Else If(Global.TempVar == 26);
			Global.GEMinPlayerReq = 3;
			"World Tag"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.TempVar3 = Custom String("A player is chosen as a Tagger. The Tagger must tag players\nwho have NOT been tagged before.");
			Global.GEName = Custom String("World Tag!");
			Global.GERequiredNum = Random Integer(1, Global.TempVar2 - 1);
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Global.GERequiredNum * 20 + 8;
			Global.GEMeleeDistance = 3;
			Global.GEViewAngle = 45;
		Else If(Global.TempVar == 27);
			Global.TempVar3 = Custom String("Some players are bugs! Don't squish them!");
			Global.GEName = Custom String("Bugs!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 90);
			Global.GERadius = 2;
		Else If(Global.TempVar == 28);
			Global.TempVar3 = Custom String("Players jump high & fall slowly.");
			Global.GEName = Custom String("Leap Frog!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 90);
		Else If(Global.TempVar == 29);
			"President"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.TempVar3 = Custom String("Protect the President! If the President dies, everyone will too.");
			Global.GEName = Custom String("President!");
			Global.GEMinPlayerReq = 2;
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(50, 110);
			Global.GERadius = 12;
		Else If(Global.TempVar == 30);
			Global.TempVar3 = Custom String("The Target must hit the ball to deflect it! \n(Ball resets at spawn.)");
			"Hot Potato"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.GEMinPlayerReq = 2;
			Global.GEName = Custom String("Extreme Pong!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(50, 150);
			"Potato Speed"
			Call Subroutine(GESetPongBallSpeed);
			"Potato size"
			Global.GERadius = 3;
			"Initial potato position"
			Global.GEBallPosition = Vector(0, -110, 0);
			Global.GEMeleeDistance = 3;
		Else If(Global.TempVar == 31);
			Global.TempVar3 = Custom String("All players will randomly be placed in random locations.");
			Global.GEName = Custom String("I'm Lagging!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 90);
		Else If(Global.TempVar == 32);
			Global.TempVar2 = Count Of(All Players(Team 1));
			Global.TempVar3 = Custom String("All players will teleport to a chosen player.");
			Global.GEName = Custom String("Group Up!");
			Global.GEMinPlayerReq = 3;
		Else If(Global.TempVar == 33);
			Global.TempVar3 = Custom String("Self-healing is toggled on/off.");
			Global.GEName = Custom String("I Need Healing!");
		Else If(Global.TempVar == 34);
			Call Subroutine(BeforeNewBastionBulletUpgrade);
			Global.TempVar3 = Custom String("Bastions' bullets has been upgraded!");
			Global.GEName = Custom String("Bastion Bullet Upgrade!");
			Global.BUChoices[0] = Random Value In Array(Filtered Array(Array(0, 1, 2, 3, 4, 5, 6),
				Current Array Element != Global.BUChoices[0]));
			"DEBUGGING only"
			disabled Global.BUChoices[0] = 0;
		Else If(Global.TempVar == 35);
			Global.TempVar3 = Custom String("Incremental value for backtrack deaths has changed.");
			Global.GEName = Custom String("Blood Sacrifice!");
		Else If(Global.TempVar == 36);
			Global.GEMinPlayerReq = 3;
			Global.TempVar3 = Custom String("The exit is locked! Find the key (blue orb)! It emits sound.");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = 100000000;
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.GEName = Custom String("Lockdown!");
			Global.GERadius = 1;
		Else If(Global.TempVar == 37);
			Global.TempVar3 = Custom String("Alternating game speed!");
			Global.GEName = Custom String("Warped Slo-mo!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 90);
		Else If(Global.TempVar == 38);
			Global.GEMinPlayerReq = 3;
			Global.TempVar3 = Custom String("Avoid spotlight or risk teleporting to a Bastion!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(160, 250);
			Global.GEBallPosition = Vector(0, 0, 0);
			Global.GEBallSpeed = 2.560;
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.GEName = Custom String("Spotlight!");
			Global.GERadius = 6.600;
		Else If(Global.TempVar == 39);
			Global.TempVar3 = Custom String("The winds are blowing strong!");
			Global.GEName = Custom String("Strong Winds!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 120);
		Else If(Global.TempVar == 40);
			Global.GECameraChoice = Random Integer(0, 2);
			"DEBUGGING ONLY: Selects a camera view"
			disabled Global.GECameraChoice = 2;
			Global.TempVar3 = Custom String("Camera is now in [{0}] mode!", Global.GECameraChoice == 0 ? Custom String("3rd-person") : (
				Global.GECameraChoice == 1 ? Custom String("top-down") : Custom String("selfie")));
			Global.GEName = Custom String("Wacky Camera!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 120);
		"Bad Jet Boots"
		Else If(Global.TempVar == 41);
			Global.TempVar3 = Custom String("Flight Activated! Don't touch the ground or risk exploding!");
			Global.GEName = Custom String("Bad Jet Boots!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 120);
		Else If(Global.TempVar == 42);
			Global.TempVar3 = Custom String("Bastions are revealed! Please thank Widowmaker!");
			Global.GEName = Custom String("Reveal!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 120);
		Else If(Global.TempVar == 43);
			Global.TempVar3 = Custom String("An extra upgrade has been added to Bastion!");
			Global.GEName = Custom String("Bastion Extra Upgrade!");
			Global.BUChoices[1] = Random Value In Array(Filtered Array(Array(0, 1, 2, 3, 4, 5), Current Array Element != Global.BUChoices[1]));
			"DEBUGGING only"
			disabled Global.BUChoices[1] = 5;
		Else If(Global.TempVar == 44);
			Global.GEMinPlayerReq = 3;
			Global.TempVar3 = Custom String(
				"Players randomly take turns controlling one body. \nIf the body dies or escapes, it affects everyone.");
			"Switcharoo"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.GEName = Custom String("One-For-All!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 280);
		Else If(Global.TempVar == 45);
			Global.TempVar3 = Custom String("Players move forward very fast! No emotes allowed!");
			Global.GEName = Custom String("Forward March!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 90);
		Else If(Global.TempVar == 46);
			Global.TempVar3 = Custom String("Some players are taller! Don't squish your smaller allies!");
			Global.GEName = Custom String("Growth Spurt!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 90);
			Global.GERadius = 3;
		Else If(Global.TempVar == 47);
			Global.TempVar3 = Custom String("Avoid the expanding sphere!");
			Global.GEName = Custom String("Kill Sphere!");
			Global.GEMaxNum = Random Integer(25, 60);
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Global.GEMaxNum + 15;
			Global.GERadius = 1;
		Else If(Global.TempVar == 48);
			Global.TempVar3 = Custom String("All players get booped!");
			Global.GEName = Custom String("Boop!");
		Else If(Global.TempVar == 49);
			Global.TempVar3 = Custom String("Toxic clouds are spread throughout the lands!");
			Global.GEName = Custom String("Toxic Clouds!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 120);
			Global.GERadius = Random Real(4, 10);
		End;
		Wait(0.300, Ignore Condition);
		"DEBUGGING ONLY: bypass minimum player req."
		disabled Global.GEMinPlayerReq = 1;
		Loop If((Global.GEMinPlayerReq != 1 && Global.TempVar2 < Global.GEMinPlayerReq) || ((Global.TempVar == 34 || Global.TempVar == 43)
			&& !Global.IsBastionUpgradableWS) || (Global.TempVar == 35 && Global.BacktrackDeathsWS == 0));
		Global.GEChoice = Global.TempVar;
		Global.GEHelpText = Global.TempVar3;
		Big Message(All Players(Team 1), Custom String("Global Effect ---> {0}", Global.GEName));
		Wait(2, Ignore Condition);
		Global.CanStartGE = 1;
		Global.GEMaxBacktrackSteps = 3;
	}
}

rule("Global Effect Timer (GE)[SR]")
{
	event
	{
		Subroutine;
		StartGETimer;
	}

	actions
	{
		"Start the timer for the duration of the Global Effect"
		Global.IsGETimerStart = True;
		Global.CanStartGE = 2;
		"Current match time in seconds"
		Global.GEEndTime = Round To Integer(Total Time Elapsed, To Nearest);
		Global.GEEndTime += Global.GEWaitTime;
		"How long to apply the global effect"
		Wait Until(!Global.IsGETimerStart, Global.GEWaitTime);
		Global.IsGETimerStart = False;
	}
}

rule("End current Global Effect (GE)[SR]")
{
	event
	{
		Subroutine;
		EndGlobalEffect;
	}

	actions
	{
		Global.CanStartGE = 0;
		Global.GEChoice = 0;
	}
}

rule("Set HUD recent help text for players(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Event Player.GEHelpTextIDs == Null;
	}

	actions
	{
		Create HUD Text(Event Player, Custom String("{0} Self-Healing: [{1}]", Ability Icon String(Hero(Soldier: 76), Button(Ability 2)),
			!Global.GEToggles[0] ? String("On") : String("Off")), Null, Null, Right, -3, Color(Green), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Event Player.GEHelpTextIDs = Array(Last Text ID);
		Create HUD Text(Event Player, Custom String("{0} Recent Effect:", Ability Icon String(Hero(Wrecking Ball), Button(Ability 1))),
			Null, Null, Right, -2, Color(Sky Blue), Color(White), Color(White), Visible To and String, Default Visibility);
		Modify Player Variable(Event Player, GEHelpTextIDs, Append To Array, Last Text ID);
		Create HUD Text(Event Player, Null, Custom String("                                   "), Custom String("{0}{1}\n", Icon String(
			Question Mark), Global.GEHelpText == Null ? Custom String("") : Global.GEHelpText), Right, -1, Color(White), Color(White),
			Color(White), Visible To and String, Default Visibility);
		Modify Player Variable(Event Player, GEHelpTextIDs, Append To Array, Last Text ID);
		If(Global.IsBastionUpgradableWS);
			Create HUD Text(Event Player, Custom String("{0} Bastion Upgrades: {1}{2}", Hero Icon String(Hero(Bastion)),
				Global.BUChoices[0] == 1 ? Icon String(Arrow: Right) : (Global.BUChoices[0] == 2 ? Icon String(Fire) : (
				Global.BUChoices[0] == 3 ? Icon String(Spiral) : (Global.BUChoices[0] == 4 ? Ability Icon String(Hero(Bastion), Button(
				Ultimate)) : (Global.BUChoices[0] == 5 ? Icon String(Dizzy) : (Global.BUChoices[0] == 6 ? Icon String(Bolt) : String("")))))),
				Global.BUChoices[1] == 1 ? Ability Icon String(Hero(Sombra), Button(Ability 1)) : (Global.BUChoices[1] == 2 ? Icon String(
				Arrow: Down) : (Global.BUChoices[1] == 3 ? Icon String(Arrow: Up) : (Global.BUChoices[1] == 4 ? Ability Icon String(Hero(
				Genji), Button(Ability 1)) : (Global.BUChoices[1] == 5 ? Icon String(Eye) : String("")))))), Null, Null, Right, -4, Color(
				Aqua), Color(White), Color(White), Visible To and String, Default Visibility);
			Modify Player Variable(Event Player, GEHelpTextIDs, Append To Array, Last Text ID);
	}
}

rule("Set Global Effect duration progress bar HUD (GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
	}

	actions
	{
		Play Effect(Event Player, Symmetra Teleporter Reappear Sound, Color(White), Position Of(Event Player), 100);
		Create Progress Bar HUD Text(Event Player, Min((Global.GEEndTime - Round To Integer(Total Time Elapsed, To Nearest))
			/ Global.GEWaitTime * 100, 100), Custom String("{0} {1}", Icon String(Diamond), Global.GEName), Top, 5, Color(Yellow), Color(
			White), Visible To and Values, Default Visibility);
		Event Player.GETimerID = Last Text ID;
	}
}

rule("Remove Global Effect progress bar HUD (GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGETimerStart == False;
		Event Player.GETimerID != Null;
	}

	actions
	{
		Destroy Progress Bar HUD Text(Event Player.GETimerID);
		Event Player.GETimerID = Null;
	}
}

rule("Remove Global Effect duration progress bar HUD when player leaves")
{
	event
	{
		Player Left Match;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GETimerID != Null;
	}

	actions
	{
		Destroy Progress Bar HUD Text(Event Player.GETimerID);
		Event Player.GETimerID = Null;
	}
}

rule("Player left during *ANY* Global Effect (GE)")
{
	event
	{
		Player Left Match;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGETimerStart == True;
	}

	actions
	{
		"Remove HUDs"
		If(Count Of(Event Player.GEHUDID) == 0 && Event Player.GEHUDID != Null);
			Destroy HUD Text(Event Player.GEHUDID);
		Else If(Count Of(Event Player.GEHUDID) > 0);
			For Player Variable(Event Player, loopNum, 0, Count Of(Event Player.GEHUDID), 1);
				Destroy HUD Text(Event Player.GEHUDID[Event Player.loopNum]);
			End;
		End;
		Event Player.GEHUDID = Null;
		"Remove Effects"
		If(Count Of(Event Player.GEID) == 0 && Event Player.GEID != Null);
			Destroy Effect(Event Player.GEID);
		Else If(Count Of(Event Player.GEID) > 0);
			For Player Variable(Event Player, loopNum, 0, Count Of(Event Player.GEID), 1);
				Destroy Effect(Event Player.GEID[Event Player.loopNum]);
			End;
		End;
		Event Player.GEID = Null;
	}
}

rule("Player left during a *SPECIFIC* Global Effect (GE)")
{
	event
	{
		Player Left Match;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGETimerStart == True;
	}

	actions
	{
		Stop Chasing Global Variable(GEBallPosition);
		"Extreme Pong"
		If(Global.GEChoice == 30);
			Global.GETarget = Random Value In Array(Filtered Array(All Players(Team 1),
				!Current Array Element.IsWinner && Current Array Element != Event Player));
			Wait(2.500, Ignore Condition);
			Chase Global Variable At Rate(GEBallPosition, Eye Position(Global.GETarget) - Vector(0, 0.500, 0), Global.GEBallSpeed,
				Destination and Rate);
		"Spotlight"
		Else If(Global.GEChoice == 38);
			Global.GETarget = Random Value In Array(Filtered Array(All Players(Team 1),
				Current Array Element != Event Player && !Current Array Element.IsWinner && !Is In Spawn Room(Current Array Element)));
			Chase Global Variable At Rate(GEBallPosition, Position Of(Global.GETarget), Global.GEBallSpeed, Destination and Rate);
		"One-For-All"
		Else If(Global.GEChoice == 44 && Event Player == Global.GEAffectedPlayer);
			Global.GEAffectedPlayer = Null;
	}
}

rule("Start Global Effect -- [Type A] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		(Global.GEChoice == 1 || Global.GEChoice == 49) == True;
		Global.CanStartGE == 1;
	}

	actions
	{
		Global.GEMultiChoice = Random Integer(0, 14);
		Global.TempVar = Randomized Array(Filtered Array(All Players(Team 1), !Is In Spawn Room(Current Array Element)
			&& !Current Array Element.IsWinner));
		If(Global.GEMultiChoice > 5 && Global.GEMultiChoice < 10);
			Global.TempVar = Array Slice(Global.TempVar, 0, Round To Integer(Count Of(Global.TempVar) / 2, Up));
		"Apply Global Effect against a SINGLE player"
		Else If(Global.GEMultiChoice >= 10);
			Global.TempVar = Array Slice(Global.TempVar, 0, 1);
		End;
		Call Subroutine(GEStartTypeA);
		Call Subroutine(StartGETimer);
	}
}

rule("Init Type A (CHOICE:Variety)(NOT:Winners,In spawn) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeA;
	}

	actions
	{
		"Roadhog Time"
		If(Global.GEChoice == 1);
			Call Subroutine(SelectAPatrol);
	}
}

rule("Start Global Effect -- [Type B] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.CanStartGE == 1;
		(
			Global.GEChoice == 3 || Global.GEChoice == 7 || Global.GEChoice == 9 || Global.GEChoice == 10 || Global.GEChoice == 13 || Global.GEChoice == 15 || Global.GEChoice == 16 || Global.GEChoice == 17 || Global.GEChoice == 18 || Global.GEChoice == 20 || Global.GEChoice == 25 || Global.GEChoice == 28 || Global.GEChoice == 30 || Global.GEChoice == 31 || Global.GEChoice == 39 || Global.GEChoice == 40 || Global.GEChoice == 41 || Global.GEChoice == 42 || Global.GEChoice == 45)
			== True;
	}

	actions
	{
		Global.TempVar = All Players(Team 1);
		Call Subroutine(GEStartTypeB);
		Call Subroutine(StartGETimer);
	}
}

rule("Init Type B (CHOICE:All) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeB;
	}

	actions
	{
		"Big Barrier"
		If(Global.GEChoice == 10);
			Start Scaling Barriers(Global.TempVar, 5, False);
		"Bastion Deactivated"
		Else If(Global.GEChoice == 16);
			Set Status(All Players(Team 2), Null, Frozen, 9999);
		"More Health"
		Else If(Global.GEChoice == 18);
			Set Max Health(Global.TempVar, 300);
		"Friendly Ghosts"
		Else If(Global.GEChoice == 20);
			Set Invisible(Global.TempVar, All);
			Disable Movement Collision With Environment(Global.TempVar, False);
			Disable Movement Collision With Players(Global.TempVar);
		"Leap Frog"
		Else If(Global.GEChoice == 28);
			Set Jump Vertical Speed(Global.TempVar, 200);
		"Extreme Pong"
		Else If(Global.GEChoice == 30);
			Create Effect(Global.TempVar, Orb, Color(White), Global.GEBallPosition, Global.GERadius, Visible To Position and Radius);
			Global.GEBallID = Array(Last Created Entity);
			Create Effect(All Players(Team 1), Energy Sound, Color(White), Global.GEBallPosition, 80, Visible To Position and Radius);
			Modify Global Variable(GEBallID, Append To Array, Last Created Entity);
		"Strong Winds"
		Else If(Global.GEChoice == 39);
			Call Subroutine(SelectWindDir);
			Call Subroutine(SetWindSpeedRate);
		Else If(Global.GEChoice == 42);
			Create Dummy Bot(Hero(Widowmaker), Team 1, 9, Random Value In Array(Spawn Points(Team 1)), Vector(0, 0, 0));
			Global.TempVar = Filtered Array(All Players(Team 1), Hero Of(Current Array Element) == Hero(Widowmaker) && Is Dummy Bot(
				Current Array Element))[0];
			Disable Movement Collision With Players(Global.TempVar);
			Set Ultimate Ability Enabled(Global.TempVar, True);
			Set Ultimate Charge(Global.TempVar, 100);
			Press Button(Global.TempVar, Button(Ultimate));
			Disallow Button(Global.TempVar, Button(Ultimate));
			Start Forcing Player Outlines(Global.TempVar, All Players(Team 1), True, Color(Yellow), Always);
	}
}

rule("Start Global Effect -- [Type C] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.CanStartGE == 1;
		(
			Global.GEChoice == 4 || Global.GEChoice == 32 || Global.GEChoice == 33 || Global.GEChoice == 34 || Global.GEChoice == 35 || Global.GEChoice == 43 || Global.GEChoice == 48)
			== True;
	}

	actions
	{
		Call Subroutine(GEStartTypeC);
		Global.CanStartGE = 2;
	}
}

rule("Init Type C (CHOICE:All)(NOT:Timer) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeC;
	}

	actions
	{
		"Switcharoo"
		If(Global.GEChoice == 4);
			Global.TempVar3 = Randomized Array(Mapped Array(All Players(Team 1), Position Of(Current Array Element)));
			Global.TempVar = Randomized Array(All Players(Team 1));
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				Teleport(Global.TempVar[Global.TempVar2], Global.TempVar3[Global.TempVar2]);
			End;
		"Group Up"
		Else If(Global.GEChoice == 32);
			Global.TempVar = Random Value In Array(All Players(Team 1));
			Teleport(Filtered Array(All Players(Team 1), Global.TempVar != Current Array Element), Position Of(Global.TempVar));
		"I Need Healing"
		Else If(Global.GEChoice == 33);
			"I Need Healing"
			If(Global.GEToggles[0]);
				Global.GEToggles[0] = False;
				Heal(All Players(Team 1), Null, 9999);
			Else;
				Global.GEToggles[0] = True;
				Stop All Heal Over Time(All Players(All Teams));
			End;
		"Bastion Bullet Upgrade"
		Else If(Global.GEChoice == 34);
			Call Subroutine(SelectBastionBulletUpgrade);
		"Blood Sacrifice"
		Else If(Global.GEChoice == 35);
			"ones = 4; twos = 4; threes = 2; "
			Global.BacktrackSteps = Random Value In Array(Filtered Array(Array(1, 2, 1, 3, 1, 2, 2, 3, 1, 2),
				Current Array Element != Global.BacktrackSteps));
		"Bastion Extra Upgrade"
		Else If(Global.GEChoice == 43);
			Call Subroutine(SelectBastionExtraUpgrade);
		"Boop"
		Else If(Global.GEChoice == 48);
			Call Subroutine(SetBoopDirection);
			Global.TempVar = All Players(Team 1);
			Apply Impulse(Global.TempVar, Global.GEBallPosition, Random Real(6000, 9000), To World, Cancel Contrary Motion);
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				Play Effect(All Players(Team 1), Buff Impact Sound, Color(White), Global.TempVar[Global.TempVar2], 80);
				Wait(0.400, Ignore Condition);
			End;
	}
}

rule("Start Global Effect -- [Type D] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.CanStartGE == 1;
		(Global.GEChoice == 8 || Global.GEChoice == 14 || Global.GEChoice == 19) == True;
	}

	actions
	{
		Global.GECarriers = Randomized Array(Filtered Array(All Living Players(Team 1), !Is In Spawn Room(Current Array Element)
			&& !Current Array Element.IsWinner));
		Global.GECarriers = Array Slice(Global.GECarriers, 0, Round To Integer(Count Of(Global.GECarriers) / 2, Up));
		Call Subroutine(GEStartTypeD);
		Call Subroutine(StartGETimer);
	}
}

rule("Init Type D (CHOICE:Some)(SPECIAL:Carriers)(NOT:Winners,In spawn) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeD;
	}

	actions
	{
		"I'm the Bomb"
		If(Global.GEChoice == 8 || Global.GEChoice == 14);
			For Global Variable(TempVar2, 0, Count Of(Global.GECarriers), 1);
				Global.GECarriers[Global.TempVar2].GEID = -1;
			End;
		"Medusa"
		Else If(Global.GEChoice == 19);
			Start Forcing Player Outlines(Global.GECarriers, All Players(Team 1), True, Color(Orange), Always);
	}
}

rule("Start Global Effect -- [Type E] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.CanStartGE == 1;
		Global.GEChoice == 11;
	}

	actions
	{
		Global.TempVar = Random Value In Array(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner && !Is In Spawn Room(
			Current Array Element)));
		Call Subroutine(GEStartTypeE);
		Call Subroutine(StartGETimer);
	}
}

rule("Init Type E (CHOICE:Single)(NOT:Winners,In spawn) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeE;
	}

	actions
	{
		"Bastion Drop"
		If(Global.GEChoice == 11);
			Modify Global Variable(AllBastionPositions, Append To Array, Position Of(Global.TempVar));
			Create Dummy Bot(Hero(Bastion), Team 2, -1, Position Of(Global.TempVar), Left - Left);
			Play Effect(All Players(Team 1), Ring Explosion Sound, Color(White), Position Of(Global.TempVar), 90);
			Play Effect(All Players(Team 1), Bad Pickup Effect, Color(Orange), Position Of(Global.TempVar), 3);
	}
}

rule("Start Global Effect -- [Type F] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.CanStartGE == 1;
		(Global.GEChoice == 12 || Global.GEChoice == 21 || Global.GEChoice == 23 || Global.GEChoice == 24) == True;
	}

	actions
	{
		Global.TempVar = Randomized Array(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
		Global.TempVar = Array Slice(Global.TempVar, 0, Round To Integer(Count Of(Global.TempVar) / 2, Up));
		Call Subroutine(GEStartTypeF);
		Call Subroutine(StartGETimer);
	}
}

rule("Init Type F (CHOICE:Some)(NOT:Winners) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeF;
	}

	actions
	{
		"Hacked"
		If(Global.GEChoice == 12);
			Set Status(Global.TempVar, Null, Hacked, 9999);
		"Sleepy tbags"
		Else If(Global.GEChoice == 21);
			Set Status(Global.TempVar, Null, Asleep, 9999);
			Start Forcing Player Outlines(Global.TempVar, All Players(Team 1), True, Color(Violet), Always);
		"Piggyback"
		Else If(Global.GEChoice == 22);
			"Enter logic below"
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				Global.TempVar[Global.TempVar2].GEIsHeroCarrier = True;
			End;
		"Guardian Angel"
		Else If(Global.GEChoice == 23);
			Global.TempVar3 = Filtered Array(All Players(Team 1), !Current Array Element.IsWinner);
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				Global.TempVar3 = Filtered Array(Global.TempVar3, Global.TempVar[Global.TempVar2] != Current Array Element);
				Global.TempVar[Global.TempVar2].GEGuardianAngel = First Of(Global.TempVar3);
				Global.TempVar[Global.TempVar2].GEGuardianAngel.GEHumanProtect = Global.TempVar[Global.TempVar2];
				Modify Global Variable(TempVar3, Remove From Array By Index, 0);
			End;
		"Soul Link"
		Else If(Global.GEChoice == 24);
			Global.TempVar3 = Filtered Array(All Players(Team 1), !Current Array Element.IsWinner);
			"Enter logic below"
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				Global.TempVar3 = Filtered Array(Global.TempVar3, Global.TempVar[Global.TempVar2] != Current Array Element);
				Global.TempVar[Global.TempVar2].GESoulMate = First Of(Global.TempVar3);
				Global.TempVar[Global.TempVar2].GESoulMate.GESoulMate = Global.TempVar[Global.TempVar2];
				Modify Global Variable(TempVar3, Remove From Array By Index, 0);
			End;
	}
}

rule("Start Global Effect -- [Type G] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.CanStartGE == 1;
		Global.GEChoice == 5;
	}

	actions
	{
		Global.GEMultiChoice = Random Integer(0, 14);
		Global.TempVar = Randomized Array(Filtered Array(All Players(Team 1), !Is In Spawn Room(Current Array Element)
			&& !Current Array Element.IsWinner));
		If(Global.GEMultiChoice > 5 && Global.GEMultiChoice < 10);
			Global.TempVar = Array Slice(Global.TempVar, 0, Round To Integer(Count Of(Global.TempVar) / 2, Up));
		"Apply Global Effect against a SINGLE player"
		Else If(Global.GEMultiChoice >= 10);
			Global.TempVar = Array Slice(Global.TempVar, 0, 1);
		End;
		Call Subroutine(GEStartTypeG);
		Global.CanStartGE = 2;
	}
}

rule("Init Type G (CHOICE:Variety)(NOT:Winners,In spawn,Timer) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeG;
	}

	actions
	{
		"Oof Teleport"
		If(Global.GEChoice == 5);
			Respawn(Global.TempVar);
			If(Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter));
				Teleport(Global.TempVar, Global.BlizzWorldSpawnLoc);
				Set Facing(Global.TempVar, Forward + Left, To World);
				Global.TempVar2 = Global.BlizzWorldSpawnLoc;
			Else If(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween));
				Teleport(Global.TempVar, Global.HollywoodSpawns[0]);
				Set Facing(Global.TempVar, Right, To World);
				Global.TempVar2 = Global.HollywoodSpawns[0];
			Else;
				Global.TempVar2 = First Of(Randomized Array(Spawn Points(Team 1)));
			End;
			Play Effect(Global.TempVar, Debuff Impact Sound, Color(White), Global.TempVar2, 200);
	}
}

rule("Start Global Effect -- [Type H] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.CanStartGE == 1;
		(Global.GEChoice == 22 || Global.GEChoice == 46) == True;
	}

	actions
	{
		Global.GEMultiChoice = Random Integer(0, 14);
		Global.TempVar = Randomized Array(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
		"Apply global effect against SOME players"
		If(Global.GEMultiChoice < 7);
			Global.TempVar = Array Slice(Global.TempVar, 0, Round To Integer(Count Of(Global.TempVar) / 2, Up));
		Else;
			Global.TempVar = Array Slice(Global.TempVar, 0, 1);
		End;
		Call Subroutine(GEStartTypeH);
		Call Subroutine(StartGETimer);
	}
}

rule("Init Type H (CHOICE:Some or Single)(NOT:Winners) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeH;
	}

	actions
	{
		"Piggyback"
		If(Global.GEChoice == 22);
			"Enter logic below"
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				Global.TempVar[Global.TempVar2].GEIsHeroCarrier = True;
			End;
		"Growth Spurt"
		Else If(Global.GEChoice == 46);
			Start Scaling Player(Global.TempVar, 3, False);
			Set Move Speed(Global.TempVar, 80);
			Set Max Health(Global.TempVar, 250);
			"Enter logic below"
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				"Is a bug"
				Global.TempVar[Global.TempVar2].GEIsAffectedPlayer = True;
			End;
			Disable Movement Collision With Environment(Global.TempVar, False);
			Disable Nameplates(All Players(Team 1), All Players(Team 1));
	}
}

rule("Start Global Effect -- [Type I] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.CanStartGE == 1;
		(
			Global.GEChoice == 26 || Global.GEChoice == 29 || Global.GEChoice == 36 || Global.GEChoice == 37 || Global.GEChoice == 38 || Global.GEChoice == 44 || Global.GEChoice == 47)
			== True;
	}

	actions
	{
		Global.TempVar = Random Value In Array(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
		Call Subroutine(GEStartTypeI);
		Call Subroutine(StartGETimer);
	}
}

rule("Init Type I (CHOICE:Single)(NOT:Winners) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeI;
	}

	actions
	{
		"World Tag"
		If(Global.GEChoice == 26);
			Global.TempVar.GEIsTagger = True;
			Global.TempVar.GEIsTagged = True;
		Else If(Global.GEChoice == 29);
			Global.GEAffectedPlayer = Global.TempVar;
		"Lockdown"
		Else If(Global.GEChoice == 36);
			Call Subroutine(SetKeyLocation);
			Create Effect(All Players(Team 1), Orb, Color(Blue), Global.GEBallPosition, Global.GERadius, Visible To Position and Radius);
			Global.GEBallID = Array(Last Created Entity);
			Create Effect(All Players(Team 1), Sparkles Sound, Color(White), Global.GEBallPosition, 70, Visible To Position and Radius);
			Modify Global Variable(GEBallID, Append To Array, Last Created Entity);
		"Spotlight"
		Else If(Global.GEChoice == 38);
			Create Effect(All Players(Team 1), Light Shaft, Custom Color(255, 36, 36, 255), Position Of(Global.GEBallPosition),
				Global.GERadius, Visible To Position and Radius);
			Global.GEBallID = Array(Last Created Entity);
			Create Effect(All Players(Team 1), Decal Sound, Color(White), Global.GEBallPosition, 90, Visible To Position and Radius);
			Modify Global Variable(GEBallID, Append To Array, Last Created Entity);
		"One-For-All"
		Else If(Global.GEChoice == 44);
			Respawn(All Players(Team 1));
			Call Subroutine(SpawnAllAtAltLoc);
		"Kill Sphere"
		Else If(Global.GEChoice == 47);
			Call Subroutine(SetKillSphereLoc);
			Create Effect(All Players(Team 1), Sphere, Color(Red), Global.GEBallPosition, Global.GERadius, Visible To Position and Radius);
			Global.GEBallID[0] = Last Created Entity;
			Create Effect(All Players(Team 1), Energy Sound, Color(White), Global.GEBallPosition, 100, Visible To);
			Global.GEBallID[1] = Last Created Entity;
			Chase Global Variable Over Time(GERadius, Global.GEMaxNum, Global.GEWaitTime, None);
	}
}

rule("Start Global Effect -- [Type J] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.CanStartGE == 1;
		(Global.GEChoice == 27 || Global.GEChoice == 2 || Global.GEChoice == 6) == True;
	}

	actions
	{
		Global.GEMultiChoice = Random Integer(0, 14);
		Global.TempVar = Randomized Array(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
		If(Global.GEMultiChoice > 5 && Global.GEMultiChoice < 10);
			Global.TempVar = Array Slice(Global.TempVar, 0, Round To Integer(Count Of(Global.TempVar) / 2, Up));
		"Apply Global Effect against a SINGLE player"
		Else If(Global.GEMultiChoice >= 10);
			Global.TempVar = Array Slice(Global.TempVar, 0, 1);
		End;
		Call Subroutine(GEStartTypeJ);
		Call Subroutine(StartGETimer);
	}
}

rule("Init Type J (CHOICE:Variety)(NOT:Winners) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeJ;
	}

	actions
	{
		"Frozen"
		If(Global.GEChoice == 2);
			"Enter logic below"
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				"Is a bug"
				Global.TempVar[Global.TempVar2].GEIsAffectedPlayer = True;
			End;
			Set Status(Global.TempVar, Null, Frozen, 9999);
		"Invincible"
		Else If(Global.GEChoice == 6);
			Global.TempVar3 = Filtered Array(All Players(Team 1), !Array Contains(Global.TempVar, Current Array Element));
			For Global Variable(TempVar4, 0, Count Of(Global.TempVar3), 1);
				Global.TempVar3[Global.TempVar4].GEHUDID = -2;
			End;
			Set Status(Global.TempVar, Null, Invincible, 99999);
		"Bugs"
		Else If(Global.GEChoice == 27);
			Start Scaling Player(Global.TempVar, 0.099, False);
			Set Max Health(Global.TempVar, 5);
			"Enter logic below"
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				"Is a bug"
				Global.TempVar[Global.TempVar2].GEIsAffectedPlayer = True;
			End;
			Disable Nameplates(Global.TempVar, All Players(Team 1));
	}
}

rule("Clean up specific Global Effect at the end (GE)[SR]")
{
	event
	{
		Subroutine;
		GESpecificEndCleanUp;
	}

	actions
	{
		Stop Forcing Player Outlines(All Players(Team 1), All Players(Team 1));
		"Patrol Guards"
		If(Global.GEChoice == 1);
			Call Subroutine(CleanUpPatrol);
		"Frozen"
		Else If(Global.GEChoice == 2);
			Clear Status(All Players(Team 1), Frozen);
		"Lava Floor"
		Else If(Global.GEChoice == 3);
			Clear Status(All Players(Team 1), Burning);
			Heal(All Living Players(Team 1), Null, 600);
			Stop All Damage Over Time(All Players(Team 1));
		"Invincible"
		Else If(Global.GEChoice == 6);
			Clear Status(All Players(Team 1), Invincible);
		"X or Die"
		Else If(Global.GEChoice == 7 || Global.GEChoice == 13 || Global.GEChoice == 15);
			Kill(Filtered Array(All Players(Team 1), Current Array Element.GECount < Global.GERequiredNum && !Current Array Element.IsWinner),
				Random Value In Array(All Players(Team 2)));
		"I'm the Bomb"
		Else If(Global.GEChoice == 8);
			For Global Variable(TempVar2, 0, Count Of(Global.GECarriers), 1);
				Global.TempVar = Filtered Array(Players Within Radius(Global.GECarriers[Global.TempVar2], Global.GERadius, Team 1, Off),
					Current Array Element != Global.GECarriers[Global.TempVar2]);
				Kill(Global.TempVar, Random Value In Array(All Players(Team 2)));
				Play Effect(Filtered Array(All Players(Team 1), Global.TempVar[Global.TempVar2] != Current Array Element),
					DVa Self Destruct Explosion Sound, Color(Orange), Global.GECarriers[Global.TempVar2], 80);
				Play Effect(All Players(Team 1), Good Explosion, Color(Orange), Global.GECarriers[Global.TempVar2], Global.GERadius);
			End;
		"Passenger"
		Else If(Global.GEChoice == 9);
			Set Move Speed(All Players(Team 1), 100);
		"Big Barrier"
		Else If(Global.GEChoice == 10);
			Stop Scaling Barriers(All Players(Team 1));
		"Bastion Drop"
		Else If(Global.GEChoice == 11);
			Destroy Dummy Bot(Team 2, Count Of(Global.AllBastionPositions) - 1);
			Modify Global Variable(AllBastionPositions, Remove From Array By Index, Count Of(Global.AllBastionPositions) - 1);
		"Hacked"
		Else If(Global.GEChoice == 12);
			Clear Status(All Players(Team 1), Hacked);
		"Bastion Deactivated"
		Else If(Global.GEChoice == 16);
			Clear Status(All Players(Team 2), Frozen);
		"More Health"
		Else If(Global.GEChoice == 18);
			Set Max Health(All Players(Team 1), 100);
		"Medusa"
		Else If(Global.GEChoice == 19);
			Clear Status(All Players(Team 1), Frozen);
		"Friendly Ghosts"
		Else If(Global.GEChoice == 20);
			Set Invisible(All Players(Team 1), None);
			Enable Movement Collision With Environment(All Players(Team 1));
			Enable Movement Collision With Players(All Players(Team 1));
		"Sleepy TBags"
		Else If(Global.GEChoice == 21);
			Clear Status(All Players(Team 1), Asleep);
			Set Move Speed(All Players(Team 1), 100);
			Global.TempVar = All Players(Team 1);
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				Global.TempVar[Global.TempVar2].IsGETBagCrouched = False;
				Global.TempVar[Global.TempVar2].IsGETBagStand = False;
			End;
		"Piggyback"
		Else If(Global.GEChoice == 22);
			Global.TempVar = All Players(Team 1);
			Stop Scaling Player(Global.TempVar);
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				Global.TempVar[Global.TempVar2].GEHeroCarrier = Null;
				Global.TempVar[Global.TempVar2].GEIsHeroCarrier = False;
				Detach Players(Global.TempVar[Global.TempVar2].GEHeroRider);
				If(Count Of(Global.TempVar[Global.TempVar2].GEHUDID) == 2);
					Destroy HUD Text(Global.TempVar[Global.TempVar2].GEHUDID[0]);
					Destroy HUD Text(Global.TempVar[Global.TempVar2].GEHUDID[1]);
					Global.TempVar[Global.TempVar2].GEHUDID = Null;
				End;
				Global.TempVar[Global.TempVar2].GEHeroRider = Null;
			End;
			Clear Status(Global.TempVar, Unkillable);
		"Guardian Angel"
		Else If(Global.GEChoice == 23);
			Global.TempVar = All Players(Team 1);
			Clear Status(Global.TempVar, Unkillable);
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				If(Global.TempVar[Global.TempVar2].GEHUDID != Null);
					Destroy HUD Text(Global.TempVar[Global.TempVar2].GEHUDID[0]);
					Destroy HUD Text(Global.TempVar[Global.TempVar2].GEHUDID[1]);
					Global.TempVar[Global.TempVar2].GEHUDID = Null;
				End;
				Global.TempVar[Global.TempVar2].GEGuardianAngel = Null;
				Global.TempVar[Global.TempVar2].GEHumanProtect = Null;
			End;
		"Soul Link"
		Else If(Global.GEChoice == 24);
			Global.TempVar = All Players(Team 1);
			Heal(Filtered Array(Global.TempVar, Current Array Element.GESoulMate != Null), Null, 9999);
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				Global.TempVar[Global.TempVar2].GESoulMate = Null;
				Global.TempVar[Global.TempVar2].GEIsRecentlyHurt = False;
				Set Max Health(Global.TempVar[Global.TempVar2], 100);
			End;
		"One Direction"
		Else If(Global.GEChoice == 25);
			Stop Forcing Throttle(All Players(Team 1));
		"World Tag"
		Else If(Global.GEChoice == 26);
			If(Global.GECurReqNum < Global.GERequiredNum);
				Kill(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner), Random Value In Array(All Players(Team 2)));
			End;
			Global.TempVar = All Players(Team 1);
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				If(Global.TempVar[Global.TempVar2].GEHUDID != Null);
					Destroy HUD Text(Global.TempVar[Global.TempVar2].GEHUDID[0]);
					Destroy HUD Text(Global.TempVar[Global.TempVar2].GEHUDID[1]);
					Destroy HUD Text(Global.TempVar[Global.TempVar2].GEHUDID[2]);
					Global.TempVar[Global.TempVar2].GEHUDID = Null;
				End;
				Global.TempVar[Global.TempVar2].GEIsTagger = False;
				Global.TempVar[Global.TempVar2].GEIsTagged = False;
			End;
		"Bugs & Growth Spurt"
		Else If(Global.GEChoice == 27 || Global.GEChoice == 46);
			Enable Nameplates(All Players(Team 1), All Players(Team 1));
			Set Max Health(All Players(Team 1), 100);
			Stop Scaling Player(All Players(Team 1));
			Set Move Speed(All Players(Team 1), 100);
			Enable Movement Collision With Environment(All Players(Team 1));
		"Leap Frog"
		Else If(Global.GEChoice == 28);
			Set Jump Vertical Speed(All Players(Team 1), 100);
		"President"
		Else If(Global.GEChoice == 29);
			Set Max Health(All Players(Team 1), 100);
		"Lockdown"
		Else If(Global.GEChoice == 36);
			Destroy Effect(Global.GEBallID);
			Stop Forcing Player Outlines(Global.GEAffectedPlayer, All Players(Team 1));
			Global.GEBallID = Null;
		"Warped Slo-mo"
		Else If(Global.GEChoice == 37);
			Set Slow Motion(90);
			Set Move Speed(All Players(Team 1), 100);
		"Spotlight & Extreme Pong"
		Else If(Global.GEChoice == 38 || Global.GEChoice == 30);
			Destroy Effect(Global.GEBallID);
			Global.GEBallID = Null;
		"Strong Winds"
		Else If(Global.GEChoice == 39);
			Stop Chasing Global Variable(GEBallSpeed);
		"Wacky Camera"
		Else If(Global.GEChoice == 40);
			Stop Camera(All Players(Team 1));
		"Reveal"
		Else If(Global.GEChoice == 42);
			Destroy Dummy Bot(Team 1, Slot Of(Filtered Array(All Players(Team 1), Hero Of(Current Array Element) == Hero(Widowmaker)
				&& Is Dummy Bot(Current Array Element))[0]));
		"One-For-All"
		Else If(Global.GEChoice == 44);
			Stop Camera(All Players(Team 1));
			Global.GEAffectedPlayer = All Players(Team 1);
			Call Subroutine(EnablePlayer);
		"Forward March"
		Else If(Global.GEChoice == 45);
			Set Move Speed(All Players(Team 1), 100);
			Stop Throttle In Direction(All Players(Team 1));
		"Kill Sphere"
		Else If(Global.GEChoice == 47);
			Destroy Effect(Global.GEBallID);
			Global.GEBallID = Null;
			Stop Chasing Global Variable(GERadius);
		"Toxic Clouds"
		Else If(Global.GEChoice == 49);
			Global.TempVar = All Players(Team 2);
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				Destroy Effect(Global.TempVar[Global.TempVar2].GEID);
				Global.TempVar[Global.TempVar2].GEID = Null;
			End;
	}
}

rule("End of Global Effect *EVENT PLAYER*(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.GEChoice == 0;
	}

	actions
	{
		"Clean up applied effects"
		If(Event Player.GEID != Null);
			If(Count Of(Event Player.GEID) == 0);
				Destroy Effect(Event Player.GEID);
			Else;
				For Player Variable(Event Player, GETempVar, 0, Count Of(Event Player.GEID), 1);
					Destroy Effect(Event Player.GEID[Event Player.GETempVar]);
				End;
			End;
		End;
		Event Player.GEID = Null;
		"Clean up global effect huds"
		If(Event Player.GEHUDID != Null);
			If(Count Of(Event Player.GEHUDID) == 0);
				Destroy HUD Text(Event Player.GEHUDID);
			Else;
				For Player Variable(Event Player, GETempVar, 0, Count Of(Event Player.GEHUDID), 1);
					Destroy HUD Text(Event Player.GEHUDID[Event Player.GETempVar]);
				End;
			End;
		End;
		Event Player.GEHUDID = Null;
		Event Player.GEIsAffectedPlayer = False;
		Event Player.GECount = 0;
		Call Subroutine(ApplyWinnerStats);
	}
}

rule("End of Global Effect *GLOBAL* (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.GEChoice > 0;
		Global.IsGETimerStart == False;
		Global.CanStartGE == 2;
	}

	actions
	{
		Call Subroutine(GESpecificEndCleanUp);
		Global.GECarriers = Null;
		Global.GEMaxNum = 0;
		Global.GECurReqNum = 0;
		Global.GERequiredNum = 0;
		Global.GETarget = Null;
		If(Global.GEBallID != Null);
			Destroy Effect(Global.GEBallID);
			Global.GEBallID = Null;
		End;
		Global.GEBallSpeed = 0;
		If(Global.GEBallPosition != Null);
			Stop Chasing Global Variable(GEBallPosition);
			Global.GEBallPosition = Null;
		End;
		Global.GEAffectedPlayer = Null;
		Call Subroutine(EndGlobalEffect);
	}
}

rule("Set basic HUD & stats (GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEHUDID == Null;
		(
			Global.GEChoice == 7 || Global.GEChoice == 13 || Global.GEChoice == 15 || Global.GEChoice == 21 || Global.GEChoice == 26 || Global.GEChoice == 29 || Global.GEChoice == 30 || Global.GEChoice == 36 || Global.GEChoice == 38 || Global.GEChoice == 39)
			== True;
	}

	actions
	{
		"communicate or die"
		If(Global.GEChoice == 7);
			"Set status id for player(if needed)"
			Create HUD Text(Event Player, Custom String("Communication Count: {0}/{1}", Event Player.GECount, Global.GERequiredNum), Null,
				Null, Right, 1, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Last Text ID;
		"emote or die"
		Else If(Global.GEChoice == 13);
			"Set status id for player(if needed)"
			Create HUD Text(Event Player, Custom String("Emote Count: {0}/{1}", Event Player.GECount, Global.GERequiredNum), Null, Null, Right,
				1, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Last Text ID;
		"voice line or die"
		Else If(Global.GEChoice == 15);
			Create HUD Text(Event Player, Custom String("Voice Line Count: {0}/{1}", Event Player.GECount, Global.GERequiredNum), Null, Null,
				Right, 1, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Last Text ID;
		"Sleepy Tbags"
		Else If(Global.GEChoice == 21);
			Create HUD Text(Event Player, Custom String("TBags Count: {0}/{1}", Event Player.GECount, Global.GERequiredNum), Null, Null, Right,
				0, Color(Blue), Color(White), Color(White), Visible To and String, Default Visibility);
			Event Player.GEHUDID = Last Text ID;
		"World Tag"
		Else If(Global.GEChoice == 26);
			Create HUD Text(Event Player, Custom String("Status: {0}", Event Player.GEIsTagger ? Custom String("Tagger") : Custom String(
				"Player")), Null, Null, Right, 0, Color(Yellow), Color(White), Color(White), Visible To and String, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Array(Last Text ID);
			"Count the number of times something happens (if neccessary)"
			Create HUD Text(Event Player, Custom String("Was Tagged?: {0}", Event Player.GEIsTagged ? String("Yes") : String("No")), Null,
				Null, Right, 0, Color(Green), Color(White), Color(White), Visible To and String, Default Visibility);
			Modify Player Variable(Event Player, GEHUDID, Append To Array, Last Text ID);
			Create HUD Text(Event Player, Custom String("Required: {0}/{1}", Global.GECurReqNum, Global.GERequiredNum), Null, Null, Right, 0,
				Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
			Modify Player Variable(Event Player, GEHUDID, Append To Array, Last Text ID);
		"President"
		Else If(Global.GEChoice == 29 && Global.GEAffectedPlayer == Event Player);
			Create HUD Text(Event Player, Custom String("Status: President"), Null, Null, Right, 0, Color(Yellow), Color(White), Color(White),
				Visible To, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Last Text ID;
			Start Forcing Player Outlines(Event Player, All Players(Team 1), True, Color(Yellow), Always);
			Set Max Health(Event Player, 50);
		Else If(Global.GEChoice == 29 && Global.GEAffectedPlayer != Event Player);
			Create HUD Text(Event Player, Custom String("Status: Bodyguard"), Null, Null, Right, 0, Color(Yellow), Color(White), Color(White),
				Visible To, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Last Text ID;
		"Lockdown"
		Else If(Global.GEChoice == 36);
			Create HUD Text(Event Player, Custom String("Has Key?: {0}", Event Player == Global.GEAffectedPlayer ? String("Yes") : String(
				"No")), Null, Null, Right, 0, Color(Yellow), Color(White), Color(White), Visible To and String, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Last Text ID;
		"Extreme Pong or Spotlight"
		Else If(Global.GEChoice == 30 || Global.GEChoice == 38);
			Create HUD Text(Event Player, Custom String("Target: {0} {1}", Hero Icon String(Hero Of(Global.GETarget)), Global.GETarget), Null,
				Null, Right, 0, Color(Orange), Color(White), Color(White), Visible To and String, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Last Text ID;
		"Strong Winds"
		Else If(Global.GEChoice == 39);
			"Set status id for player(if needed)"
			Create HUD Text(Event Player, Custom String("Wind Direction: {0}", Global.GEText), Null, Null, Right, 1, Color(White), Color(
				White), Color(White), Visible To and String, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Last Text ID;
	}
}

rule("Player dies (GE)")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		(Global.GEChoice == 22 || Global.GEChoice == 29 || Global.GEChoice == 36 || Global.GEChoice == 44) == True;
	}

	actions
	{
		If(Global.GEChoice == 22);
			"Piggyback"
			If(Event Player.GEHeroRider != Null);
				Call Subroutine(GEResetHeroCarrierStats);
			Else If(Event Player.GEHeroCarrier != Null);
				Call Subroutine(GEResetHeroRiderStats);
			End;
		"President"
		Else If(Global.GEChoice == 29 && Event Player == Global.GEAffectedPlayer);
			Kill(Filtered Array(All Players(Team 1), Current Array Element != Event Player && !Current Array Element.IsWinner),
				Closest Player To(Position Of(Event Player), Team 2));
		Else If(Global.GEChoice == 36 && Event Player == Global.GEAffectedPlayer);
			Stop Forcing Player Outlines(Global.GEAffectedPlayer, All Players(Team 1));
			Global.GEBallPosition = Position Of(Global.GEAffectedPlayer);
			Global.GEAffectedPlayer = Null;
		Else If(Global.GEChoice == 44 && Event Player == Global.GEAffectedPlayer);
			Kill(Filtered Array(All Players(Team 1), Current Array Element != Global.GEAffectedPlayer), Closest Player To(Event Player,
				Team 2));
	}
}

rule("Player joins match (GE)")
{
	event
	{
		Player Joined Match;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGETimerStart == True;
		"Change the ID # from -1 to a positive number"
		(Global.GEChoice == 20 || Global.GEChoice == 40) == True;
	}

	actions
	{
		"Friendly Ghosts"
		If(Global.GEChoice == 20);
			Set Invisible(Event Player, All);
			Disable Movement Collision With Environment(Event Player, False);
			Disable Movement Collision With Players(Event Player);
		"Wacky Camera"
		Else If(Global.GEChoice == 40);
			Call Subroutine(SetCameraView);
	}
}

rule("Instructions for players (GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		(Global.GEChoice == 30 || Global.GEChoice == 22 || Global.GEChoice == 26 || Global.GEChoice == 41) == True;
	}

	actions
	{
		If(Event Player.GEIsHeroCarrier && Event Player.GEHeroRider == Null && Global.GEChoice == 22);
			"Save IDs of something for the player(if needed)"
			Small Message(Event Player, Custom String("Press {0} to carry a player!", Input Binding String(Button(Melee))));
		Else If(Global.GEChoice == 30);
			Small Message(Event Player, Custom String("Press {0} to deflect potato!", Input Binding String(Button(Melee))));
		Else If(Global.GEChoice == 26 && Event Player.GEIsTagger);
			Small Message(Event Player, Custom String("Press {0} to tag a player!", Input Binding String(Button(Melee))));
		Else If(Global.GEChoice == 41);
			Small Message(Event Player, Custom String("Hold {0} to use jet boots!", Input Binding String(Button(Jump))));
		End;
		Wait(10, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("All players reached required number early (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 26;
		Global.IsGETimerStart == True;
		Global.GECurReqNum >= Global.GERequiredNum;
	}

	actions
	{
		Global.IsGETimerStart = False;
		Big Message(All Players(Team 1), Custom String("Success!"));
	}
}

rule("Select a patrol guard (Patrol Guards)[SR]")
{
	event
	{
		Subroutine;
		SelectAPatrol;
	}

	actions
	{
		Global.GETempVar5 = Global.GEPatrolChoice == 0 ? Hero(Roadhog) : (Global.GEPatrolChoice == 1 ? Hero(Winston) : Hero(Reinhardt));
		For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
			Call Subroutine(SpawnPatrolLoc);
			Create Dummy Bot(Global.GETempVar5, Team 2, -1, Nearest Walkable Position(Global.TempVar3), Global.TempVar4);
		End;
	}
}

rule("Set the timer for (Patrol Guards)[SR]")
{
	event
	{
		Subroutine;
		SetPatrolDuration;
	}

	actions
	{
		"Roadhog"
		If(Global.GEPatrolChoice == 0);
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(7, 11);
		Else;
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 120);
	}
}

rule("Clean up (Patrol Guards)[SR]")
{
	event
	{
		Subroutine;
		CleanUpPatrol;
	}

	actions
	{
		Global.TempVar = Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Roadhog) || Hero Of(
			Current Array Element) == Hero(Winston) || Hero Of(Current Array Element) == Hero(Reinhardt));
		Stop Facing(Global.TempVar);
		Stop Forcing Throttle(Global.TempVar);
		For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
			Destroy Dummy Bot(Team 2, Slot Of(Global.TempVar[Global.TempVar2]));
		End;
	}
}

rule("Location to spawn near a player (Patrols Guards)(GE)[SR]")
{
	event
	{
		Subroutine;
		SpawnPatrolLoc;
	}

	actions
	{
		Global.TempVar3 = Random Integer(0, 7);
		Global.GESpawnDistance = 2.500;
		If(Global.TempVar3 == 0);
			Global.TempVar3 = Eye Position(Global.TempVar[Global.TempVar2]) + Forward * Global.GESpawnDistance;
			Global.TempVar4 = Forward * -1;
		Else If(Global.TempVar3 == 1);
			Global.TempVar3 = Eye Position(Global.TempVar[Global.TempVar2]) + (Forward + Right) * Global.GESpawnDistance * -1;
			Global.TempVar4 = (Forward + Right) * -1;
		Else If(Global.TempVar3 == 2);
			Global.TempVar3 = Eye Position(Global.TempVar[Global.TempVar2]) + Right * Global.GESpawnDistance;
			Global.TempVar4 = Right * -1;
		Else If(Global.TempVar3 == 3);
			Global.TempVar3 = Eye Position(Global.TempVar[Global.TempVar2]) + (Backward + Right) * Global.GESpawnDistance * -1;
			Global.TempVar4 = (Backward + Right) * -1;
		Else If(Global.TempVar3 == 4);
			Global.TempVar3 = Eye Position(Global.TempVar[Global.TempVar2]) + Backward * Global.GESpawnDistance;
			Global.TempVar4 = Backward * -1;
		Else If(Global.TempVar3 == 5);
			Global.TempVar3 = Eye Position(Global.TempVar[Global.TempVar2]) + (Backward + Left) * Global.GESpawnDistance * -1;
			Global.TempVar4 = (Backward + Left) * -1;
		Else If(Global.TempVar3 == 6);
			Global.TempVar3 = Eye Position(Global.TempVar[Global.TempVar2]) + Left * Global.GESpawnDistance;
			Global.TempVar4 = Left * -1;
		Else;
			Global.TempVar3 = Eye Position(Global.TempVar[Global.TempVar2]) + (Forward + Left) * Global.GESpawnDistance * -1;
			Global.TempVar4 = (Forward + Left) * -1;
	}
}

rule("init Roadhogs stats (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Roadhog;
	}

	conditions
	{
		Global.GEChoice == 1;
		Global.GEPatrolChoice == 0;
		Has Spawned(Event Player) == True;
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		Set Ultimate Ability Enabled(Event Player, True);
		Set Knockback Dealt(Event Player, Random Real(400, 500));
		Set Damage Dealt(Event Player, 0);
		Start Facing(Event Player, Position Of(Closest Player To(Event Player, Team 1)) - Event Player, 300, To World,
			Direction and Turn Rate);
		Start Throttle In Direction(Event Player, Position Of(Closest Player To(Event Player, Team 1)) - Position Of(Event Player),
			Random Real(0.500, 0.800), To World, Replace existing throttle, Direction and Magnitude);
		Set Status(Event Player, Null, Invincible, 9999);
	}
}

rule("set Roadhog ultimate (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Roadhog;
	}

	conditions
	{
		Global.GEChoice == 1;
		Global.GEPatrolChoice == 0;
		Is Dummy Bot(Event Player) == True;
		Ultimate Charge Percent(Event Player) < 100;
	}

	actions
	{
		Set Ultimate Ability Enabled(Event Player, True);
		Set Ultimate Charge(Event Player, 100);
	}
}

rule("Use Roadhog ultimate (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Roadhog;
	}

	conditions
	{
		Global.GEChoice == 1;
		Global.GEPatrolChoice == 0;
		Is Dummy Bot(Event Player) == True;
		Ultimate Charge Percent(Event Player) == 100;
	}

	actions
	{
		Wait(0.100, Ignore Condition);
		Press Button(Event Player, Button(Ultimate));
		Loop If Condition Is True;
	}
}

rule("init Winstons stats (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Winston;
	}

	conditions
	{
		Global.GEChoice == 1;
		Global.GEPatrolChoice == 1;
		Has Spawned(Event Player) == True;
		Is Dummy Bot(Event Player) == True;
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		Set Ultimate Ability Enabled(Event Player, True);
		Set Damage Dealt(Event Player, 50);
		Start Facing(Event Player, Position Of(Closest Player To(Event Player, Team 1)) - Position Of(Event Player), 300, To World,
			Direction and Turn Rate);
		Start Throttle In Direction(Event Player, Position Of(Closest Player To(Event Player, Team 1)) - Event Player, Random Real(0.500,
			0.800), To World, Replace existing throttle, Direction and Magnitude);
		Allow Button(Event Player, Button(Primary Fire));
		Allow Button(Event Player, Button(Ability 1));
		Set Status(Event Player, Null, Invincible, 9999);
		Set Ultimate Charge(Event Player, 100);
		Allow Button(Event Player, Button(Ultimate));
		Wait(0.250, Ignore Condition);
		Press Button(Event Player, Button(Ultimate));
	}
}

rule("Winston Attack (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Winston;
	}

	conditions
	{
		Global.GEChoice == 1;
		Global.GEPatrolChoice == 1;
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Primary Fire));
	}
}

rule("Winston Jumps (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Winston;
	}

	conditions
	{
		Global.GEChoice == 1;
		Global.GEPatrolChoice == 1;
		Is Using Ultimate(Event Player) == True;
		Is Using Ability 1(Event Player) == False;
	}

	actions
	{
		Press Button(Event Player, Button(Ability 1));
		Wait(Ability Cooldown(Event Player, Button(Ability 1)), Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Teleport Winston to player (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Winston;
	}

	conditions
	{
		Global.GEChoice == 1;
		Global.GEPatrolChoice == 1;
		Is Using Ultimate(Event Player) == True;
		Is In Line of Sight(Position Of(Closest Player To(Event Player, Team 1)), Position Of(Event Player), Barriers Do Not Block LOS)
			== False;
	}

	actions
	{
		Wait(2, Abort When False);
		Event Player.GETempVar = Random Integer(0, 2);
		If(Event Player.GETempVar == 0);
			Teleport(Event Player, Nearest Walkable Position(Eye Position(Closest Player To(Event Player, Team 1)) + Forward * 2.500));
		Else If(Event Player.GETempVar == 1);
			Teleport(Event Player, Nearest Walkable Position(Eye Position(Farthest Player From(Event Player, Team 1)) + Forward * 2.500));
		Else;
			Teleport(Event Player, Nearest Walkable Position(Eye Position(Random Value In Array(Filtered Array(All Players(Team 1),
				!Current Array Element.IsWinner))) + Forward * 2.500));
		End;
		Loop If Condition Is True;
	}
}

rule("init Reinhardt stats (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.GEChoice == 1;
		Global.GEPatrolChoice == 2;
		Has Spawned(Event Player) == True;
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		Allow Button(Event Player, Button(Ability 1));
		Start Facing(Event Player, Position Of(Closest Player To(Event Player, Team 1)) - Position Of(Event Player), 500, To World,
			Direction and Turn Rate);
		Start Throttle In Direction(Event Player, Position Of(Closest Player To(Event Player, Team 1)) - Event Player, Random Real(0.300,
			0.600), To World, Replace existing throttle, Direction and Magnitude);
		Set Status(Event Player, Null, Invincible, 9999);
	}
}

rule("Reinhardt charges (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		Global.GEChoice == 1;
		Global.GEPatrolChoice == 2;
	}

	actions
	{
		Play Effect(All Players(Team 1), Bad Pickup Effect, Color(Orange), Event Player, 5);
		Play Effect(All Players(Team 1), Debuff Impact Sound, Color(White), Event Player, 80);
		Teleport(Event Player, Nearest Walkable Position(Eye Position(Random Value In Array(All Players(Team 1))) + Forward * Random Real(
			3, 5)));
		Wait(Random Real(1.500, 2.100), Abort When False);
		Press Button(Event Player, Button(Ability 1));
		Wait Until(!Is Using Ability 1(Event Player), 99999);
		If(Random Integer(0, 20) == 6);
			Communicate(Event Player, Hello);
		End;
		Wait(Ability Cooldown(Event Player, Button(Ability 1)), Abort When False);
		Loop If Condition Is True;
	}
}

rule("Refreeze player if no longer frozen (Frozen)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 2;
		Global.IsGETimerStart == True;
		Event Player.GEIsAffectedPlayer == True;
		Has Status(Event Player, Frozen) == False;
	}

	actions
	{
		Set Status(Event Player, Null, Frozen, 9999);
	}
}

rule("Player on foot (Lava Floor)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 3;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Is In Spawn Room(Event Player) == False;
		Is In Air(Event Player) == False;
		Event Player.GEID == Null;
	}

	actions
	{
		Set Status(Event Player, Null, Burning, 9999);
		Start Damage Over Time(Event Player, Null, 9999, Random Real(40, 100));
		Event Player.GEID = Last Damage Over Time ID;
	}
}

rule("Player in air (Lava Floor)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 3;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEID != Null;
		(Is In Air(Event Player) || Is In Spawn Room(Event Player)) == True;
	}

	actions
	{
		Clear Status(Event Player, Burning);
		Stop Damage Over Time(Event Player.GEID);
		Event Player.GEID = Null;
	}
}

rule("Notify players who AREN'T (Invincible)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEChoice == 6;
		Global.IsGETimerStart == True;
		Event Player.GEHUDID == -2;
	}

	actions
	{
		Create HUD Text(Event Player, Custom String("Not Invincible!"), Null, Null, Right, 0, Color(Red), Color(White), Color(White),
			Visible To, Default Visibility);
		Event Player.GEHUDID = Last Text ID;
	}
}

rule("Notify players who ARE (Invincible) (GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEChoice == 6;
		Global.IsGETimerStart == True;
		Event Player.GEHUDID == Null;
	}

	actions
	{
		Create HUD Text(Event Player, Custom String("You are Invincible!"), Null, Null, Right, 0, Color(Yellow), Color(White), Color(
			White), Visible To, Default Visibility);
		Event Player.GEHUDID = Last Text ID;
		Create Effect(All Players(Team 1), Orisa Amplifier Sound, Color(White), Event Player, 80, Visible To Position and Radius);
		Event Player.GEID = Last Created Entity;
	}
}

rule("Player communicates (Communicate or Die)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 7;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GECount < Global.GERequiredNum;
		"Player will have to delay their \"Hello\" by 5 seconds for input to be read. !Overwatch issue!"
		(Is Communicating(Event Player, Hello) || Is Communicating(Event Player, Need Healing) || Is Communicating(Event Player, Group Up)
			|| Is Communicating(Event Player, Thanks) || Is Communicating(Event Player, Acknowledge) || Is Communicating(Event Player,
			Press the Attack) || Is Communicating(Event Player, You are Welcome) || Is Communicating(Event Player, Yes)
			|| Is Communicating(Event Player, No) || Is Communicating(Event Player, Goodbye) || Is Communicating(Event Player, Go)
			|| Is Communicating(Event Player, Ready) || Is Communicating(Event Player, Fall Back) || Is Communicating(Event Player,
			Push Forward) || Is Communicating(Event Player, Incoming) || Is Communicating(Event Player, With You) || Is Communicating(
			Event Player, Going In) || Is Communicating(Event Player, On My Way) || Is Communicating(Event Player, Attacking)
			|| Is Communicating(Event Player, Defending) || Is Communicating(Event Player, Need Help) || Is Communicating(Event Player,
			Sorry) || Is Communicating(Event Player, Countdown) || Is Communicating(Event Player, Ultimate Status)) == True;
	}

	actions
	{
		"Set status id for player(if needed)"
		Event Player.GECount += 1;
		Play Effect(Event Player, Buff Explosion Sound, Color(White), Event Player, 90);
		Play Effect(All Players(Team 1), Good Explosion, Color(White), Event Player, 1);
	}
}

rule("Set sphere radius effect (I'm the Bomb/Personal Space)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.GEID == -1;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Is In Spawn Room(Event Player) == False;
		"Change the ID # from -1 to a positive number"
		(Global.GEChoice == 8 || Global.GEChoice == 14) == True;
		Array Contains(Global.GECarriers, Event Player) == True;
	}

	actions
	{
		Start Forcing Player Outlines(Event Player, Filtered Array(All Players(Team 1), Current Array Element != Event Player), True,
			Color(Orange), Always);
		If(Global.GEChoice == 8);
			"Count the number of times something happens (if neccessary)"
			Create Effect(Filtered Array(All Players(Team 1), Current Array Element != Event Player), Sphere, Color(Red), Event Player,
				Global.GERadius, Visible To Position and Radius);
		Else If(Global.GEChoice == 14);
			Create Effect(Filtered Array(All Players(Team 1), Current Array Element != Event Player), Sphere, Color(White), Event Player,
				Global.GERadius, Visible To Position and Radius);
		End;
		"Save id of something for the player(if needed)"
		Event Player.GEID = Last Created Entity;
	}
}

rule("Player is with partner (Passenger)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 9;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Is True For Any(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Off),
			Current Array Element != Event Player) == True;
	}

	actions
	{
		Start Forcing Player Outlines(Event Player, All Players(Team 1), True, Color(Lime Green), Always);
		Set Move Speed(Event Player, 120);
		Wait(0.300, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Player is without partner (Passenger)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 9;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Is True For Any(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Off),
			Current Array Element != Event Player) == False;
	}

	actions
	{
		Start Forcing Player Outlines(Event Player, All Players(Team 1), True, Color(Purple), Always);
		Set Move Speed(Event Player, 50);
		Wait(0.300, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Player emotes (Emote or Die)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 13;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GECount < Global.GERequiredNum;
		Is Communicating Any Emote(Event Player) == True;
	}

	actions
	{
		"Set status id for player(if needed)"
		Event Player.GECount += 1;
		Play Effect(Event Player, Buff Explosion Sound, Color(White), Event Player, 90);
		Play Effect(All Players(Team 1), Good Explosion, Color(White), Event Player, 3);
	}
}

rule("Push players within radius (Personal Space)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 14;
		Global.IsGETimerStart == True;
		Is In Spawn Room(Event Player) == False;
		Event Player.IsWinner == False;
		Is True For Any(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Off),
			Current Array Element != Event Player) == True;
		Array Contains(Global.GECarriers, Event Player) == True;
	}

	actions
	{
		Global.TempVar = Filtered Array(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Off),
			Current Array Element != Event Player);
		"Count the number of times something happens (if neccessary)"
		For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
			Apply Impulse(Global.TempVar[Global.TempVar2], Position Of(Global.TempVar[Global.TempVar2]) - Position Of(Event Player),
				Random Integer(7000, 9000), To World, Cancel Contrary Motion);
			Play Effect(All Living Players(Team 1), Explosion Sound, Color(Yellow), Position Of(Event Player), 90);
			Play Effect(All Living Players(Team 1), Good Explosion, Color(Yellow), Position Of(Event Player), Global.GERadius);
		End;
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Player uses voice line (Voice Line or Die)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 15;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GECount < Global.GERequiredNum;
		"Player will have to delay their \"Hello\" by 5 seconds for input to be read. !Overwatch issue!"
		Is Communicating Any Voice line(Event Player) == True;
	}

	actions
	{
		"Set status id for player(if needed)"
		Event Player.GECount += 1;
		Play Effect(Event Player, Buff Explosion Sound, Color(White), Event Player, 90);
		Play Effect(All Players(Team 1), Good Explosion, Color(White), Event Player, 1);
	}
}

rule("Kill nearby players (Die with Me!)(GE)")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEChoice == 17;
		Global.IsGETimerStart == True;
	}

	actions
	{
		"Save IDs of something for the player(if needed)"
		Event Player.GETempVar = Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Off);
		"Save IDs of something for the player(if needed)"
		Kill(Filtered Array(Event Player.GETempVar, (Hero Of(Current Array Element) == Hero(D.Va) && Is In Alternate Form(
			Current Array Element)) || (Hero Of(Current Array Element) != Hero(D.Va))), Closest Player To(Position Of(Event Player),
			Team 2));
		Event Player.GETempVar = Filtered Array(Event Player.GETempVar, Hero Of(Current Array Element) == Hero(D.Va)
			&& !Is In Alternate Form(Current Array Element));
		If(Count Of(Event Player.GETempVar) > 0);
			"Save IDs of something for the player(if needed)"
			Kill(Event Player.GETempVar, Closest Player To(Position Of(Event Player), Team 2));
			Wait(1, Ignore Condition);
			"Save IDs of something for the player(if needed)"
			Kill(Event Player.GETempVar, Closest Player To(Position Of(Event Player), Team 2));
	}
}

rule("Player looks at a (Medusa) (GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 19;
		Global.IsGETimerStart == True;
		Is In Spawn Room(Event Player) == False;
		Event Player.IsWinner == False;
		Is True For Any(Players in View Angle(Event Player, Team 1, Global.GEViewAngle), Array Contains(Global.GECarriers,
			Current Array Element) && Is In Line of Sight(Position Of(Event Player), Position Of(Current Array Element),
			Barriers Do Not Block LOS)) == True;
	}

	actions
	{
		Set Status(Event Player, Null, Frozen, 9999);
		Wait(0.250, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Player not looking at a (Medusa) (GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 19;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Is In Spawn Room(Event Player) == False;
		Is True For Any(Players in View Angle(Event Player, Team 1, Global.GEViewAngle), Array Contains(Global.GECarriers,
			Current Array Element) && Is In Line of Sight(Position Of(Event Player), Position Of(Current Array Element),
			Barriers Do Not Block LOS)) == False;
	}

	actions
	{
		Wait(1.700, Abort When False);
		"Save IDs of something for the player(if needed)"
		Clear Status(Event Player, Frozen);
	}
}

rule("Player is in spawn room (Medusa) (GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 19;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Is In Spawn Room(Event Player) == True;
		Has Status(Event Player, Frozen) == True;
	}

	actions
	{
		"Save IDs of something for the player(if needed)"
		Clear Status(Event Player, Frozen);
	}
}

rule("Sleeping player (Sleepy TBags)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 21;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Has Status(Event Player, Asleep) == True;
		Is True For Any(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Surfaces),
			!Current Array Element.IsWinner && !Has Status(Current Array Element, Asleep)) == True;
	}

	actions
	{
		Event Player.GETempVar = Filtered Array(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Surfaces),
			!Has Status(Current Array Element, Asleep) && !Current Array Element.IsWinner);
		For Player Variable(Event Player, loopNum, 0, Count Of(Event Player.GETempVar), 1);
			If(Is Crouching(Event Player.GETempVar[Event Player.loopNum]) == True);
				Event Player.GETempVar[Event Player.loopNum].IsGETBagCrouched = True;
			Else If(Is Standing(Event Player.GETempVar[Event Player.loopNum])
					&& Event Player.GETempVar[Event Player.loopNum].IsGETBagCrouched);
				Event Player.GETempVar[Event Player.loopNum].IsGETBagStand = True;
			End;
		End;
		Wait(0.200, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Player has made a complete TBag sequence (Sleepy TBags)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 21;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Has Status(Event Player, Asleep) == False;
		Event Player.IsGETBagCrouched == True;
		Event Player.IsGETBagStand == True;
		Event Player.GECount < Global.GERequiredNum;
	}

	actions
	{
		Event Player.IsGETBagCrouched = False;
		Event Player.IsGETBagStand = False;
		Event Player.GECount += 1;
		Play Effect(All Players(Team 1), Ring Explosion, Color(White), Event Player, 2);
		Play Effect(All Players(Team 1), Ring Explosion Sound, Color(White), Event Player, 80);
	}
}

rule("Player walks away from sleeper (Sleepy TBags)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 21;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GECount < Global.GERequiredNum;
		Has Status(Event Player, Asleep) == False;
		Is True For All(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Surfaces), !Has Status(
			Current Array Element, Asleep)) == True;
	}

	actions
	{
		Event Player.GECount = 0;
		Event Player.IsGETBagCrouched = False;
		Event Player.IsGETBagStand = False;
	}
}

rule("Player has completed the required TBag limit (Sleepy TBags)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 21;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEHUDID != -1;
		Has Status(Event Player, Asleep) == False;
		Event Player.GECount >= Global.GERequiredNum;
	}

	actions
	{
		Set Move Speed(Event Player, 180);
		Global.TempVar = First Of(Filtered Array(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Off),
			Has Status(Current Array Element, Asleep)));
		Clear Status(Global.TempVar, Asleep);
		Stop Forcing Player Outlines(Global.TempVar, All Players(Team 1));
		Destroy HUD Text(Event Player.GEHUDID);
		Event Player.GEHUDID = -1;
	}
}

rule("Init Carrier players (Piggyback)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 22;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEIsHeroCarrier == True;
		Event Player.GEHUDID == Null;
	}

	actions
	{
		Create HUD Text(Event Player, Custom String("Status: Carrier"), Null, Null, Right, 0, Color(Yellow), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Event Player.GEHUDID = Array(Last Text ID);
		Create HUD Text(Event Player, Custom String("Rider: {0}", Global.TempVar.GEHeroRider), Null, Null, Right, 0, Color(Orange), Color(
			White), Color(White), Visible To and String, Default Visibility);
		Modify Player Variable(Event Player, GEHUDID, Append To Array, Last Text ID);
		Start Forcing Player Outlines(Event Player, All Players(Team 1), True, Color(Orange), Always);
	}
}

rule("Reset Carrier stats & release rider(Piggyback)(GE)[SR]")
{
	event
	{
		Subroutine;
		GEResetHeroCarrierStats;
	}

	actions
	{
		If(Global.IsGETimerStart && Global.GEChoice == 22 && Event Player.GEHeroRider != Null);
			Detach Players(Event Player.GEHeroRider);
			Stop Scaling Player(Event Player.GEHeroRider);
			Destroy HUD Text(Event Player.GEHeroRider.GEHUDID);
			Event Player.GEHeroRider.GEHeroCarrier = Null;
			Clear Status(Event Player.GEHeroRider, Unkillable);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHeroRider = Null;
	}
}

rule("Reset Rider stats & release (Piggyback)(GE)[SR]")
{
	event
	{
		Subroutine;
		GEResetHeroRiderStats;
	}

	actions
	{
		If(Global.IsGETimerStart && Global.GEChoice == 22 && Event Player.GEHeroCarrier != Null);
			"Count the number of times something happens (if neccessary)"
			Detach Players(Event Player);
			Stop Scaling Player(Event Player);
			Event Player.GEHeroCarrier.GEHeroRider = Null;
			"Save IDs of something for the player(if needed)"
			Event Player.GEHeroCarrier = Null;
			Destroy HUD Text(Event Player.GEHUDID);
			Clear Status(Event Player, Unkillable);
	}
}

rule("Carrier reaches goal with a Rider (PiggyBack)(GE)[SR]")
{
	event
	{
		Subroutine;
		PromoteHeroRider;
	}

	actions
	{
		If(Global.IsGETimerStart && Global.GEChoice == 22 && Event Player.GEHeroRider != Null);
			Detach Players(Event Player.GEHeroRider);
			Stop Scaling Player(Event Player.GEHeroRider);
			Destroy HUD Text(Event Player.GEHeroRider.GEHUDID);
			Event Player.GEHeroRider.GEHeroCarrier = Null;
			Clear Status(Event Player.GEHeroRider, Unkillable);
			Teleport(Event Player.GEHeroRider, Position Of(Event Player));
			"Save IDs of something for the player(if needed)"
			Event Player.GEHeroRider = Null;
	}
}

rule("A Carrier or Rider left the game (Piggyback)(GE)")
{
	event
	{
		Player Left Match;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 22;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
	}

	actions
	{
		If(Event Player.GEIsHeroCarrier && Event Player.GEHeroRider != Null);
			Call Subroutine(GEResetHeroCarrierStats);
		Else If(!Event Player.GEIsHeroCarrier && Event Player.GEHeroCarrier != Null);
			Call Subroutine(GEResetHeroRiderStats);
	}
}

rule("Grabs a Rider(Piggyback)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 22;
		Global.IsGETimerStart == True;
		Is In Spawn Room(Event Player) == False;
		Event Player.IsWinner == False;
		Event Player.GEIsHeroCarrier == True;
		Event Player.GEHeroRider == Null;
		Is Button Held(Event Player, Button(Melee)) == True;
		Is True For Any(Players in View Angle(Event Player, Team 1, Global.GEViewAngle), Distance Between(Position Of(Event Player),
			Position Of(Current Array Element)) <= Global.GEMeleeDistance && Is In Line of Sight(Position Of(Event Player), Position Of(
			Current Array Element), Barriers Do Not Block LOS)
			&& !Current Array Element.IsWinner && !Current Array Element.GEIsHeroCarrier) == True;
	}

	actions
	{
		"Save IDs of something for the player(if needed)"
		Event Player.GEHeroRider = First Of(Filtered Array(Players in View Angle(Event Player, Team 1, Global.GEViewAngle),
			Distance Between(Position Of(Event Player), Position Of(Current Array Element))
			<= Global.GEMeleeDistance && Is In Line of Sight(Position Of(Event Player), Position Of(Current Array Element),
			Barriers Do Not Block LOS) && !Current Array Element.IsWinner && !Current Array Element.GEIsHeroCarrier));
		Event Player.GEHeroRider.GEHeroCarrier = Event Player;
		"Count the number of times something happens (if neccessary)"
		Attach Players(Event Player.GEHeroRider, Event Player, Vector(0, 0.900, -0.425));
		Start Scaling Player(Event Player.GEHeroRider, 0.400, False);
		Play Effect(All Players(Team 1), Good Pickup Effect, Color(Yellow), Event Player, 3);
		Play Effect(All Players(Team 1), Explosion Sound, Color(White), Event Player, 90);
		Create HUD Text(Event Player.GEHeroRider, Custom String("You are being carried!"), Null, Null, Right, 0, Color(Yellow), Color(
			White), Color(White), Visible To, Default Visibility);
		Event Player.GEHeroRider.GEHUDID = Last Text ID;
		Set Status(Event Player.GEHeroRider, Null, Unkillable, 9999);
	}
}

rule("When Carrier enters spawn, detach Rider(Piggyback)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 22;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEHeroRider != Null;
		Is In Spawn Room(Event Player) == True;
	}

	actions
	{
		"Count the number of times something happens (if neccessary)"
		Call Subroutine(GEResetHeroCarrierStats);
	}
}

rule("Init players (Guardian Angel) (GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 23;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEHUDID == Null;
		(Event Player.GEGuardianAngel != Null || Event Player.GEHumanProtect != Null) == True;
	}

	actions
	{
		If(Event Player.GEHumanProtect != Null);
			Create HUD Text(Event Player, Custom String("Status: Guardian Angel"), Null, Null, Right, 0, Color(Yellow), Color(White), Color(
				White), Visible To, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Array(Last Text ID);
			Create HUD Text(Event Player, Custom String("Protecting: {0}", Hero Icon String(Hero Of(Event Player.GEHumanProtect))), Null, Null,
				Right, 0, Color(Green), Color(White), Color(White), Visible To, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Modify Player Variable(Event Player, GEHUDID, Append To Array, Last Text ID);
			Start Forcing Player Outlines(Event Player, Event Player.GEHumanProtect, True, Color(Yellow), Always);
		Else If(Event Player.GEGuardianAngel != Null);
			Create HUD Text(Event Player, Custom String("Status: Human"), Null, Null, Right, 0, Color(Yellow), Color(White), Color(White),
				Visible To, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Array(Last Text ID);
			Create HUD Text(Event Player, Custom String("Guardian Angel: {0}", Hero Icon String(Hero Of(Event Player.GEGuardianAngel))), Null,
				Null, Right, 0, Color(Green), Color(White), Color(White), Visible To, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Modify Player Variable(Event Player, GEHUDID, Append To Array, Last Text ID);
			Start Forcing Player Outlines(Event Player, Event Player.GEGuardianAngel, True, Color(Yellow), Always);
			Set Status(Event Player, Null, Unkillable, 9999);
	}
}

rule("Human about to die (Guardian Angel)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 23;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEGuardianAngel != Null;
		Health(Event Player) == 1;
	}

	actions
	{
		"Completely kill D.va in mech"
		If(Hero Of(Event Player.GEGuardianAngel) == Hero(D.Va) && !Is In Alternate Form(Event Player.GEGuardianAngel));
			Kill(Event Player.GEGuardianAngel, Closest Player To(Position Of(Event Player), Team 2));
			Wait(1, Ignore Condition);
			Kill(Event Player.GEGuardianAngel, Closest Player To(Position Of(Event Player), Team 2));
		Else;
			Kill(Event Player.GEGuardianAngel, Closest Player To(Position Of(Event Player), Team 2));
		End;
		Destroy HUD Text(Event Player.GEHUDID[0]);
		Destroy HUD Text(Event Player.GEHUDID[1]);
		Destroy HUD Text(Event Player.GEGuardianAngel.GEHUDID[0]);
		Destroy HUD Text(Event Player.GEGuardianAngel.GEHUDID[1]);
		Event Player.GEHUDID = Null;
		Event Player.GEGuardianAngel.GEHUDID = Null;
		Stop Forcing Player Outlines(Event Player, All Players(Team 1));
		Stop Forcing Player Outlines(Event Player.GEGuardianAngel, All Players(Team 1));
		Event Player.GEGuardianAngel.GEHumanProtect = Null;
		Event Player.GEGuardianAngel = Null;
		Wait(3, Ignore Condition);
		Clear Status(Event Player, Unkillable);
	}
}

rule("Combine max health with soulmate (Soul Link)(GE)[SR]")
{
	event
	{
		Subroutine;
		GECombineMaxHealth;
	}

	actions
	{
		If(Global.GEChoice == 24 && Event Player.GESoulMate != Null);
			Set Max Health(Event Player, 100);
			Set Max Health(Event Player.GESoulMate, 100);
			Event Player.GETempVar = (Max Health(Event Player) + Max Health(Event Player.GESoulMate)) / Max Health(Event Player) * 100;
			Set Max Health(Event Player, Event Player.GETempVar);
			Set Max Health(Event Player.GESoulMate, Event Player.GETempVar);
			Wait(0.250, Ignore Condition);
			Heal(Event Player, Null, 9999);
			Heal(Event Player.GESoulMate, Null, 9999);
	}
}

rule("Init soulmate players (Soul Link)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 24;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEHUDID == Null;
		Event Player.GESoulMate != Null;
	}

	actions
	{
		Create HUD Text(Event Player, Custom String("Soulmate: {0}", Hero Icon String(Hero Of(Event Player.GESoulMate))), Null, Null,
			Right, 0, Color(Yellow), Color(White), Color(White), Visible To and String, Default Visibility);
		Event Player.GEHUDID = Last Text ID;
		Start Forcing Player Outlines(Event Player, Event Player.GESoulMate, True, Color(Yellow), Always);
		Call Subroutine(GECombineMaxHealth);
	}
}

rule("soul linked player takes damage (Soul Link)(GE)")
{
	event
	{
		Player Took Damage;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 24;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GESoulMate != Null;
	}

	actions
	{
		Event Player.GEIsRecentlyHurt = True;
		Wait(2, Ignore Condition);
		Event Player.GEIsRecentlyHurt = False;
	}
}

rule("soul linked player dies (Soul Link)(GE)")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 24;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GESoulMate != Null;
	}

	actions
	{
		"D.va has two forms. This is used to completely kill D.va"
		If(Hero Of(Event Player.GESoulMate) == Hero(D.Va) && !Is In Alternate Form(Event Player.GESoulMate));
			Kill(Event Player.GESoulMate, Closest Player To(Position Of(Event Player.GESoulMate), Team 2));
			Wait(1, Ignore Condition);
			Kill(Event Player.GESoulMate, Closest Player To(Position Of(Event Player.GESoulMate), Team 2));
		Else;
			Kill(Event Player.GESoulMate, Closest Player To(Position Of(Event Player.GESoulMate), Team 2));
	}
}

rule("Link health between soulmates (Soul Link)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 24;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GESoulMate != Null;
		Health(Event Player) != Health(Event Player.GESoulMate);
	}

	actions
	{
		If(Event Player.GEIsRecentlyHurt || Event Player.GESoulMate.GEIsRecentlyHurt);
			Event Player.temp = Min(Health(Event Player), Health(Event Player.GESoulMate));
		Else;
			Event Player.temp = Max(Health(Event Player), Health(Event Player.GESoulMate));
		End;
		Set Player Health(Event Player, Event Player.temp);
		Set Player Health(Event Player.GESoulMate, Event Player.temp);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("soul linked player receives healing (Soul Link)(GE)")
{
	event
	{
		Player Received Healing;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 24;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GESoulMate != Null;
		Is In Spawn Room(Event Player) == False;
	}

	actions
	{
		Heal(Event Player.GESoulMate, Null, Event Healing);
	}
}

rule("Select a throttle for the player to move (One Direction)(GE)[SR]")
{
	event
	{
		Subroutine;
		GESelectThrottle;
	}

	actions
	{
		Stop Forcing Throttle(Event Player);
		Global.GEMultiChoice = Random Integer(0, 2);
		"Forward"
		If(Global.GEMultiChoice == 0);
			Start Forcing Throttle(Event Player, 0, 1, 0, 0, 0, 0);
		Else If(Global.GEMultiChoice == 1);
			Start Forcing Throttle(Event Player, 0, 0, 0, 1, 0, 0);
		Else;
			Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 1);
	}
}

rule("Set initial throttle (One Direction)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 25;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEID == Null;
	}

	actions
	{
		"Save IDs of something for the player(if needed)"
		Event Player.GEID = 22;
		Call Subroutine(GESelectThrottle);
	}
}

rule("Change throttle if player dies (One Direction)(GE)")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 25;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
	}

	actions
	{
		Call Subroutine(GESelectThrottle);
	}
}

rule("Init Tagger outline(World Tag)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 26;
		Global.IsGETimerStart == True;
		Event Player.GEIsTagger == True;
		Event Player.IsWinner == False;
	}

	actions
	{
		Start Forcing Player Outlines(Event Player, All Players(Team 1), True, Color(Yellow), Always);
	}
}

rule("Tagger tags a player (World Tag)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 26;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEIsTagger == True;
		Is Button Held(Event Player, Button(Melee)) == True;
		Is True For Any(Players in View Angle(Event Player, Team 1, Global.GEViewAngle), Distance Between(Position Of(Event Player),
			Position Of(Current Array Element)) < Global.GEMeleeDistance && Is In Line of Sight(Position Of(Event Player), Position Of(
			Current Array Element), Barriers Do Not Block LOS) && !Current Array Element.IsWinner && !Current Array Element.GEIsTagged)
			== True;
	}

	actions
	{
		"Save IDs of something for the player(if needed)"
		Global.TempVar = First Of(Filtered Array(Players in View Angle(Event Player, Team 1, Global.GEViewAngle), Distance Between(
			Position Of(Event Player), Position Of(Current Array Element)) < Global.GEMeleeDistance && Is In Line of Sight(Position Of(
			Event Player), Position Of(Current Array Element), Barriers Do Not Block LOS)
			&& !Current Array Element.IsWinner && !Current Array Element.GEIsTagged));
		"Count the number of times something happens (if neccessary)"
		Global.TempVar.GEIsTagger = True;
		"Count the number of times something happens (if neccessary)"
		Global.TempVar.GEIsTagged = True;
		Start Forcing Player Outlines(Global.TempVar, All Players(Team 1), True, Color(Yellow), Always);
		Event Player.GEIsTagger = False;
		Global.GECurReqNum += 1;
		Play Effect(All Players(Team 1), Good Pickup Effect, Color(Yellow), Event Player, 4);
		Play Effect(All Players(Team 1), Buff Explosion Sound, Color(White), Event Player, 80);
		Start Forcing Player Outlines(Event Player, All Players(Team 1), True, Color(Orange), Always);
	}
}

rule("Bug is going to be squished (Bugs)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		(Global.GEChoice == 27 || Global.GEChoice == 46) == True;
		Global.IsGETimerStart == True;
		Event Player.GEIsAffectedPlayer == True;
		Event Player.IsWinner == False;
		Is In Spawn Room(Event Player) == False;
		Is True For Any(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Surfaces),
			!Current Array Element.GEIsAffectedPlayer) == True;
	}

	actions
	{
		Play Effect(All Players(Team 1), Brigitte Repair Pack Armor Sound, Color(White), Event Player, 90);
		If(Global.GEChoice == 27);
			If(Hero Of(Event Player) == Hero(D.Va) && !Is In Alternate Form(Event Player));
				Kill(Event Player, Closest Player To(Position Of(Event Player), Team 2));
				Wait(1, Ignore Condition);
				Kill(Event Player, Closest Player To(Position Of(Event Player), Team 2));
			Else;
				Kill(Event Player, Closest Player To(Position Of(Event Player), Team 2));
			End;
			Communicate(Event Player, Thanks);
			Communicate(First Of(Filtered Array(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Surfaces),
				!Current Array Element.GEIsAffectedPlayer)), Sorry);
		Else;
			If(Hero Of(Event Player) == Hero(D.Va) && !Is In Alternate Form(Event Player));
				Kill(Closest Player To(Event Player, Team 1), Closest Player To(Position Of(Event Player), Team 2));
				Wait(1, Ignore Condition);
				Kill(Closest Player To(Event Player, Team 1), Closest Player To(Position Of(Event Player), Team 2));
			Else;
				Kill(Closest Player To(Event Player, Team 1), Closest Player To(Position Of(Event Player), Team 2));
			End;
			Communicate(First Of(Filtered Array(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Surfaces),
				!Current Array Element.GEIsAffectedPlayer)), Thanks);
			Communicate(Event Player, Sorry);
		End;
	}
}

rule("Bodyguard near the President (President)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 29;
		Global.IsGETimerStart == True;
		Is True For Any(Players Within Radius(Position Of(Global.GEAffectedPlayer), Global.GERadius, Team 1, Surfaces),
			Current Array Element != Global.GEAffectedPlayer) == True;
	}

	actions
	{
		Set Max Health(Filtered Array(Players Within Radius(Position Of(Global.GEAffectedPlayer), Global.GERadius, Team 1, Off),
			Current Array Element != Global.GEAffectedPlayer), 250);
		Heal(Filtered Array(Players Within Radius(Position Of(Global.GEAffectedPlayer), Global.GERadius, Team 1, Off),
			Current Array Element != Global.GEAffectedPlayer), Null, 9999);
	}
}

rule("Bodyguards not close to President (President)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 29;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player != Global.GEAffectedPlayer;
		Is True For All(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Off),
			Current Array Element != Global.GEAffectedPlayer) == True;
	}

	actions
	{
		Set Max Health(Event Player, 100);
	}
}

rule("Set move speed of Ball (Extreme Pong)(GE)[SR]")
{
	event
	{
		Subroutine;
		GESetPongBallSpeed;
	}

	actions
	{
		If(Distance Between(Eye Position(Global.GETarget) - Vector(0, 0.500, 0), Global.GEBallPosition) <= 7);
			Global.GEBallSpeed = 5;
		Else;
			Global.GEBallSpeed = 30;
	}
}

rule("Init Extreme Pong game (Extreme Pong)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 30;
		Global.IsGETimerStart == True;
		Global.GETarget == Null;
	}

	actions
	{
		Global.GETarget = Random Value In Array(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
		If(Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter));
			Global.GEBallPosition = Global.BlizzWorldSpawnLoc + Vector(0, 3, 0);
		Else If(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween));
			Global.GEBallPosition = Global.HollywoodSpawns[0] + Vector(0, 3, 0);
		Else;
			Global.GEBallPosition = Random Value In Array(Spawn Points(Team 1)) + Vector(0, 3, 0);
		End;
		Wait(2.500, Ignore Condition);
		Chase Global Variable At Rate(GEBallPosition, Eye Position(Global.GETarget) - Vector(0, 0.500, 0), Global.GEBallSpeed,
			Destination and Rate);
		Loop If Condition Is True;
	}
}

rule("Target hits Ball (Extreme Pong)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 30;
		Global.IsGETimerStart == True;
		Global.GETarget == Event Player;
		Is Button Held(Event Player, Button(Melee)) == True;
		Distance Between(Eye Position(Event Player) - Vector(0, 0.500, 0), Global.GEBallPosition) < Global.GEMeleeDistance;
	}

	actions
	{
		Stop Chasing Global Variable(GEBallPosition);
		Play Effect(All Players(Team 1), Buff Explosion Sound, Color(White), Event Player, 90);
		Global.GETarget = Random Value In Array(Filtered Array(All Players(Team 1),
			Current Array Element != Event Player && !Current Array Element.IsWinner));
		Chase Global Variable At Rate(GEBallPosition, Eye Position(Global.GETarget) - Vector(0, 0.500, 0), Global.GEBallSpeed,
			Destination and Rate);
	}
}

rule("Ball chases Target (Extreme Pong)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 30;
		Global.IsGETimerStart == True;
		Global.GETarget != Null;
	}

	actions
	{
		If(Distance Between(Eye Position(Global.GETarget) - Vector(0, 0.500, 0), Global.GEBallPosition) <= 1);
			Stop Chasing Global Variable(GEBallPosition);
			Kill(Global.GETarget, Closest Player To(Global.GETarget, Team 2));
			Play Effect(All Players(Team 1), Junkrat Concussion Mine Explosion Sound, Color(White), Global.GETarget, 90);
			Play Effect(All Players(Team 1), Bad Explosion, Color(Red), Global.GETarget, 4);
			Global.GETarget = Null;
		End;
		Call Subroutine(GESetPongBallSpeed);
		Wait(0.150, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Lag player (I'm Lagging)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 31;
		Global.IsGETimerStart == True;
	}

	actions
	{
		"Lag intervals"
		Wait(Random Real(2, 20), Abort When False);
		Event Player.GELagType = Random Integer(0, 25);
		Event Player.GELagDistance = Random Real(1, 20);
		If(Event Player.GELagType == 0);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + Forward * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 1);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Forward + Right) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 2);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + Right * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 3);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Backward + Right) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 4);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + Backward * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 5);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Backward + Left) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 6);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + Left * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 7);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Forward + Left) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 8);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Forward + Down) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 9);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Forward + Up) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 10);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Right + Up) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 11);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Right + Down) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 12);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Backward + Down) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 13);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Backward + Up) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 14);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Left + Up) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 15);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Left + Down) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 16);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Forward + Right + Up) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 17);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Forward + Right + Down)
				* Event Player.GELagDistance);
		Else If(Event Player.GELagType == 18);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Backward + Right + Down)
				* Event Player.GELagDistance);
		Else If(Event Player.GELagType == 19);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Backward + Right + Up)
				* Event Player.GELagDistance);
		Else If(Event Player.GELagType == 20);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Forward + Left + Up) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 21);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Forward + Left + Down)
				* Event Player.GELagDistance);
		Else If(Event Player.GELagType == 22);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Backward + Left + Down)
				* Event Player.GELagDistance);
		Else If(Event Player.GELagType == 23);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Backward + Left + Up) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 24);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + Up * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 25);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + Down * Event Player.GELagDistance);
		End;
		Set Status(Event Player, Null, Invincible, Random Real(2, 3));
		Teleport(Event Player, Event Player.GELagPos);
		Play Effect(Event Player, Buff Explosion Sound, Color(White), Event Player, 80);
		Loop If Condition Is True;
	}
}

rule("Select a Bastion Bullet Upgrade (BU)[Bullet][SR]")
{
	event
	{
		Subroutine;
		SelectBastionBulletUpgrade;
	}

	actions
	{
		Global.TempVar4 = Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Bastion));
		"Knockback Bullets"
		If(Global.BUChoices[0] == 1);
			Global.BastionDamages[1] = 50;
		"Flaming Bullets"
		Else If(Global.BUChoices[0] == 2);
			Global.BastionDamages[1] = 0.500;
		"Tank Mode"
		Else If(Global.BUChoices[0] == 4);
			Allow Button(Global.TempVar4, Button(Ultimate));
			Set Ultimate Ability Enabled(Global.TempVar4, True);
			Set Ultimate Charge(Global.TempVar4, 100);
			Press Button(Global.TempVar4, Button(Ultimate));
			Disallow Button(Global.TempVar4, Button(Ultimate));
			Set Ultimate Ability Enabled(Global.TempVar4, False);
			Global.BastionDamages[1] = Global.BastionDamages[0];
		"Concussion Bullets"
		Else If(Global.BUChoices[0] == 5);
			Global.BastionDamages[1] = 100;
		"None"
		Else;
			Global.BastionDamages[1] = Global.BastionDamages[0];
		End;
		Call Subroutine(SetGEBastionDamage);
	}
}

rule("Player took damage (BU)[Bullet]")
{
	event
	{
		Player Took Damage;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsBastionUpgradableWS == True;
		Attacker != Event Player;
		(Global.BUChoices[0] == 2 || Global.BUChoices[0] == 1 || Global.BUChoices[0] == 5 || Global.BUChoices[0] == 6) == True;
	}

	actions
	{
		"Flame Bullets"
		If(Global.BUChoices[0] == 2);
			Set Status(Event Player, Null, Burning, 10);
			Start Damage Over Time(Event Player, Null, 10, Random Real(0.500, 5.100));
		"Knockback Bullets"
		Else If(Global.BUChoices[0] == 1);
			Apply Impulse(Event Player, Event Direction, Random Real(5, 8.300), To World, Cancel Contrary Motion);
		"Concussion Bullets"
		Else If(Global.BUChoices[0] == 5 && Random Integer(0, 19) == 6);
			Set Status(Event Player, Null, Stunned, 0.700);
		"Shock Bullets"
		Else If(Global.BUChoices[0] == 6);
			Event Player.BUPlayersNearby = Players Within Radius(Event Player, 10, Team 1, Off);
			For Player Variable(Event Player, BUIndex, 0, Count Of(Event Player.BUPlayersNearby), 1);
				Damage(Event Player.BUPlayersNearby[Event Player.BUIndex], Closest Player To(Event Player, Team 2), Event Damage * 0.700);
				Create Beam Effect(All Players(Team 1), Bad Beam, Event Player, Event Player.BUPlayersNearby[Event Player.BUIndex], Color(Aqua),
					Visible To Position and Radius);
				Event Player.BUBulletEffectIDs[0] = Last Created Entity;
				Create Effect(All Players(Team 1), Energy Sound, Color(White), Event Player.BUPlayersNearby[Event Player.BUIndex], 80,
					Visible To Position and Radius);
				Event Player.BUBulletEffectIDs[1] = Last Created Entity;
				Wait(1, Abort When False);
				Destroy Effect(Event Player.BUBulletEffectIDs);
			End;
	}
}

rule("Bastion kills player (BU)[Bullet]")
{
	event
	{
		Player Dealt Final Blow;
		Team 2;
		Bastion;
	}

	conditions
	{
		Global.IsBastionUpgradableWS == True;
		Global.BUChoices[0] == 3;
	}

	actions
	{
		"Teleport Bullets"
		If(Global.BUChoices[0] == 3);
			Victim.BUTelePos = Position Of(Victim);
			Wait(0.150, Ignore Condition);
			Victim.BUTeleType = Random Integer(0, 24);
			Victim.BUTeleDistance = Random Real(3, 30);
			If(Victim.BUTeleType == 0);
				Victim.BUTelePos = Victim.BUTelePos + Forward * Victim.BUTeleDistance;
			Else If(Victim.BUTeleType == 1);
				Victim.BUTelePos = Victim.BUTelePos + (Forward + Right) * Victim.BUTeleDistance;
			Else If(Victim.BUTeleType == 2);
				Victim.BUTelePos = Victim.BUTelePos + Right * Victim.BUTeleDistance;
			Else If(Victim.BUTeleType == 3);
				Victim.BUTelePos = Victim.BUTelePos + (Backward + Right) * Victim.BUTeleDistance;
			Else If(Victim.BUTeleType == 4);
				Victim.BUTelePos = Victim.BUTelePos + Backward * Victim.BUTeleDistance;
			Else If(Victim.BUTeleType == 5);
				Victim.BUTelePos = Victim.BUTelePos + (Backward + Left) * Victim.BUTeleDistance;
			Else If(Victim.BUTeleType == 6);
				Victim.BUTelePos = Victim.BUTelePos + Left * Victim.BUTeleDistance;
			Else If(Victim.BUTeleType == 7);
				Victim.BUTelePos = Victim.BUTelePos + (Forward + Left) * Victim.BUTeleDistance;
			Else If(Victim.BUTeleType == 8);
				Victim.BUTelePos = Nearest Walkable Position(Victim.BUTelePos + (Forward + Down) * Victim.BUTeleDistance);
			Else If(Victim.BUTeleType == 9);
				Victim.BUTelePos = Victim.BUTelePos + (Forward + Up) * Victim.BUTeleDistance;
			Else If(Victim.BUTeleType == 10);
				Victim.BUTelePos = Victim.BUTelePos + (Right + Up) * Victim.BUTeleDistance;
			Else If(Victim.BUTeleType == 11);
				Victim.BUTelePos = Nearest Walkable Position(Victim.BUTelePos + (Right + Down) * Victim.BUTeleDistance);
			Else If(Victim.BUTeleType == 12);
				Victim.BUTelePos = Nearest Walkable Position(Victim.BUTelePos + (Backward + Down) * Victim.BUTeleDistance);
			Else If(Victim.BUTeleType == 13);
				Victim.BUTelePos = Victim.BUTelePos + (Backward + Up) * Victim.BUTeleDistance;
			Else If(Victim.BUTeleType == 14);
				Victim.BUTelePos = Victim.BUTelePos + (Left + Up) * Victim.BUTeleDistance;
			Else If(Victim.BUTeleType == 15);
				Victim.BUTelePos = Nearest Walkable Position(Victim.BUTelePos + (Left + Down) * Victim.BUTeleDistance);
			Else If(Victim.BUTeleType == 16);
				Victim.BUTelePos = Victim.BUTelePos + (Forward + Right + Up) * Victim.BUTeleDistance;
			Else If(Victim.BUTeleType == 17);
				Victim.BUTelePos = Nearest Walkable Position(Victim.BUTelePos + (Forward + Right + Down) * Victim.BUTeleDistance);
			Else If(Victim.BUTeleType == 18);
				Victim.BUTelePos = Nearest Walkable Position(Victim.BUTelePos + (Backward + Right + Down) * Victim.BUTeleDistance);
			Else If(Victim.BUTeleType == 19);
				Victim.BUTelePos = Victim.BUTelePos + (Backward + Right + Up) * Victim.BUTeleDistance;
			Else If(Victim.BUTeleType == 20);
				Victim.BUTelePos = Victim.BUTelePos + (Forward + Left + Up) * Victim.BUTeleDistance;
			Else If(Victim.BUTeleType == 21);
				Victim.BUTelePos = Nearest Walkable Position(Victim.BUTelePos + (Forward + Left + Down) * Victim.BUTeleDistance);
			Else If(Victim.BUTeleType == 22);
				Victim.BUTelePos = Nearest Walkable Position(Victim.BUTelePos + (Backward + Left + Down) * Victim.BUTeleDistance);
			Else If(Victim.BUTeleType == 23);
				Victim.BUTelePos = Victim.BUTelePos + (Backward + Left + Up) * Victim.BUTeleDistance;
			Else If(Victim.BUTeleType == 24);
				Victim.BUTelePos = Victim.BUTelePos + Up * Victim.BUTeleDistance;
			End;
			Wait Until(Is Alive(Victim), 5);
			Teleport(Victim, Victim.BUTelePos);
			Play Effect(Event Player, Moira Fade Reappear Sound, Color(White), Event Player, 90);
			Set Status(Victim, Null, Invincible, 1.600);
	}
}

rule("Before New Bastion Upgrade Choice (BU)[Bullet][SR]")
{
	event
	{
		Subroutine;
		BeforeNewBastionBulletUpgrade;
	}

	actions
	{
		Global.TempVar4 = Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Bastion));
		If(Global.BUChoices[0] == 4);
			Clear Status(Global.TempVar4, Unkillable);
			Kill(Global.TempVar4, Null);
			Set Status(Global.TempVar4, Null, Unkillable, 999999);
	}
}

rule("Player Dies during Bastion Upgrade (BU)")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsBastionUpgradableWS == True;
		Global.BUChoices[0] == 2;
	}

	actions
	{
		Stop All Damage Over Time(Event Player);
		Clear Status(Event Player, Burning);
		Call Subroutine(AddBacktrackDeath);
	}
}

rule("Set new key location (Lockdown)(GE)[SR]")
{
	event
	{
		Subroutine;
		SetKeyLocation;
	}

	actions
	{
		Global.TempVar = Random Value In Array(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
		Global.TempVar2 = Random Integer(0, 25);
		Global.GESpawnDistance = Random Real(15, 90);
		If(Global.TempVar2 == 0);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + Forward * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 1);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Right) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 2);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + Right * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 3);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Right) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 4);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + Backward * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 5);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Left) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 6);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + Left * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 7);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Left) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 8);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 9);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 10);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Right + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 11);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Right + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 12);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 13);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 14);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Left + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 15);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Left + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 16);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Right + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 17);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Right + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 18);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Right + Down)
				* Global.GESpawnDistance);
		Else If(Global.TempVar2 == 19);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Right + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 20);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Left + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 21);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Left + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 22);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Left + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 23);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Left + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 24);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + Up * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 25);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + Down * Global.GESpawnDistance);
		End;
		Global.GEBallPosition += Vector(0, Random Real(0, 5), 0);
	}
}

rule("Player picks up key (Lockdown)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGETimerStart == True;
		Global.GEChoice == 36;
		Global.GEAffectedPlayer == Null;
		Is True For Any(Players Within Radius(Global.GEBallPosition, Global.GERadius + 0.200, Team 1, Off), Is Alive(
			Current Array Element)) == True;
	}

	actions
	{
		Global.GEAffectedPlayer = Closest Player To(Global.GEBallPosition, Team 1);
		Start Forcing Player Outlines(Global.GEAffectedPlayer, All Players(Team 1), True, Color(Yellow), Always);
		Global.GEBallPosition = Vector(0, -1111, 0);
	}
}

rule("Key was used to unlock the exit! (Lockdown)(GE)[SR]")
{
	event
	{
		Subroutine;
		EscapeWithKey;
	}

	actions
	{
		If(Global.GEChoice == 36);
			Global.IsGETimerStart = False;
			Big Message(All Players(Team 1), Custom String("Success!"));
	}
}

rule("Relocate key (Lockdown)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.GEChoice == 36;
		Global.IsGETimerStart == True;
		Global.GEAffectedPlayer == Null;
	}

	actions
	{
		If(Distance Between(Random Value In Array(Spawn Points(Team 2)), Global.GEBallPosition) <= 30);
			Wait(0.100, Abort When False);
		Else;
			Wait(Random Real(40, 120), Abort When False);
		End;
		Call Subroutine(SetKeyLocation);
		Loop If Condition Is True;
	}
}

rule("Player with the key is no longer in the game (Lockdown)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.GEChoice == 36;
		Global.IsGETimerStart == True;
		Global.GEAffectedPlayer != Null;
		Is True For Any(All Players(Team 1), Current Array Element == Global.GEAffectedPlayer) == False;
	}

	actions
	{
		Call Subroutine(SetKeyLocation);
	}
}

rule("Change game speed (Warped Slo-mo)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.GEChoice == 37;
		Global.IsGETimerStart == True;
	}

	actions
	{
		Set Slow Motion(Random Integer(10, 50));
		Set Move Speed(All Players(Team 1), 100);
		Wait(Random Real(1, 3), Abort When False);
		Set Slow Motion(90);
		Set Move Speed(All Players(Team 1), Random Integer(120, 180));
		Wait(Random Real(7, 12), Abort When False);
		Loop If Condition Is True;
	}
}

rule("Player is in (Spotlight)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 38;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Is In Spawn Room(Event Player) == False;
		((Current Map == Map(Blizzard World) && Distance Between(Position Of(Event Player), Global.BlizzWorldSpawnLoc) > 30) || (
			Current Map == Map(Blizzard World Winter) && Distance Between(Position Of(Event Player), Global.BlizzWorldSpawnLoc) > 30) || (
			Current Map != Map(Blizzard World) && Current Map != Map(Blizzard World Winter))) == True;
		((Current Map == Map(Hollywood) && Distance Between(Position Of(Event Player), Global.HollywoodSpawns[0]) > 30) || (
			Current Map == Map(Hollywood Halloween) && Distance Between(Position Of(Event Player), Global.HollywoodSpawns[0]) > 30) || (
			Current Map != Map(Hollywood) && Current Map != Map(Hollywood Halloween))) == True;
		Y Component Of(Position Of(Event Player)) >= Y Component Of(Global.GEBallPosition);
		Distance Between(Position Of(Event Player), Vector(X Component Of(Global.GEBallPosition), Y Component Of(Position Of(
			Event Player)), Z Component Of(Global.GEBallPosition))) <= Global.GERadius;
	}

	actions
	{
		Set Status(Event Player, Null, Frozen, 2);
		Stop Chasing Global Variable(GEBallPosition);
		Wait(1, Ignore Condition);
		Play Effect(Event Player, Debuff Impact Sound, Color(White), Event Player, 90);
		Teleport(Event Player, Position Of(Random Value In Array(All Players(Team 2))));
		Global.GETarget = Null;
	}
}

rule("Choose a Target (Spotlight)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 38;
		Global.IsGETimerStart == True;
	}

	actions
	{
		Wait Until(Global.GETarget == Null || Is In Spawn Room(Global.GETarget) || Position Of(Global.GETarget) == Global.GEBallPosition,
			Random Real(15, 30));
		Stop Chasing Global Variable(GEBallPosition);
		Global.GETarget = Random Value In Array(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner && !Is In Spawn Room(
			Current Array Element)));
		Chase Global Variable At Rate(GEBallPosition, Position Of(Global.GETarget) - Vector(0, 2, 0), Global.GEBallSpeed,
			Destination and Rate);
		Wait(0.100, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Init wind (Strong Winds)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.GEChoice == 39;
		Global.IsGETimerStart == True;
	}

	actions
	{
		Wait(Random Integer(18, 22), Abort When False);
		Stop Chasing Global Variable(GEBallSpeed);
		Global.GEBallSpeed = 0;
		Global.GEBallPosition = Vector(0, 0, 0);
		Global.GEText = Custom String("None");
		Wait(5, Abort When False);
		Call Subroutine(SelectWindDir);
		Call Subroutine(SetWindSpeedRate);
		Loop If Condition Is True;
	}
}

rule("Exhale (Strong Winds)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEChoice == 39;
		Global.IsGETimerStart == True;
	}

	actions
	{
		Apply Impulse(Event Player, Global.GEBallPosition, Global.GEBallSpeed, To World, Cancel Contrary Motion);
		Wait(0.100, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Select wind direction (Strong Winds)(GE)[SR]")
{
	event
	{
		Subroutine;
		SelectWindDir;
	}

	actions
	{
		Global.GEMultiChoice = Random Integer(0, 25);
		If(Global.GEMultiChoice == 0);
			Global.GEBallPosition = Forward;
			Global.GEText = Custom String("{0}|{1}", Icon String(Asterisk), Icon String(Arrow: Up));
		Else If(Global.GEMultiChoice == 1);
			Global.GEBallPosition = Forward + Right;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Asterisk), Icon String(Arrow: Up), Icon String(Arrow: Right));
		Else If(Global.GEMultiChoice == 2);
			Global.GEBallPosition = Right;
			Global.GEText = Custom String("{0}|{1}", Icon String(Asterisk), Icon String(Arrow: Right));
		Else If(Global.GEMultiChoice == 3);
			Global.GEBallPosition = Right + Backward;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Asterisk), Icon String(Arrow: Down), Icon String(Arrow: Right));
		Else If(Global.GEMultiChoice == 4);
			Global.GEBallPosition = Backward;
			Global.GEText = Custom String("{0}|{1}", Icon String(Asterisk), Icon String(Arrow: Down));
		Else If(Global.GEMultiChoice == 5);
			Global.GEBallPosition = Left + Backward;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Asterisk), Icon String(Arrow: Down), Icon String(Arrow: Left));
		Else If(Global.GEMultiChoice == 6);
			Global.GEBallPosition = Left;
			Global.GEText = Custom String("{0}|{1}", Icon String(Asterisk), Icon String(Arrow: Left));
		Else If(Global.GEMultiChoice == 7);
			Global.GEBallPosition = Left + Forward;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Asterisk), Icon String(Arrow: Up), Icon String(Arrow: Left));
		Else If(Global.GEMultiChoice == 8);
			Global.GEBallPosition = Forward + Up;
			Global.GEText = Custom String("{0}|{1}", Icon String(Arrow: Up), Icon String(Arrow: Up));
		Else If(Global.GEMultiChoice == 9);
			Global.GEBallPosition = Forward + Down;
			Global.GEText = Custom String("{0}|{1}", Icon String(Arrow: Down), Icon String(Arrow: Up));
		Else If(Global.GEMultiChoice == 10);
			Global.GEBallPosition = Left + Up;
			Global.GEText = Custom String("{0}|{1}", Icon String(Arrow: Up), Icon String(Arrow: Left));
		Else If(Global.GEMultiChoice == 11);
			Global.GEBallPosition = Left + Down;
			Global.GEText = Custom String("{0}|{1}", Icon String(Arrow: Down), Icon String(Arrow: Left));
		Else If(Global.GEMultiChoice == 12);
			Global.GEBallPosition = Right + Up;
			Global.GEText = Custom String("{0}|{1}", Icon String(Arrow: Up), Icon String(Arrow: Right));
		Else If(Global.GEMultiChoice == 13);
			Global.GEBallPosition = Right + Down;
			Global.GEText = Custom String("{0}|{1}", Icon String(Arrow: Down), Icon String(Arrow: Right));
		Else If(Global.GEMultiChoice == 14);
			Global.GEBallPosition = Backward + Up;
			Global.GEText = Custom String("{0}|{1}", Icon String(Arrow: Up), Icon String(Arrow: Down));
		Else If(Global.GEMultiChoice == 15);
			Global.GEBallPosition = Backward + Down;
			Global.GEText = Custom String("{0}|{1}", Icon String(Arrow: Down), Icon String(Arrow: Down));
		Else If(Global.GEMultiChoice == 16);
			Global.GEBallPosition = Forward + Left + Up;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Arrow: Up), Icon String(Arrow: Up), Icon String(Arrow: Left));
		Else If(Global.GEMultiChoice == 17);
			Global.GEBallPosition = Forward + Left + Down;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Arrow: Down), Icon String(Arrow: Up), Icon String(Arrow: Left));
		Else If(Global.GEMultiChoice == 18);
			Global.GEBallPosition = Forward + Right + Up;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Arrow: Up), Icon String(Arrow: Up), Icon String(Arrow: Right));
		Else If(Global.GEMultiChoice == 19);
			Global.GEBallPosition = Forward + Right + Down;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Arrow: Down), Icon String(Arrow: Up), Icon String(Arrow: Right));
		Else If(Global.GEMultiChoice == 20);
			Global.GEBallPosition = Backward + Left + Up;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Arrow: Up), Icon String(Arrow: Down), Icon String(Arrow: Left));
		Else If(Global.GEMultiChoice == 21);
			Global.GEBallPosition = Backward + Left + Down;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Arrow: Down), Icon String(Arrow: Down), Icon String(Arrow: Left));
		Else If(Global.GEMultiChoice == 22);
			Global.GEBallPosition = Backward + Right + Up;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Arrow: Up), Icon String(Arrow: Down), Icon String(Arrow: Right));
		Else If(Global.GEMultiChoice == 23);
			Global.GEBallPosition = Backward + Right + Down;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Arrow: Down), Icon String(Arrow: Down), Icon String(Arrow: Right));
		Else If(Global.GEMultiChoice == 24);
			Global.GEBallPosition = Up;
			Global.GEText = Custom String("{0}", Icon String(Arrow: Up));
		Else If(Global.GEMultiChoice == 25);
			Global.GEBallPosition = Down;
			Global.GEText = Custom String("{0}", Icon String(Arrow: Down));
		End;
	}
}

rule("Set wind speed rate (String Winds)(GE)[SR]")
{
	event
	{
		Subroutine;
		SetWindSpeedRate;
	}

	actions
	{
		Chase Global Variable At Rate(GEBallSpeed, Random Integer(8, 16), 1 / 27 * Global.GEBallSpeed + 1, Destination and Rate);
	}
}

rule("Init camera (Wacky Camera)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEChoice == 40;
		Global.IsGETimerStart == True;
	}

	actions
	{
		"3rd-person view"
		Call Subroutine(SetCameraView);
	}
}

rule("Set camera view (Wacky Camera)(GE)[SR]")
{
	event
	{
		Subroutine;
		SetCameraView;
	}

	actions
	{
		"3rd-person view"
		If(Global.GECameraChoice == 0);
			"0 = Camera Distance; 1 = Camera Origin Y-Axis"
			Event Player.GECameraStats = Array(5, 3);
			Start Camera(Event Player, Ray Cast Hit Position(Eye Position(Event Player), Facing Direction Of(Event Player)
				* -1 * Event Player.GECameraStats[0] + Eye Position(Event Player) + Vector(0, Event Player.GECameraStats[1], 0), All Players(
				All Teams), Event Player, False), Eye Position(Event Player), 15);
		"Top-down view"
		Else If(Global.GECameraChoice == 1);
			"Camera Distance"
			Event Player.GECameraStats = Vector(0, 20, Facing Direction Of(Event Player) * 100);
			Start Camera(Event Player, Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + Facing Direction Of(
				Event Player) * -1 + Event Player.GECameraStats, All Players(All Teams), Event Player, False), Eye Position(Event Player)
				+ Facing Direction Of(Event Player), 15);
		"Selfie view"
		Else If(Global.GECameraChoice == 2);
			"0 = Camera Distance; 1 = Camera Origin Y-Axis"
			Event Player.GECameraStats = Array(5, 3);
			Start Camera(Event Player, Ray Cast Hit Position(Eye Position(Event Player), Facing Direction Of(Event Player)
				* Event Player.GECameraStats[0] + Eye Position(Event Player) + Vector(0, Event Player.GECameraStats[1], 0), All Players(
				All Teams), Event Player, False), Eye Position(Event Player), 15);
	}
}

rule("Use jet boots (Bad Jet Boots)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 41;
		Global.IsGETimerStart == True;
		Is Button Held(Event Player, Button(Jump)) == True;
	}

	actions
	{
		If(Event Player.GEID == Null);
			Create Effect(All Players(Team 1), Smoke Sound, Color(White), Event Player, 100, Visible To Position and Radius);
			Event Player.GEID = Last Created Entity;
		End;
		Apply Impulse(Event Player, Up, 5, To World, Cancel Contrary Motion);
		Wait(0.080, Ignore Condition);
		Loop If Condition Is True;
		Destroy Effect(Event Player.GEID);
		Event Player.GEID = Null;
	}
}

rule("Player touches ground (Bad Jet Boots)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 41;
		Global.IsGETimerStart == True;
		Is On Ground(Event Player) == True;
		Is In Spawn Room(Event Player) == False;
		((Current Map == Map(Blizzard World) && Distance Between(Position Of(Event Player), Global.BlizzWorldSpawnLoc) > 30) || (
			Current Map == Map(Blizzard World Winter) && Distance Between(Position Of(Event Player), Global.BlizzWorldSpawnLoc) > 30) || (
			Current Map != Map(Blizzard World) && Current Map != Map(Blizzard World Winter))) == True;
		((Current Map == Map(Hollywood) && Distance Between(Position Of(Event Player), Global.HollywoodSpawns[0]) > 30) || (
			Current Map == Map(Hollywood Halloween) && Distance Between(Position Of(Event Player), Global.HollywoodSpawns[0]) > 30) || (
			Current Map != Map(Hollywood) && Current Map != Map(Hollywood Halloween))) == True;
	}

	actions
	{
		If(Hero Of(Event Player) == Hero(D.Va));
			Wait(0.096, Abort When False);
		End;
		Kill(Event Player, Closest Player To(Event Player, Team 2));
		Play Effect(All Players(Team 1), Junkrat Frag Launcher Explosion Sound, Color(White), Event Player, 90);
		If(Event Player.GEID != Null);
			Destroy Effect(Event Player.GEID);
			Event Player.GEID = Null;
	}
}

rule("Widowmaker communicates (Reveal)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Widowmaker;
	}

	conditions
	{
		Global.GEChoice == 42;
		Global.IsGETimerStart == True;
		Is Dummy Bot(Event Player) == True;
		Is Communicating Any(Player Closest To Reticle(Event Player, Team 1)) == True;
	}

	actions
	{
		Global.TempVar4 = Player Closest To Reticle(Event Player, Team 1);
		Start Facing(Event Player, Direction Towards(Position Of(Event Player), Position Of(Global.TempVar4)), 200, To World,
			Direction and Turn Rate);
		"Delay before responding to player"
		Wait(0.600, Ignore Condition);
		If(Is Communicating(Global.TempVar4, Hello));
			Communicate(Event Player, Hello);
		Else If(Is Communicating(Global.TempVar4, Thanks));
			If(Random Integer(0, 10) != 10);
				Communicate(Event Player, You are Welcome);
			Else;
				Communicate(Event Player, With You);
			End;
		Else If(Is Communicating(Global.TempVar4, No));
			If(Random Integer(0, 10) != 10);
				Communicate(Event Player, Yes);
			Else;
				Communicate(Event Player, Sorry);
			End;
		Else If(Is Communicating(Global.TempVar4, Yes) || Is Communicating(Global.TempVar4, Acknowledge));
			If(Random Integer(0, 10) < 7);
				Communicate(Event Player, Acknowledge);
			Else;
				Communicate(Event Player, No);
			End;
		Else If(Is Communicating(Global.TempVar4, Goodbye));
			If(Random Integer(0, 10) != 10);
				Communicate(Event Player, Goodbye);
			Else;
				Communicate(Event Player, No);
			End;
		Else If(Is Communicating(Global.TempVar4, Sorry));
			Global.GETempVar5 = Random Integer(0, 15);
			If(Global.GETempVar5 < 5);
				Communicate(Event Player, Acknowledge);
			Else If(Global.GETempVar5 >= 5 && Global.GETempVar5 < 10);
				Communicate(Event Player, No);
			Else;
				Communicate(Event Player, Sorry);
			End;
		Else If(Is Communicating Any Voice line(Global.TempVar4));
			Global.GETempVar5 = Random Integer(0, 15);
			"Delay response if player uses voice line"
			Wait(1.500, Ignore Condition);
			If(Global.GETempVar5 < 3);
				Communicate(Event Player, Press the Attack);
			Else If(Global.GETempVar5 >= 3 && Global.GETempVar5 < 6);
				Communicate(Event Player, Go);
			Else If(Global.GETempVar5 >= 6 && Global.GETempVar5 < 12);
				Communicate(Event Player, No);
			Else;
				Communicate(Event Player, Yes);
			End;
		Else If(Is Communicating(Global.TempVar4, You are Welcome));
			Communicate(Event Player, You are Welcome);
		End;
		Stop Facing(Event Player);
		"Cooldown before accepting next responses from players"
		Wait(0.800, Ignore Condition);
	}
}

rule("Set Bastion Upgrade Damage (BU)[SR]")
{
	event
	{
		Subroutine;
		SetGEBastionDamage;
	}

	actions
	{
		Set Damage Dealt(Global.TempVar4, Global.BastionDamages[1] + Global.BastionDamages[2]);
	}
}

rule("Select extra Bastion Upgrade (BU)[Extra][SR]")
{
	event
	{
		Subroutine;
		SelectBastionExtraUpgrade;
	}

	actions
	{
		Call Subroutine(BastionExtraUpgradeReset);
		"Camo"
		If(Global.BUChoices[1] == 1);
			Set Invisible(Global.TempVar4, All);
		"Bastion Jr."
		Else If(Global.BUChoices[1] == 2);
			Global.BUExtraScale = 0.300;
			Start Scaling Player(Global.TempVar4, Global.BUExtraScale, False);
		"Bastion Sr."
		Else If(Global.BUChoices[1] == 3);
			Global.BUExtraScale = Random Real(2, 2.500);
			Start Scaling Player(Global.TempVar4, Global.BUExtraScale, False);
			Disable Movement Collision With Environment(Global.TempVar4, False);
		"Damage Boost"
		Else If(Global.BUChoices[1] == 4);
			Global.BastionDamages[2] = 50;
		End;
		Call Subroutine(SetGEBastionDamage);
	}
}

rule("Reset extra Bastion Upgrade (BU)[Extra][SR]")
{
	event
	{
		Subroutine;
		BastionExtraUpgradeReset;
	}

	actions
	{
		Global.TempVar4 = Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Bastion));
		Set Invisible(Global.TempVar4, None);
		Stop Forcing Player Outlines(Global.TempVar4, All Players(Team 1));
		Stop Scaling Player(Global.TempVar4);
		Enable Movement Collision With Environment(Global.TempVar4);
		Global.BastionDamages[2] = 0;
		Global.TempVar4 = All Players(Team 1);
		For Global Variable(TempVar2, 0, Count Of(Global.TempVar4), 1);
			Destroy Effect(Global.TempVar4[Global.TempVar2].BUExtraEffectIDs);
			Global.TempVar4[Global.TempVar2].BUExtraEffectIDs = Null;
		End;
	}
}

rule("Bastion passives (GE)(BU)[Extra]")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Global.BUChoices[1] == 2 || Global.BUChoices[1] == 3) == True;
	}

	actions
	{
		Wait(20, Abort When False);
		Stop Scaling Player(Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Bastion)));
		Start Scaling Player(Global.TempVar4, Global.BUExtraScale, False);
		Loop If Condition Is True;
	}
}

rule("Bastion is shooting (Camo)(GE)(BU)[Extra]")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		"Clandestine Toggle"
		Global.BUChoices[1] == 1;
		Is Firing Primary(Event Player) == True;
	}

	actions
	{
		Wait(0.300, Abort When False);
		Set Invisible(Event Player, None);
		Start Forcing Player Outlines(Event Player, All Players(Team 1), True, Color(Red), Always);
		If(Event Player.BUExtraEffectIDs != Null);
			Destroy Effect(Event Player.BUExtraEffectIDs[0]);
			Event Player.BUExtraEffectIDs = Null;
	}
}

rule("Bastion is hiding (Camo)(GE)(BU)[Extra]")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		"Clandestine Toggle"
		Global.BUChoices[1] == 1;
		Is Firing Primary(Event Player) == False;
	}

	actions
	{
		Wait(1, Abort When False);
		Set Invisible(Event Player, Enemies);
		Stop Forcing Player Outlines(Event Player, All Players(Team 1));
		If(Event Player.BUExtraEffectIDs == Null);
			Create Effect(All Players(Team 1), Bad Aura Sound, Color(White), Event Player, 80, Visible To Position and Radius);
			Event Player.BUExtraEffectIDs[0] = Last Created Entity;
	}
}

rule("Player is looking at Bastion (Shining Armor)(GE)(BU)[Extra]")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Clandestine Toggle"
		Global.BUChoices[1] == 5;
		Event Player.BUExtraEffectIDs == Null;
		Is True For Any(Players in View Angle(Event Player, Team 2, 50), Is In Line of Sight(Position Of(Event Player), Position Of(
			Current Array Element), All Barriers Block LOS)) == True;
	}

	actions
	{
		Create Effect(Event Player, Sphere, Color(Yellow), Event Player, 50, Visible To Position and Radius);
		Event Player.BUExtraEffectIDs[0] = Last Created Entity;
		Create Effect(Event Player, Sphere, Color(White), Event Player, 5, Visible To Position and Radius);
		Event Player.BUExtraEffectIDs[1] = Last Created Entity;
	}
}

rule("Player is not looking at Bastion (Shining Armor)(GE)(BU)[Extra]")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Clandestine Toggle"
		Global.BUChoices[1] == 5;
		Event Player.BUExtraEffectIDs != Null;
		Is True For Any(Players in View Angle(Event Player, Team 2, 50), Is In Line of Sight(Position Of(Event Player), Position Of(
			Current Array Element), All Barriers Block LOS)) == False;
	}

	actions
	{
		Wait(5, Abort When False);
		Destroy Effect(Event Player.BUExtraEffectIDs);
		Event Player.BUExtraEffectIDs = Null;
		Loop If Condition Is True;
	}
}

rule("Assign new body (One-For-All)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.GEChoice == 44;
		Global.IsGETimerStart == True;
	}

	actions
	{
		Wait Until(Global.GEAffectedPlayer == Null, Random Real(10, 40));
		Abort If Condition Is False;
		Global.GETarget = Global.GEAffectedPlayer;
		Global.GEAffectedPlayer = Random Value In Array(Filtered Array(All Players(Team 1),
			Current Array Element != Global.GETarget && !Current Array Element.IsWinner));
		If(Global.GETarget != Null);
			Teleport(Global.GEAffectedPlayer, Position Of(Global.GETarget));
			Respawn(Global.GETarget);
			If(Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter));
				Teleport(Global.GETarget, Global.BlizzWorldSpawnLoc);
			Else If(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween));
				Teleport(Global.GETarget, Global.HollywoodSpawns[0]);
			Else If(Hero Of(Global.GETarget) == Hero(D.Va));
				Teleport(Global.GETarget, Position Of(Random Value In Array(Spawn Points(Team 1))));
			End;
			Play Effect(All Players(Team 1), Buff Impact Sound, Color(White), Global.GETarget, 80);
			Play Effect(All Players(Team 1), Good Pickup Effect, Color(Yellow), Global.GETarget, 8);
		End;
		Stop Camera(Global.GEAffectedPlayer);
		Call Subroutine(EnablePlayer);
		Play Effect(All Players(Team 1), Buff Impact Sound, Color(White), Global.GEAffectedPlayer, 80);
		Play Effect(All Players(Team 1), Good Pickup Effect, Color(Yellow), Global.GEAffectedPlayer, 8);
		Wait(0.500, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Assign minds to the body (One-For-All)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEChoice == 44;
		Global.IsGETimerStart == True;
		Event Player != Global.GEAffectedPlayer;
		Event Player.IsWinner == False;
	}

	actions
	{
		Event Player.GECameraStats = Array(5, 3);
		Start Camera(Event Player, Ray Cast Hit Position(Eye Position(Global.GEAffectedPlayer), (Throttle Of(Event Player) == Vector(0, 0,
			0) ? Facing Direction Of(Global.GEAffectedPlayer) * -1 : Throttle Of(Event Player))
			* Event Player.GECameraStats[0] + Eye Position(Global.GEAffectedPlayer) + Vector(0, Event Player.GECameraStats[1], 0),
			All Players(All Teams), Global.GEAffectedPlayer, False), Eye Position(Global.GEAffectedPlayer), 15);
		Call Subroutine(DisablePlayer);
	}
}

rule("Disable Player (One-For-All)(GE)[SR]")
{
	event
	{
		Subroutine;
		DisablePlayer;
	}

	actions
	{
		Disallow Button(Event Player, Button(Primary Fire));
		Disallow Button(Event Player, Button(Secondary Fire));
		Disallow Button(Event Player, Button(Ability 1));
		Disallow Button(Event Player, Button(Ability 2));
		Disallow Button(Event Player, Button(Interact));
		Disallow Button(Event Player, Button(Jump));
		Disallow Button(Event Player, Button(Melee));
		Disallow Button(Event Player, Button(Reload));
		Disallow Button(Event Player, Button(Crouch));
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
	}
}

rule("Enable Player (One-For-All)(GE)[SR]")
{
	event
	{
		Subroutine;
		EnablePlayer;
	}

	actions
	{
		Allow Button(Global.GEAffectedPlayer, Button(Primary Fire));
		Allow Button(Global.GEAffectedPlayer, Button(Secondary Fire));
		Allow Button(Global.GEAffectedPlayer, Button(Ability 1));
		Allow Button(Global.GEAffectedPlayer, Button(Ability 2));
		Allow Button(Global.GEAffectedPlayer, Button(Interact));
		Allow Button(Global.GEAffectedPlayer, Button(Jump));
		Allow Button(Global.GEAffectedPlayer, Button(Melee));
		Allow Button(Global.GEAffectedPlayer, Button(Reload));
		Allow Button(Global.GEAffectedPlayer, Button(Crouch));
		Stop Forcing Throttle(Global.GEAffectedPlayer);
	}
}

rule("Body reaches goal (One-For-All)(GE)[SR]")
{
	event
	{
		Subroutine;
		OneForAllGoal;
	}

	actions
	{
		If(Global.GEChoice == 44 && Global.GEAffectedPlayer == Event Player);
			Global.TempVar = Filtered Array(All Players(Team 1),
				Global.GEAffectedPlayer != Current Array Element && !Current Array Element.IsWinner);
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				If((Global.HeroListTypeWS != 2 && Global.TempVar[Global.TempVar2].CurrentHero == Count Of(Global.HeroList) - 1) || (
					Global.HeroListTypeWS == 2 && Global.TempVar[Global.TempVar2].CurrentHero == Count Of(
					Global.TempVar[Global.TempVar2].IndieHeroList) - 1));
					Teleport(Global.TempVar[Global.TempVar2], Global.EndPosition + Vector(0, 5, 0));
				Else;
					Global.TempVar[Global.TempVar2].CurrentHero += 1;
					Global.TempVar[Global.TempVar2].TargetHero = Global.TempVar[Global.TempVar2].CurrentHero;
	}
}

rule("Init marching motion (Forward March)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEChoice == 45;
		Global.IsGETimerStart == True;
		Event Player.GEID == Null;
	}

	actions
	{
		Set Move Speed(Event Player, 300);
		Create Effect(All Players(Team 1), Cloud, Color(White), Event Player, 1, Visible To Position and Radius);
		Event Player.GEID = Last Created Entity;
		Start Throttle In Direction(Event Player, Facing Direction Of(Event Player), 1, To World, Replace existing throttle,
			Direction and Magnitude);
	}
}

rule("Player emotes (Forward March)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEChoice == 45;
		Global.IsGETimerStart == True;
		Is Communicating Any Emote(Event Player) == True;
	}

	actions
	{
		Kill(Event Player, Closest Player To(Event Player, Team 2));
	}
}

rule("Set sphere location (Kill Sphere)(GE)[SR]")
{
	event
	{
		Subroutine;
		SetKillSphereLoc;
	}

	actions
	{
		Global.TempVar = Random Value In Array(All Players(Team 2));
		Global.TempVar2 = Random Integer(0, 25);
		Global.GESpawnDistance = Random Real(0, 60);
		If(Global.TempVar2 == 0);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + Forward * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 1);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Right) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 2);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + Right * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 3);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Right) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 4);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + Backward * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 5);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Left) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 6);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + Left * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 7);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Left) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 8);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 9);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 10);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Right + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 11);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Right + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 12);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 13);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 14);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Left + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 15);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Left + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 16);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Right + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 17);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Right + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 18);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Right + Down)
				* Global.GESpawnDistance);
		Else If(Global.TempVar2 == 19);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Right + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 20);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Left + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 21);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Left + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 22);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Left + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 23);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Left + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 24);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + Up * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 25);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + Down * Global.GESpawnDistance);
		End;
		Global.GEBallPosition += Vector(0, Random Real(0, 10), 0);
	}
}

rule("Player touches sphere (Kill Sphere)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.GEChoice == 47;
		Global.IsGETimerStart == True;
		Is True For Any(Players Within Radius(Global.GEBallPosition, Global.GERadius, Team 1, Off), !Is In Spawn Room(
			Current Array Element) && !Current Array Element.IsWinner && (Current Map == Map(Hollywood) || Current Map == Map(
			Hollywood Halloween)) && Distance Between(Position Of(Current Array Element), Global.HollywoodSpawns[0]) > 26 && (
			Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter)) && Distance Between(Position Of(
			Current Array Element), Global.BlizzWorldSpawnLoc) > 30) == True;
	}

	actions
	{
		Kill(Filtered Array(Players Within Radius(Global.GEBallPosition, Global.GERadius, All Teams, Off), !Is In Spawn Room(
			Current Array Element) && !Current Array Element.IsWinner && (Current Map == Map(Hollywood) || Current Map == Map(
			Hollywood Halloween)) && Distance Between(Position Of(Current Array Element), Global.HollywoodSpawns[0]) > 26 && (
			Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter)) && Distance Between(Position Of(
			Current Array Element), Global.BlizzWorldSpawnLoc) > 30), Closest Player To(Global.GEBallPosition, Team 2));
	}
}

rule("Set boop direction (Boop)(GE)[SR]")
{
	event
	{
		Subroutine;
		SetBoopDirection;
	}

	actions
	{
		Global.TempVar2 = Random Integer(0, 16);
		If(Global.TempVar2 == 0);
			Global.GEBallPosition = Forward;
		Else If(Global.TempVar2 == 1);
			Global.GEBallPosition = Forward + Right;
		Else If(Global.TempVar2 == 2);
			Global.GEBallPosition = Right;
		Else If(Global.TempVar2 == 3);
			Global.GEBallPosition = Backward + Right;
		Else If(Global.TempVar2 == 4);
			Global.GEBallPosition = Backward;
		Else If(Global.TempVar2 == 5);
			Global.GEBallPosition = Backward + Left;
		Else If(Global.TempVar2 == 6);
			Global.GEBallPosition = Left;
		Else If(Global.TempVar2 == 7);
			Global.GEBallPosition = Forward + Left;
		Else If(Global.TempVar2 == 8);
			Global.GEBallPosition = Forward + Up;
		Else If(Global.TempVar2 == 9);
			Global.GEBallPosition = Right + Up;
		Else If(Global.TempVar2 == 10);
			Global.GEBallPosition = Backward + Up;
		Else If(Global.TempVar2 == 11);
			Global.GEBallPosition = Left + Up;
		Else If(Global.TempVar2 == 12);
			Global.GEBallPosition = Forward + Right + Up;
		Else If(Global.TempVar2 == 13);
			Global.GEBallPosition = Backward + Right + Up;
		Else If(Global.TempVar2 == 14);
			Global.GEBallPosition = Forward + Left + Up;
		Else If(Global.TempVar2 == 15);
			Global.GEBallPosition = Backward + Left + Up;
		Else If(Global.TempVar2 == 16);
			Global.GEBallPosition = Up;
		End;
	}
}

rule("Set cloud location (Toxic Clouds)(GE)[SR]")
{
	event
	{
		Subroutine;
		SetCloudLoc;
	}

	actions
	{
		Event Player.GETempVar = Random Integer(0, 25);
		Event Player.GETempVar2 = Random Real(15, 70);
		If(Event Player.GETempVar == 0);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + Forward * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 1);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Forward + Right) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 2);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + Right * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 3);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Backward + Right) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 4);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + Backward * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 5);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Backward + Left) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 6);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + Left * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 7);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Forward + Left) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 8);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Forward + Down) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 9);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Forward + Up) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 10);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Right + Up) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 11);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Right + Down) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 12);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Backward + Down) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 13);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Backward + Up) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 14);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Left + Up) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 15);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Left + Down) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 16);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Forward + Right + Up) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 17);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Forward + Right + Down) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 18);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Backward + Right + Down)
				* Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 19);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Backward + Right + Up) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 20);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Forward + Left + Up) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 21);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Forward + Left + Down) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 22);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Backward + Left + Down) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 23);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Backward + Left + Up) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 24);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + Up * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 25);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + Down * Event Player.GETempVar2);
		End;
	}
}

rule("Init clouds (Toxic Clouds)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Global.GEChoice == 49;
		Global.IsGETimerStart == True;
		Event Player.GEID == Null;
	}

	actions
	{
		Call Subroutine(SetCloudLoc);
		Create Effect(All Players(Team 1), Cloud, Color(Green), Event Player.GETempVar + Vector(0, 2, 0), Global.GERadius, Visible To);
		Event Player.GEID = Last Created Entity;
	}
}

rule("Player touches cloud (Toxic Clouds)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Global.GEChoice == 49;
		Global.IsGETimerStart == True;
		Event Player.GEID != Null;
		Is True For Any(Players Within Radius(Event Player.GETempVar, Global.GERadius - 0.500, Team 1, Off),
			!Current Array Element.IsWinner && !Is In Spawn Room(Current Array Element)) == True;
	}

	actions
	{
		Event Player.GETempVar2 = Players Within Radius(Event Player.GETempVar, Global.GERadius - 0.500, Team 1, Off);
		Start Damage Over Time(Event Player.GETempVar2, Event Player, 5, Random Real(15, 30));
		Wait(5, Abort When False);
		Loop If Condition Is True;
	}
}