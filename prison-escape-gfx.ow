settings
{
	main
	{
		Description: "Prisoners are placed on death row. Can you escape your fate? Escape prison with ALL heroes to finish the game.\n\n*This is an alternative version of BASTION ESCAPE 2."
		Mode Name: "PRISON ESCAPE"
	}

	lobby
	{
		Allow Players Who Are In Queue: Yes
		Map Rotation: After A Game
		Match Voice Chat: Enabled
		Max Spectators: 12
		Max Team 1 Players: 9
		Max Team 2 Players: 0
		Return To Lobby: Never
		Swap Teams After Match: No
	}

	modes
	{
		Skirmish
		{
			disabled maps
			{
				Workshop Chamber
				Workshop Expanse
				Workshop Expanse Night
				Workshop Green Screen
				Workshop Island
				Workshop Island Night
			}
		}

		disabled Team Deathmatch
		{
			Score To Win: 1
			Self Initiated Respawn: Off
		}

		General
		{
			Allow Hero Switching: Off
			Enemy Health Bars: Off
			Game Mode Start: Immediately
			Health Pack Respawn Time Scalar: 10%
			Hero Limit: Off
			Kill Cam: Off
			Kill Feed: Off
			Respawn As Random Hero: On
			Respawn Time Scalar: 0%
			Spawn Health Packs: Enabled
		}
	}

	heroes
	{
		Team 1
		{
			Bastion
			{
				Configuration: Tank Weapon Knockback Scalar: 300%
				Health: 135%
				Infinite Ultimate Duration: On
				Self-Repair Maximum Time: 200%
				Self-Repair Recharge Rate: 150%
			}
		}

		Team 2
		{
			Bastion
			{
				Configuration: Tank Weapon Knockback Scalar: 300%
				Health: 135%
				Infinite Ultimate Duration: On
				No Ammunition Requirement: On
				Quick Melee: Off
				Self-Repair Maximum Time: 200%
				Self-Repair Recharge Rate: 150%
				Ultimate Ability Configuration: Tank: Off
			}
		}

		General
		{
			Ability Cooldown Time: 30%
			No Ammunition Requirement: On
			Ultimate Generation: 10%
			Ultimate Generation - Combat: 0%
			Ultimate Generation - Passive: 0%

			Ana
			{
				Sleep Dart Cooldown Time: 500%
			}

			Baptiste
			{
				Healing Received: 10%
				Health: 10%
				Immortality Field Cooldown Time: 15%
				No Ammunition Requirement: On
				Projectile Gravity: 0%
				Projectile Speed: 500%
				Regenerative Burst Cooldown Time: 15%
			}

			Hanzo
			{
				Lunge Distance Scalar: 125%
				Storm Arrows Quantity: 12
			}

			Mercy
			{
				Secondary Fire: Off
				Weapons Enabled: Caduceus Staff Only
			}

			Orisa
			{
				Ultimate Ability Supercharger: Off
			}

			Roadhog
			{
				Chain Hook: Off
			}

			Sombra
			{
				Translocator Cooldown Time: 0%
			}

			Symmetra
			{
				Sentry Turret: Off
			}

			Torbjörn
			{
				Deploy Turret: Off
				Overload Cooldown Time: 250%
				Overload Duration Scalar: 500%
				Weapons Enabled: Forge Hammer Only
			}

			Widowmaker
			{
				Infinite Ultimate Duration: On
			}

			Winston
			{
				Infinite Ultimate Duration: On
				Primal Rage Melee Knockback Scalar: 200%
			}

			Zarya
			{
				Jump Vertical Speed: 140%
				Particle Cannon Secondary Knockback Scalar: 200%
			}

			Zenyatta
			{
				Healing Dealt: 200%
				Health: 175%
				Orb of Discord: Off
			}
		}
	}

	extensions
	{
		Explosion Sounds
		Play More Effects
		Spawn More Dummy Bots
	}
}

variables
{
	global:
		0: LotteryStats
		1: EndPosition
		2: BastionBotCount
		3: IsGEEnabledWS
		4: GEChoice
		5: MaxSafetyServerLoadWS
		6: IsDebugMode
		7: BastionDamages
		8: GEText
		9: JumpPadLocList
		10: JumpPadPowerList
		11: HeroList
		12: EscapeBoardStats
		13: HasSeventhBastionWS
		15: AllBastionPositions
		16: TempVar
		17: IsGEIntervalRandomWS
		18: GEIntervalWS
		20: IsBastionLastHeroWS
		21: BacktrackMinMaxListWS
		22: HeroListTypeWS
		23: BacktrackDeathsWS
		25: HeroDataSaveIndexWS
		26: TempVar2
		27: GameSettingsHUDWT
		28: SavedIndex
		29: SavedHero
		30: SavedDeaths
		31: SavedWinners
		32: SavedBacktrackDeaths
		33: BlizzWorldSpawnLoc
		34: HasAllWinnersToCycleWS
		35: HollywoodSpawns
		36: RBPDefaultMaps
		37: isTeleporterEnabled
		38: JumpPadRadius
		39: TempVar3
		40: TempVar4
		41: GEMinPlayerReq
		42: GEName
		43: GEHelpText
		44: GameSettingTextVec
		45: CanStartGE
		46: IsGETimerStart
		47: GEEndTime
		48: GEWaitTime
		49: GERadius
		50: GECarriers
		51: GEViewAngle
		52: GERequiredNum
		53: WinnerHeroesList
		54: GEBallPosition
		55: GEBallID
		56: GEMeleeDistance
		57: GEMultiChoice
		58: GESpawnDistance
		59: GECurReqNum
		60: GETarget
		61: GEBallSpeed
		62: WinnerHeroesRingStats
		63: WinnerResetRingStats
		64: GECameraChoice
		65: ShowEscapeStatusWS
		66: BUExtraScale
		67: BastionPosLocType
		68: BastionPosDistance
		69: BastionPosIntervalMinMaxWS
		70: BastionPosTypeWS
		71: GEAffectedPlayer
		72: RBPIndex
		73: BacktrackSteps
		74: GEMaxNum
		75: GEMaxBacktrackSteps
		76: CurWinnerCount
		77: GameOptTextVec
		78: GameOptTextSpacing
		80: GEPatrolChoice
		81: GETempVar5
		82: GEToggles
		83: BUChoices

	player:
		0: IsWinner
		1: GECameraStats
		2: temp
		3: CurrentHero
		4: BUPlayersNearby
		5: Deaths
		6: PatrolMoveStats
		8: BacktrackDeaths
		9: randBacktrackNum
		10: hasPlayedSaveMessage
		11: SideEffectStats
		13: GEHelpTextIDs
		14: GETimerID
		15: GEID
		16: GEHUDID
		17: GETempVar
		18: GECount
		19: GEIsAffectedPlayer
		20: TargetHero
		21: loopNum
		23: IsGETBagStand
		24: IsGETBagCrouched
		25: TrapZoneChoice
		26: Enemy
		27: AimPosition
		28: TurnSpeed
		29: TempAimPosition
		30: EnemyUnSeen
		31: InvisibleText
		32: Invis
		33: GEIsHeroCarrier
		34: GEHeroRider
		35: GEHeroCarrier
		36: GEGuardianAngel
		37: GEHumanProtect
		38: GEPartner
		39: TrapZoneStats
		40: GEIsTagger
		41: GEIsTagged
		42: GELagType
		43: GELagDistance
		44: GELagPos
		45: WinnerHeroCursor
		46: IndieHeroList
		47: temp2
		48: EnemyTrapEntity
		49: TrapIndex
		50: FirstLazerPos
		51: WinnerDeathID
		52: BUIndex
		53: BUBulletEffectIDs
		54: BUExtraEffectIDs
		55: GETempVar2
		56: LotteryChoice
		57: GEIndex
		58: BlindChanceNum
		59: PlayersInTrapZone
		60: SecondLazerPos
		61: ThirdLazerPos
		62: TrapIDs
		64: IsInSpawnRoom
		65: GETarget
		66: BUTeleStats
}

subroutines
{
	0: SavePlayerData
	1: DestroyDVAMechHUD
	2: PlaySaveUnlockedMSG
	3: SpawnAtAltLoc
	4: InitCustomHeroOrder
	5: SpawnFriendlySoldier
	6: IncrementGameSettingsPos
	7: SelectGlobalEffect
	8: StartGETimer
	9: EndGlobalEffect
	10: GESetPongBallSpeed
	11: GEStartTypeA
	12: SpawnPatrolLoc
	13: GESpecificEndCleanUp
	14: GEStartTypeB
	15: GEStartTypeC
	16: GEStartTypeD
	17: GEStartTypeE
	18: GEStartTypeF
	19: GEStartTypeG
	20: GEStartTypeH
	21: GEResetHeroCarrierStats
	22: GEResetHeroRiderStats
	23: GEPromoteWingman
	24: SetCineCameraStat
	25: GEStartTypeI
	26: GEStartTypeJ
	27: AddBacktrackDeath
	28: SelectBastionBulletUpgrade
	29: SelectTankShellType
	30: SetNewBastionPosition
	31: ApplyWinnerStats
	32: SetupGameSettingsText
	33: CreateJumpPads
	34: CreateTeleporters
	35: PromoteHeroRider
	36: SpawnDistantPlayerPatrolLoc
	37: CompleteGlobalEffect
	38: SelectWindDir
	39: SetWindSpeedRate
	40: BeforeNewBastionBulletUpgrade
	41: SelectAPatrol
	42: CleanUpPatrol
	43: SetPatrolDuration
	44: NewBastionPosOnEscape
	45: RBPCheckAndSet
	46: SetCameraView
	47: SelectBastionExtraUpgrade
	48: BastionExtraUpgradeReset
	49: SpawnAllAtAltLoc
	50: DisablePlayer
	51: EnablePlayer
	52: OneForAllGoal
	53: NextHero
	54: SetGEBastionDamage
	55: SetBoopDirection
	56: SetBetZoneLoc
	57: ApplyTankForm
	58: SetTrapZoneLoc
	59: SpawnDistantPatrolLoc
	60: SelectLocFromAllDirs
	61: ResetPlayerSideEffect
	62: ResetAllSideEffects
	63: SelectBastionBuffUpgrade
	64: CleanUpAllTrapsAndStats
	65: SelectSpringDir
	66: SetLazerPositions
}

rule("Workshop Settings")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.BacktrackDeathsWS = Workshop Setting Integer(Custom String("Backtracking"), Custom String(
			"# of deaths before backtracking (0=disable)"), 8, 0, 999, 0);
		Global.HeroDataSaveIndexWS = Workshop Setting Integer(Custom String("Game"), Custom String(
			"Unlock Save feature At Hero Number (0=disable)"), 7, 0, 32, 0) - 1;
		Global.BacktrackMinMaxListWS = Empty Array;
		Global.BacktrackMinMaxListWS[0] = Workshop Setting Integer(Custom String("Backtracking"), Custom String(
			"Minimum random number to backtrack by"), 1, 1, 31, 0);
		Global.BacktrackMinMaxListWS[1] = Workshop Setting Integer(Custom String("Backtracking"), Custom String(
			"Maximum random number to backtrack by"), 3, 1, 31, 1);
		Global.BacktrackMinMaxListWS = Array(Min(Global.BacktrackMinMaxListWS[0], Global.BacktrackMinMaxListWS[1]), Max(
			Global.BacktrackMinMaxListWS[0], Global.BacktrackMinMaxListWS[1]));
		Global.IsGEEnabledWS = Workshop Setting Toggle(Custom String("Global Effect Mode"), Custom String("Enabled"), True, 0);
		Global.GEIntervalWS = Workshop Setting Integer(Custom String("Global Effect Mode"), Custom String("Interval (in seconds)"), 60, 20,
			999, 1);
		Global.IsGEIntervalRandomWS = Workshop Setting Toggle(Custom String("Global Effect Mode"), Custom String(
			"Randomize the interval.  Between (0.5 * [INTERVAL]) & (1.5 * [INTERVAL])"), True, 2);
		Global.IsBastionLastHeroWS = Workshop Setting Toggle(Custom String("Hero Ordering"), Custom String(
			"Set Bastion as the last hero [random/independent only]"), False, 0);
		Global.HeroListTypeWS = Workshop Setting Combo(Custom String("Hero Ordering"), Custom String("Hero order to use"), 2, Array(
			Custom String("Normal"), Custom String("Random"), Custom String("Independent"), Custom String("Custom")), 0);
		Global.BastionPosIntervalMinMaxWS[0] = Workshop Setting Integer(Custom String("Bastion Position"), Custom String(
			"Minimum change interval (random only)"), 60, 30, 1000, 1);
		Global.BastionPosIntervalMinMaxWS[1] = Workshop Setting Integer(Custom String("Bastion Position"), Custom String(
			"Maximum change interval (random only)"), 135, 30, 1000, 2);
		Global.BastionPosIntervalMinMaxWS = Array(Min(Global.BastionPosIntervalMinMaxWS[0], Global.BastionPosIntervalMinMaxWS[1]), Max(
			Global.BastionPosIntervalMinMaxWS[0], Global.BastionPosIntervalMinMaxWS[1]));
		Global.BastionPosTypeWS = Workshop Setting Combo(Custom String("Bastion Position"), Custom String("Position Type"), 1, Array(
			Custom String("Original"), Custom String("Random"), Custom String("Random Once"), Custom String("On Escape")), 0);
		Global.HasAllWinnersToCycleWS = Workshop Setting Toggle(Custom String("Game"), Custom String(
			"To cycle next map, the amount of completions = total players in the lobby"), True, 0);
		Global.ShowEscapeStatusWS = Workshop Setting Toggle(Custom String("Game"), Custom String("Show Escape Status Board"), False, 1);
		Global.HasSeventhBastionWS = Workshop Setting Toggle(Custom String("Experimental"), Custom String("Add 7th Bastion"), True, 0);
		"Maximum server load to allow actions"
		Global.MaxSafetyServerLoadWS = Workshop Setting Integer(Custom String("Game"), Custom String(
			"Max Server CPU usage until safety mode is active (%)"), 90, 50, 100, 1);
	}
}

rule("Init custom hero list")
{
	event
	{
		Subroutine;
		InitCustomHeroOrder;
	}

	actions
	{
		Global.HeroList = Array(Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 1"), Sombra, 0),
			Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 2"), Tracer, 0), Workshop Setting Hero(
			Custom String("Custom Order List"), Custom String("Hero 3"), Reaper, 0), Workshop Setting Hero(Custom String(
			"Custom Order List"), Custom String("Hero 4"), Symmetra, 0), Workshop Setting Hero(Custom String("Custom Order List"),
			Custom String("Hero 5"), Moira, 0), Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 6"),
			Doomfist, 0), Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 7"), Genji, 0),
			Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 8"), D.Va, 0), Workshop Setting Hero(
			Custom String("Custom Order List"), Custom String("Hero 9"), Echo, 0), Workshop Setting Hero(Custom String(
			"Custom Order List"), Custom String("Hero 10"), Brigitte, 1), Workshop Setting Hero(Custom String("Custom Order List"),
			Custom String("Hero 11"), Widowmaker, 1), Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 12"),
			Mei, 1), Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 13"), Baptiste, 1),
			Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 14"), Soldier: 76, 1), Workshop Setting Hero(
			Custom String("Custom Order List"), Custom String("Hero 15"), Wrecking Ball, 1), Workshop Setting Hero(Custom String(
			"Custom Order List"), Custom String("Hero 16"), Hanzo, 1), Workshop Setting Hero(Custom String("Custom Order List"),
			Custom String("Hero 17"), Ashe, 1), Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 18"),
			Cassidy, 1), Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 19"), Lúcio, 1),
			Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 20"), Winston, 2), Workshop Setting Hero(
			Custom String("Custom Order List"), Custom String("Hero 21"), Junkrat, 2), Workshop Setting Hero(Custom String(
			"Custom Order List"), Custom String("Hero 22"), Pharah, 2), Workshop Setting Hero(Custom String("Custom Order List"),
			Custom String("Hero 23"), Mercy, 2), Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 24"),
			Reinhardt, 2), Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 25"), Zarya, 2),
			Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 26"), Orisa, 2), Workshop Setting Hero(
			Custom String("Custom Order List"), Custom String("Hero 27"), Sigma, 2), Workshop Setting Hero(Custom String(
			"Custom Order List"), Custom String("Hero 28"), Torbjörn, 2), Workshop Setting Hero(Custom String("Custom Order List"),
			Custom String("Hero 29"), Ana, 2), Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 30"),
			Zenyatta, 3), Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 31"), Roadhog, 3),
			Workshop Setting Hero(Custom String("Custom Order List"), Custom String("Hero 32"), Bastion, 3));
	}
}

rule("init winner hero list")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.WinnerHeroesList == Null;
	}

	actions
	{
		Global.WinnerHeroesList = Array(Hero(Ana), Hero(Baptiste), Hero(Brigitte), Hero(Cassidy), Hero(D.Va), Hero(Genji), Hero(Hanzo),
			Hero(Lúcio), Hero(Mei), Hero(Mercy), Hero(Moira), Hero(Orisa), Hero(Reinhardt), Hero(Roadhog), Hero(Sigma), Hero(Soldier: 76),
			Hero(Sombra), Hero(Symmetra), Hero(Winston), Hero(Zarya), Hero(Zenyatta));
	}
}

rule("init hero list sequence")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"HeroListTypeWS: 0 = Normal, 1 = Random Order, 2 = Independent Order, 3 = Custom Order"
		If(Global.HeroListTypeWS == 3);
			Call Subroutine(InitCustomHeroOrder);
		Else;
			Global.HeroList = Array(Hero(Sombra), Hero(Tracer), Hero(Reaper), Hero(Symmetra), Hero(Moira), Hero(Doomfist), Hero(Genji), Hero(
				D.Va), Hero(Echo), Hero(Brigitte), Hero(Widowmaker), Hero(Mei), Hero(Baptiste), Hero(Soldier: 76), Hero(Wrecking Ball), Hero(
				Hanzo), Hero(Ashe), Hero(Cassidy), Hero(Lúcio), Hero(Winston), Hero(Junkrat), Hero(Pharah), Hero(Mercy), Hero(Reinhardt), Hero(
				Zarya), Hero(Orisa), Hero(Sigma), Hero(Torbjörn), Hero(Ana), Hero(Zenyatta), Hero(Roadhog), Hero(Bastion));
			If(Global.HeroListTypeWS == 1);
				Global.HeroList = Randomized Array(Global.HeroList);
				If(Global.IsBastionLastHeroWS == True);
					If(Last Of(Global.HeroList) != Hero(Bastion));
						Global.TempVar = Last Of(Global.HeroList);
						Global.HeroList[Index Of Array Value(Global.HeroList, Hero(Bastion))] = Global.TempVar;
						Global.HeroList[Count Of(Global.HeroList) - 1] = Hero(Bastion);
	}
}

rule("Global Stats & inits")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Disable Inspector Recording;
		Disable Built-In Game Mode Completion;
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("WORKSHOP.CODES/PRISON-ESCAPE | SERVER CPU: {0}%",
			Round To Integer(Server Load / 255 * 100, To Nearest)), Left, -1000, Color(White), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Set Slow Motion(90);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("Server hosted \"{1}\" for {0} seconds!\r\n \r\n ",
			Round To Integer(Total Time Elapsed, To Nearest), Current Map), Left, -1, Color(White), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Custom String(" \nGo To Spawn:"), Custom String("Hold [{0}] + [{1}] + [{2}]",
			Input Binding String(Button(Reload)), Input Binding String(Button(Jump)), Input Binding String(Button(Interact))), Left, 14,
			Color(White), Color(Aqua), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("PRISON ESCAPE"), Top, 0, Color(White), Color(White), Color(
			White), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Custom String("Code: N0B1R"), Null, Top, 1, Color(White), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Global.SavedWinners = Empty Array;
		Global.SavedIndex = Empty Array;
		Global.SavedHero = Empty Array;
		Global.SavedBacktrackDeaths = Empty Array;
		Global.JumpPadRadius = 2.500;
		Global.BacktrackSteps = 1;
		"[0] Location,[1] Radius, [2] RingID, [3] Text Height"
		Global.WinnerHeroesRingStats = Array(Null, 1.750, Null, Vector(0, 1, 0));
		Global.WinnerResetRingStats = Array(Null, 1.750, Null, Vector(0, 1, 0));
		"Maps with Players spawns using the game's default locations "
		Global.RBPDefaultMaps = Array(Map(Busan), Map(Eichenwalde), Map(Eichenwalde Halloween), Map(Hanamura), Map(Hanamura Winter), Map(
			Havana), Map(Horizon Lunar Colony), Map(King's Row), Map(King's Row Winter), Map(Numbani), Map(Oasis), Map(Paris), Map(Rialto),
			Map(Route 66), Map(Temple of Anubis), Map(Volskaya Industries));
		"0 = I Need Healing, 1 = Trap Zones, 2 = Drug Packs"
		Global.GEToggles = Array(False, False, False);
		"0 = Bullets; 1 = Extra, 2 = Tank Shell, 3 = Buffs"
		Global.BUChoices = Array(0, 0, 0, 0);
		"0 = Initial Damage; 1 = New Base Damage; 2 = Extra Damage; "
		Global.BastionDamages = Array(150, 150, 0);
		If(Global.ShowEscapeStatusWS);
			Create HUD Text(All Players(All Teams), Null, Null, Custom String(" \n \nEscape Status:"), Left, 10, Color(White), Color(White),
				Color(Aqua), Visible To and String, Default Visibility);
			Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0}", !Has Spawned(Global.EscapeBoardStats[1]) ? Custom String(
				" ") : Custom String("1. {0} {1} - {2}", Hero Icon String(Hero Of(Global.EscapeBoardStats[1])), Global.EscapeBoardStats[1],
				Global.EscapeBoardStats[1].TargetHero + 1)), Left, 11, Color(White), Color(White), Color(Green), Visible To and String,
				Default Visibility);
			Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0}", !Has Spawned(Global.EscapeBoardStats[2]) ? Custom String(
				" ") : Custom String("2. {0} {1} - {2}", Hero Icon String(Hero Of(Global.EscapeBoardStats[2])), Global.EscapeBoardStats[2],
				Global.EscapeBoardStats[2].TargetHero + 1)), Left, 12, Color(White), Color(White), Color(Yellow), Visible To and String,
				Default Visibility);
			Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0}", !Has Spawned(Global.EscapeBoardStats[3]) ? Custom String(
				" ") : Custom String("3. {0} {1} - {2}", Hero Icon String(Hero Of(Global.EscapeBoardStats[3])), Global.EscapeBoardStats[3],
				Global.EscapeBoardStats[3].TargetHero + 1)), Left, 13, Color(White), Color(White), Color(Orange), Visible To and String,
				Default Visibility);
		End;
	}
}

rule("Init independent hero list")
{
	event
	{
		Player Joined Match;
		Team 1;
		All;
	}

	conditions
	{
		Global.HeroListTypeWS == 2;
		Event Player.IndieHeroList == Null;
	}

	actions
	{
		Event Player.IndieHeroList = Randomized Array(Global.HeroList);
		If(Global.IsBastionLastHeroWS == True);
			If(Last Of(Event Player.IndieHeroList) != Hero(Bastion));
				Event Player.temp2 = Last Of(Event Player.IndieHeroList);
				Event Player.IndieHeroList[Index Of Array Value(Event Player.IndieHeroList, Hero(Bastion))] = Event Player.temp2;
				Event Player.IndieHeroList[Count Of(Event Player.IndieHeroList) - 1] = Hero(Bastion);
	}
}

disabled rule("map setting (global arr p, global b, global d, global c) - [template]")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Insert map name here"
		Current Map == Null;
	}

	actions
	{
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		Global.AllBastionPositions = Array(Null, Null, Null, Null, Null, Null);
		"Goal position"
		Global.EndPosition = Left - Left;
		Start Forcing Spawn Room(Team 1, 2);
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(0, 0, 0);
		Global.WinnerResetRingStats[0] = Vector(0, 0, 0);
		"The text above the endgame rings for winners"
		Global.WinnerHeroesRingStats[3] = Vector(0, 0, 0);
		Global.WinnerResetRingStats[3] = Vector(0, 0, 0);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(0, 0, 0);
	}
}

disabled rule("Teleporter position init (global T) [template]")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.T == Empty Array;
		Current Map == Null;
	}

	actions
	{
		"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
		Global.T = Array(Vector(0, 0, 0), Vector(0, 0, 0));
	}
}

disabled rule("Jump pad position init (global J)(global K) [template]")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.JumpPadLocList == Empty Array;
		Current Map == Null;
	}

	actions
	{
		"Location of the jump pad"
		Modify Global Variable(JumpPadLocList, Append To Array, Left - Left);
		"How powerful the jump pad should be?"
		Modify Global Variable(JumpPadPowerList, Append To Array, Left - Left);
	}
}

rule("Cycle to next map (Map Cycling)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.HasAllWinnersToCycleWS == True;
		Global.CurWinnerCount >= Count Of(All Players(Team 1));
	}

	actions
	{
		Big Message(All Players(Team 1), Custom String("     Winner Limit Reached!\n\nMap will cycle in 60 seconds!"));
		Wait(3, Abort When False);
		Wait(45, Abort When False);
		Big Message(All Players(Team 1), Custom String("Map will cycle in 15 seconds!"));
		Wait(2, Abort When False);
		Wait(12, Abort When False);
		Big Message(All Players(Team 1), Custom String("Cycling Map!"));
		Wait(3, Abort When False);
		Restart Match;
	}
}

rule("map setting (global arr p, global b, global d, global c) - oasis(all)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Insert map name here"
		Current Map == Map(Oasis);
	}

	actions
	{
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		Start Forcing Spawn Room(Team 1, 2);
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		"University"
		If(Count Of(Players Within Radius(Vector(-193.743, 21.300, 91.204), 40, Team 1, Off)) != 0);
			"The text above the endgame rings for winners"
			Global.WinnerHeroesRingStats[3] = Vector(0, 0.750, 0);
			Global.AllBastionPositions = Array(Vector(-168.599, 22.258, 68.245), Vector(-180.717, 16.300, 25.092), Vector(-183.567, 16.905,
				9.355), Vector(-200.438, 20.300, -4.854), Vector(-185.219, 16.296, -25.005), Vector(-175.947, 20.261, -48.694));
			"University goal position"
			Global.EndPosition = Vector(-188.063, 19.298, -63.705) - Vector(0, 2, 0);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(-178.052, 20.350, 81.100);
			Global.WinnerResetRingStats[0] = Vector(-197.983, 20.350, 81.201);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(-188.171, 20.300, 81.549);
		"Garden"
		Else If(Count Of(Players Within Radius(Vector(203.074, 8.038, -185.630), 40, Team 1, Off)) != 0);
			"The text above the endgame rings for winners"
			Global.WinnerHeroesRingStats[3] = Vector(0, 1, 0);
			Global.AllBastionPositions = Array(Vector(144.649, 4.488, -184.348), Vector(151.869, 8.800, -225.833), Vector(131.907, 16.581,
				-238.408), Vector(127.361, 8.772, -233.725), Vector(131.369, 10.300, -267.255), Vector(108.870, 13.853, -277.224));
			"Garden goal position"
			Global.EndPosition = Vector(71.347, 9.120, -279.602) - Vector(0, 2, 0);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(192.857, 9.038, -196.085);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(202.107, 6.719, -196.908);
			Global.WinnerResetRingStats[0] = Vector(204.878, 7.247, -199.526);
		"City Center"
		Else If(Count Of(Players Within Radius(Vector(66.241, 2.300, 324.072), 40, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(95.535, 2.200, 272.691), Vector(143.308, 3.448, 247.397), Vector(139.550, 11.298,
				251.107), Vector(147.400, 11.299, 243.810), Vector(209.108, 2.303, 213.907), Vector(157.325, 5.232, 213.538));
			"City Center goal position"
			Global.EndPosition = Vector(178.628, 2.276, 174.641) - Vector(0, 2, 0);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(73.560, 2.300, 327.104);
			Global.WinnerResetRingStats[0] = Vector(65.313, 2.300, 314.109);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(84.820, 2.148, 310.593);
			"The text above the endgame rings for winners"
			Global.WinnerHeroesRingStats[3] = Vector(0, 0.750, 0);
		End;
		Global.WinnerResetRingStats[3] = Vector(0, 0.750, 0);
	}
}

rule("map setting (global arr p, global b, global d, global c) - nepal(all)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Insert map name here"
		Current Map == Map(Nepal);
	}

	actions
	{
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		Start Forcing Spawn Room(Team 1, 2);
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		"Shrine"
		If(Count Of(Players Within Radius(Vector(-41.729, 19.079, -93.923), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(-70.186, 20.076, -40.441), Vector(-43.379, 19.417, -20.224), Vector(-43.716, 19.442,
				20.212), Vector(-52.963, 20.606, 44.634), Vector(-72.738, 12.476, 47.462), Vector(-30.099, 16.585, 51.459));
			"Shrine goal position"
			Global.EndPosition = Vector(-45.233, 16.300, 72.137) - Vector(0, 2, 0);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(-45.895, 18.079, -88.959);
			Global.WinnerResetRingStats[0] = Vector(-49.186, 18.079, -89.027);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(-37.556, 18.946, -88.505);
		"Sanctum"
		Else If(Count Of(Players Within Radius(Vector(82.236, 133.730, -90.834), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(92.358, 140.810, -47.405), Vector(84.485, 131.300, -12.016), Vector(107.637, 133.300,
				18.065), Vector(85.505, 131.675, 40.858), Vector(94.228, 138.254, 47.119), Vector(70.771, 129.837, 66.950));
			"Sanctum goal position"
			Global.EndPosition = Vector(81.344, 131.245, 70.547) - Vector(0, 2, 0);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(86.482, 133.595, -84.782);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(78.553, 132.729, -85.378);
			Global.WinnerResetRingStats[0] = Vector(75.105, 132.730, -85.197);
		"Village"
		Else If(Count Of(Players Within Radius(Vector(-160.389, -94.271, -84.060), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(-179.755, -88.685, -26.069), Vector(-204.373, -89.729, -12.570), Vector(-204.457,
				-89.727, 12.440), Vector(-195.496, -93.630, 45.155), Vector(-163.005, -88.821, 43.442), Vector(-147.271, -83.869, 50.381));
			"Village goal position"
			Global.EndPosition = Vector(-167.446, -97.633, 68.291) - Vector(0, 2, 0);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(-166.073, -95.271, -81.014);
			Global.WinnerResetRingStats[0] = Vector(-168.919, -95.271, -82.581);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(-159.261, -94.705, -76.760);
		End;
		"The text above the endgame rings for winners"
		Global.WinnerHeroesRingStats[3] = Vector(0, 1, 0);
		Global.WinnerResetRingStats[3] = Vector(0, 1, 0);
	}
}

rule("map setting (global arr p, global b, global d, global c) - ilios(all)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Insert map name here"
		Current Map == Map(Ilios);
	}

	actions
	{
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		Start Forcing Spawn Room(Team 1, 2);
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		"Well"
		If(Count Of(Players Within Radius(Vector(-152.014, -1.104, -93.120), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(-181.480, 0.300, -50.903), Vector(-197.571, 11.191, -13.818), Vector(-223.199, 6.427,
				7.091), Vector(-236.558, 6.300, -9.246), Vector(-262.055, -3.701, 31.839), Vector(-213.939, 3.300, 6.564));
			"Well goal position"
			Global.EndPosition = Vector(-271.140, -3.585, 33.279) - Vector(0, 2, 0);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(-157.019, -1.355, -89.945);
			Global.WinnerResetRingStats[0] = Vector(-160.308, -1.355, -91.403);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(-149.658, -1.587, -86.416);
		"Ruins"
		Else If(Count Of(Players Within Radius(Vector(131.609, 64.254, -159.135), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(91.562, 65.583, -174.582), Vector(66.927, 68.505, -169.264), Vector(28.390, 62.689,
				-148.659), Vector(-1.205, 65.524, -147.564), Vector(-33.746, 65.611, -173.263), Vector(-65.140, 61.666, -168.727));
			"Tower goal position"
			Global.EndPosition = Vector(-51.248, 67.259, -158.371) - Vector(0, 2, 0);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(127.484, 63.920, -154.025);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(128.139, 63.254, -161.875);
			Global.WinnerResetRingStats[0] = Vector(128.072, 63.254, -165.528);
		"Town"
		Else If(Count Of(Players Within Radius(Vector(322.692, -21.520, 42.832), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(355.021, -19.264, -4.231), Vector(330.019, -16.347, -30.497), Vector(350.081, -15.408,
				-56.854), Vector(304.817, -16.160, -73.229), Vector(294.972, -19.341, -75.245), Vector(276.960, -20.361, -83.065));
			"Town goal position"
			Global.EndPosition = Vector(290.229, -23.291, -88.556) - Vector(0, 3, 0);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(327.717, -21.520, 39.609);
			Global.WinnerResetRingStats[0] = Vector(331.080, -21.520, 41.121);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(320.494, -21.755, 36);
		End;
		"The text above the endgame rings for winners"
		Global.WinnerHeroesRingStats[3] = Vector(0, 0.250, 0);
		Global.WinnerResetRingStats[3] = Vector(0, 0.250, 0);
	}
}

rule("map setting (global arr p, global b, global d, global c) - lijiang tower(all)(lunar new year)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Current Map == Map(Lijiang Tower) || Current Map == Map(Lijiang Tower Lunar New Year)) == True;
	}

	actions
	{
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		Start Forcing Spawn Room(Team 1, 2);
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		"Data Center"
		If(Count Of(Players Within Radius(Vector(61.699, 268.879, 342.773), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(30.128, 270.151, 282.442), Vector(2.043, 280.231, 312.979), Vector(-0.085, 273.800,
				280.044), Vector(-2.029, 280.231, 313.200), Vector(-38.268, 268.300, 295.176), Vector(-28.765, 271.300, 340.361));
			"Data Center goal position"
			Global.EndPosition = Vector(-51.280, 266.300, 332.484) - Vector(0, 2, 0);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(59.981, 268.878, 336.868);
			Global.WinnerResetRingStats[0] = Vector(62.727, 268.878, 334.382);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(54.159, 268.545, 342.362);
		"Tower"
		Else If(Count Of(Players Within Radius(Vector(79.167, 97.863, 144.773), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(46.896, 96.452, 136.808), Vector(-0.070, 95.551, 158.403), Vector(0.028, 95.550,
				141.938), Vector(-36.303, 96.450, 137.238), Vector(53.242, 97.554, 169.195), Vector(-54.166, 95.551, 159.799));
			"Tower goal position"
			Global.EndPosition = Vector(-65.245, 95.552, 146.885) - Vector(0, 2, 0);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(75.006, 97.780, 150.128);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(74.991, 98.113, 142.005);
			Global.WinnerResetRingStats[0] = Vector(74.509, 98.113, 138.469);
		"Shrine"
		Else If(Count Of(Players Within Radius(Vector(78.273, 6.208, -30.659), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(59.281, 3.741, -12.995), Vector(6.914, 0.741, -39.069), Vector(-2.149, 9.756, -52.371),
				Vector(-34.343, 0.741, -12.038), Vector(-57.683, 3.745, -12.967), Vector(-53.844, 4.400, -30.280));
			"Shrine goal position"
			Global.EndPosition = Vector(-60.904, 7.743, -14.404) - Vector(0, 2, 0);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(74.181, 5.900, -34.525);
			Global.WinnerResetRingStats[0] = Vector(74.792, 5.900, -37.957);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(72.166, 5.786, -26.690);
		End;
		"The text above the endgame rings for winners"
		Global.WinnerHeroesRingStats[3] = Vector(0, 0, 0);
		Global.WinnerResetRingStats[3] = Vector(0, 0, 0);
	}
}

rule("map setting (global arr p, global b, global d, global c) - busan(all)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Insert map name here"
		Current Map == Map(Busan);
	}

	actions
	{
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		Start Forcing Spawn Room(Team 1, 2);
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		"Factory"
		If(Count Of(Players Within Radius(Vector(290.902, 12.396, 213.099), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(251.444, 13.395, 221.373), Vector(223.880, 19.332, 214.017), Vector(51.997, 7.309,
				-101.671), Vector(177.838, 12.395, 275.812), Vector(186.569, 13.395, 248.653), Vector(194.799, 22.393, 246.564));
			"Factory goal position"
			Global.EndPosition = Vector(163.996, 11.397 - 1.320, 259.067);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(292.254, 12.494, 219.868);
			Global.WinnerResetRingStats[0] = Vector(295.837, 12.494, 218.427);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(295.322, 11.595, 221.749);
		"Plaza"
		Else If(Count Of(Players Within Radius(Vector(-31.724, 18.300, -125.575), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(26.382, 23.990, -110.239), Vector(34.637, 16.300, -122.903), Vector(51.761, 7.309,
				-101.209), Vector(69.110, 16.300, -122.896), Vector(77.047, 24.050, -110.099), Vector(107.594, 18.314, -148.811));
			"Plaza goal position"
			Global.EndPosition = Vector(112.557, 17.246 - 1.320, -125.478);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(-43.861, 17.820, -125.438);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(-43.677, 18.253, -122.800);
			Global.WinnerResetRingStats[0] = Vector(-43.634, 18.253, -128.069);
		"Dojo"
		Else If(Count Of(Players Within Radius(Vector(-426.165, 12.407, 165.979), 30, Team 1, Off)) != 0);
			Global.AllBastionPositions = Array(Vector(-365.499, 15.267, 130.545), Vector(-328.646, 18.403, 167.589), Vector(-329.006, 16.203,
				138.519), Vector(-307.520, 11.953, 139.141), Vector(-291.570, 13.334, 157.068), Vector(-252.461, 10.655, 152.426));
			"Dojo goal position"
			Global.EndPosition = Vector(-262.352, 10.460 - 1.320, 161.585);
			"Location of winners end game rings"
			Global.WinnerHeroesRingStats[0] = Vector(-411.092, 11.462, 174.379);
			Global.WinnerResetRingStats[0] = Vector(-412.805, 11.462, 154.558);
			"Base coordinates for world game settings HUD"
			Global.GameSettingTextVec = Vector(-410.566, 11.463, 164.413);
		End;
		"The text above the endgame rings for winners"
		Global.WinnerHeroesRingStats[3] = Vector(0, 0, 0);
		Global.WinnerResetRingStats[3] = Vector(0, 0, 0);
	}
}

rule("map setting (global arr p, global b, global d, global c) - hanamura (winter)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Current Map == Map(Hanamura) || Current Map == Map(Hanamura Winter)) == True;
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-14.835, 7.540, -94.010), Vector(-23.327, -1, -47.090), Vector(13.117, 7.170, -50.253),
			Vector(24.812, 6, 9.457), Vector(46.742, 6, -13.957), Vector(68.033, -1.900, 12.950));
		Global.EndPosition = Vector(68.166, -2, -0.310);
		Start Forcing Spawn Room(Team 1, 2);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-30.205, 0.500, -105.354);
		Global.WinnerResetRingStats[0] = Vector(-37.960, 0.500, -97.845);
		"The text above the endgame rings for winners"
		Global.WinnerHeroesRingStats[3] = Vector(0, 2, 0);
		Global.WinnerResetRingStats[3] = Vector(0, 2, 0);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-33.825, 1.750, -101.375);
	}
}

rule("map setting (global arr p, global b, global d, global c) - gibraltar")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Watchpoint: Gibraltar);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(70.099, 9, 26.803), Vector(81.759, 6, 3.200), Vector(64.465, 9.690, -32.138), Vector(
			32.373, 3, -50.866), Vector(31.113, 7.300, -89.871), Vector(41.383, 4, -124.788));
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Add another bastion (Experimental)"
		If(Global.HasSeventhBastionWS);
			Global.AllBastionPositions[6] = Vector(51, -3.910, -159.860);
			Global.BastionBotCount = 7;
		End;
		Global.EndPosition = Vector(46.558, 1, -146.808);
		Start Forcing Spawn Room(Team 1, 2);
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(82.842, -8.700, 44.751);
		Global.WinnerResetRingStats[0] = Vector(77.831, -8.700, 49.404);
		"The text above the endgame rings for winners"
		Global.WinnerHeroesRingStats[3] = Vector(0, 2, 0);
		Global.WinnerResetRingStats[3] = Vector(0, 2, 0);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(77.495, -9.676, 44.697);
	}
}

rule("map setting (global arr p, global b, global d, global c) - numbani")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Numbani);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(179.102, 4.250, 13.115), Vector(154.224, -4.180, 13.616), Vector(118.815, 4.250, 3.556),
			Vector(78.459, 6.250, -11.527), Vector(-49.872, 11.283, -43.701), Vector(7.964, 1.270, -6.488));
		Global.EndPosition = Vector(6.984, -1, 5.778);
		Start Forcing Spawn Room(Team 1, 1);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(241.550, 1.665, 22.677);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(238.587, 1.455, 18.412);
		Global.WinnerResetRingStats[0] = Vector(238.587, 1.505, 26.771);
	}
}

rule("map setting (global arr p, global b, global d, global c) - volskaya industries")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Volskaya Industries);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-87.972, 2.020, 38.919), Vector(-67.835, 10.390, 49.479), Vector(-63.809, -0.410,
			77.730), Vector(-11.250, 1.270, 76.356), Vector(-16.279, 2.200, 41.017), Vector(-6.364, 8.240, 35.514));
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Add another bastion (Experimental)"
		If(Global.HasSeventhBastionWS);
			Global.AllBastionPositions[6] = Vector(-35.430, -2.980, 28.190);
			Global.BastionBotCount = 7;
		End;
		Global.EndPosition = Vector(-11.477, -6, 19.868);
		Start Forcing Spawn Room(Team 1, 0);
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-108.629, -0.680, 27.504);
		Global.WinnerResetRingStats[0] = Vector(-117.908, -0.680, 36.678);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-112.517, -1.680, 32.352);
	}
}

rule("map setting (global arr p, global b, global d, global c) - route 66")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Route 66);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-95.624, 12.660, -5.541), Vector(-38.680, 12.750, -22.136), Vector(-15.784, 8.540,
			-12.685), Vector(36.467, 2.140, -4.003), Vector(48.707, 10.110, 25.063), Vector(26.871, 7.010, 2.468));
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Add another bastion (Experimental)"
		If(Global.HasSeventhBastionWS);
			Global.AllBastionPositions[6] = Vector(51.140, 2.380, 59.880);
			Global.BastionBotCount = 7;
		End;
		Global.EndPosition = Vector(47.956, 5.200, 47.318);
		Start Forcing Spawn Room(Team 1, 1);
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-106.441, 6, -58.824);
		Global.WinnerResetRingStats[0] = Vector(-108.447, 6, -62.336);
		"The text above the endgame rings for winners"
		Global.WinnerHeroesRingStats[3] = Vector(0, 0, 0);
		Global.WinnerResetRingStats[3] = Vector(0, 0, 0);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-108.281, 5.812, -50.656);
	}
}

rule("map setting (global arr p, global b, global d, global c) - rialto")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Rialto);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-64.421, 5.040, -125.927), Vector(-16.976, 1.660, -38.459), Vector(-36.002, 4.750,
			-77.344), Vector(59.058, 0.070, -8.103), Vector(54.797, 1.740, -59.938), Vector(87.874, -0.370, 0.268));
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Add another bastion (Experimental)"
		If(Global.HasSeventhBastionWS);
			Global.AllBastionPositions[6] = Vector(13.670, 3.750, -35.720);
			Global.BastionBotCount = 7;
		End;
		Global.EndPosition = Vector(98.662, -1.500, -21.009);
		Start Forcing Spawn Room(Team 1, 2);
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-49.550, 5.050, -171.124);
		Global.WinnerResetRingStats[0] = Vector(-63.679, 5.050, -170.880);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-57, 4.050, -156.838);
	}
}

rule("map setting (global arr p, global b, global d, global c) - horizon lunar colony")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Horizon Lunar Colony);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-15.287, 6, -127.244), Vector(16.250, 11.860, -106.756), Vector(70.800, 15, -76.840),
			Vector(62.340, 6, -34.740), Vector(19.496, 9, -1.439), Vector(66.687, 8.520, -37.241));
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Add another bastion (Experimental)"
		If(Global.HasSeventhBastionWS);
			Global.AllBastionPositions[6] = Vector(92.690, 14.530, -83.950);
			Global.BastionBotCount = 7;
		End;
		Global.EndPosition = Vector(34.476, 11.500, -23.518);
		Start Forcing Spawn Room(Team 1, 0);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-43.492, 5.800, -156.776);
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-37.170, 6.450, -161.895);
		Global.WinnerResetRingStats[0] = Vector(-38.639, 6.450, -165.470);
	}
}

rule("map setting (global arr p, global b, global d, global c) - havana")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Havana);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(117.332, 14.433, -58.091), Vector(140.438, 6.413, -16.667), Vector(31.288, 18.900,
			-75.331), Vector(-32.514, 7.150, -79.487), Vector(14.787, 7.300, -47.470), Vector(-71.110, 5.846, -72.362));
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Add another bastion (Experimental)"
		If(Global.HasSeventhBastionWS);
			Global.AllBastionPositions[6] = Vector(43.260, 9.950, -93.300);
			Global.BastionBotCount = 7;
		End;
		Global.EndPosition = Vector(-71.203, 2, -50.678);
		Start Forcing Spawn Room(Team 1, 2);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(158.050, 12.302, -46.921);
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(172.764, 12.300, -51.870);
		Global.WinnerResetRingStats[0] = Vector(172.695, 12.300, -41.247);
	}
}

rule("map setting (global arr p, global b, global d, global c) - dorado")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Dorado);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(170.288, 19.100, 45.051), Vector(118.262, 18.250, 1.209), Vector(78.973, 17.480, -6.843),
			Vector(34.074, 11.080, -17.958), Vector(26.361, 10.650, 20.115), Vector(126.713, 16.300, 17.517));
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Add another bastion (Experimental)"
		If(Global.HasSeventhBastionWS);
			Global.AllBastionPositions[6] = Vector(-5.490, 8.010, 2);
			Global.BastionBotCount = 7;
		End;
		Global.EndPosition = Vector(16.012, Empty Array, 5.874);
		Start Forcing Spawn Room(Team 1, 1);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(184.096, 7.840, 40.671);
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(182.148, 8.390, 42.701);
		Global.WinnerResetRingStats[0] = Vector(183.660, 8.390, 37.902);
	}
}

rule("map setting (global arr p, global b, global d, global c) - king's row (winter)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Current Map == Map(King's Row) || Current Map == Map(King's Row Winter)) == True;
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-143.900, 7.130, 10.150), Vector(-120.990, 1.070, -12.080), Vector(-91.380, 1.140,
			-27.900), Vector(-55.460, -0.200, -29.830), Vector(5.980, 6.110, -30.350), Vector(-21.560, 2.580, -8.160));
		Global.EndPosition = Vector(-1.900, 5, -0.290);
		Start Forcing Spawn Room(Team 1, 1);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-173.483, 0.762, 36.414);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-178.034, 1.260, 43.774);
		Global.WinnerResetRingStats[0] = Vector(-180.556, 1.262, 30.807);
	}
}

rule("map setting (global arr p, global b, global d, global c) - blizzworld (winter)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter)) == True;
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-121.979, 0.148, 110.507), Vector(-93.733, -1.047, 110.100), Vector(-66.733, 7.079,
			110.571), Vector(-0.165, 7.421, 89.178), Vector(3.082, 3.900, 43.609), Vector(3.049, -4.850, 16.685), Vector(-30.574, 12.966,
			87.938));
		Start Forcing Spawn Room(Team 1, 1);
		Global.EndPosition = Vector(2.772, -6.500, -6.900);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-151.769, 1.648, 101.924);
		Global.BlizzWorldSpawnLoc = Vector(-169.871, 2.948, 96.498);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 7;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-152.835, 0.500, 106.112);
		Global.WinnerResetRingStats[0] = Vector(-150.326, 0.500, 98.171);
		"The text above the endgame rings for winners"
		Global.WinnerHeroesRingStats[3] = Vector(0, 2, 0);
		Global.WinnerResetRingStats[3] = Vector(0, 2, 0);
	}
}

rule("map setting (global arr p, global b, global d, global c) - eichenwalde (halloween)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Current Map == Map(Eichenwalde) || Current Map == Map(Eichenwalde Halloween)) == True;
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(123.333, 8.971, -27.303), Vector(89.318, 21.095, -62.697), Vector(38.021, 13.917,
			-79.821), Vector(23.799, 7.417, -53.839), Vector(-4.858, 6.957, -31.559), Vector(25.587, 6.300, -14.531));
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Add another bastion (Experimental)"
		If(Global.HasSeventhBastionWS);
			Global.AllBastionPositions[6] = Vector(67.750, 4.720, -84.020);
			Global.BastionBotCount = 7;
		End;
		Global.EndPosition = Vector(-10.354, -2.149, -12.399);
		Start Forcing Spawn Room(Team 1, 2);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(129.339, 12.120, -2.655);
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(135.825, 11.899, -2.692);
		Global.WinnerResetRingStats[0] = Vector(124.359, 11.898, 0.626);
	}
}

rule("map setting (global arr p, global b, global d, global c) - hollywood (halloween)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween)) == True;
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-26.166, 7.503, -134.609), Vector(-2.241, 12.161, -112.505), Vector(11.552, 6.303,
			-69.943), Vector(-7.480, 7.441, -43.441), Vector(-20.714, 8.050, 9.977), Vector(4.864, 7.147, 38.401), Vector(-43.340, 0.500,
			48.970));
		Start Forcing Spawn Room(Team 1, 2);
		Global.EndPosition = Vector(-12.002, -1.307, 69.489);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-32.049, 4.714, -155.052);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 7;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-27.106, 5.414, -157.424);
		Global.WinnerResetRingStats[0] = Vector(-22.370, 5.416, -158.670);
		"[0] = The CORRECT Hollywood spawn point; [1] = The WRONG Hollywood spawn point"
		Global.HollywoodSpawns = Array(Vector(-30.960, 7.254, -172.189), Vector(49.257, 4.050, -56.238));
	}
}

rule("map setting (global arr p, global b, global d, global c) - junkertown")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Junkertown);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-96.235, 13.672, -136.725), Vector(-72.380, 7.672, -144.151), Vector(-27.431, 13.780,
			-100.155), Vector(-32.236, 12.976, -29.143), Vector(-2.080, 11.366, -61.807), Vector(30.116, 13.407, -59.880));
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Add another bastion (Experimental)"
		If(Global.HasSeventhBastionWS);
			Global.AllBastionPositions[6] = Vector(33.010, 9, -52.060);
			Global.BastionBotCount = 7;
		End;
		Global.EndPosition = Vector(30.248, 5.515, -81.733);
		Start Forcing Spawn Room(Team 1, 2);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-95.486, 12.245, -86.316);
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-85.345, 11.812, -81.681);
		Global.WinnerResetRingStats[0] = Vector(-94.717, 11.800, -84.011);
		Global.WinnerResetRingStats[3] = Vector(0, 0, 0);
	}
}

rule("map setting (global arr p, global b, global d, global c) - paris")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Paris);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-95.984, 13.454, -83.535), Vector(-72.132, 11.976, -44.042), Vector(-41.725, 14.240,
			-2.920), Vector(34.074, 11.080, -17.958), Vector(-14.721, 14.250, -35.219), Vector(0.211, 10.174, -60.874));
		Global.EndPosition = Vector(9.563, 8.329, -59.980);
		Start Forcing Spawn Room(Team 1, 1);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-108.617, 15.800, -109.835);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-110.869, 16, -105.512);
		Global.WinnerResetRingStats[0] = Vector(-104.076, 16.445, -109.313);
	}
}

rule("map setting (global arr p, global b, global d, global c) - anubis")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Temple of Anubis);
	}

	actions
	{
		Global.AllBastionPositions = Array(Vector(-17.188, 11.237, 105.646), Vector(-12.218, 10.667, 52.835), Vector(-58.847, 6.810,
			41.419), Vector(-8.454, 1.153, 29.868), Vector(8.482, 4.898, 10.299), Vector(-23.218, 2.706, -26.863));
		Global.EndPosition = Vector(-0.866, -3.781, -10.919);
		Start Forcing Spawn Room(Team 1, 1);
		"Total amount of Bastion Bots to spawn"
		Global.BastionBotCount = 6;
		"Location of winners end game rings"
		Global.WinnerHeroesRingStats[0] = Vector(-5.076, 5.576, 140.240);
		Global.WinnerResetRingStats[0] = Vector(-15.733, 5.585, 137.884);
		"Base coordinates for world game settings HUD"
		Global.GameSettingTextVec = Vector(-7.971, 5.570, 135.900);
	}
}

rule("Spawn players at alternative locations instead")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Call Subroutine(SpawnAtAltLoc);
	}
}

rule("init winners feature rings (END GAME)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.WinnerHeroesRingStats[2] == Null;
	}

	actions
	{
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		Create Effect(Filtered Array(All Players(Team 1), Current Array Element.IsWinner), Ring, Color(Rose),
			Global.WinnerHeroesRingStats[0], Global.WinnerHeroesRingStats[1], Visible To);
		Global.WinnerHeroesRingStats[2] = Last Created Entity;
		Create In-World Text(Filtered Array(All Players(Team 1), Current Array Element.IsWinner), Custom String(
			"[Jump]/[Crouch] to Change Hero"), Global.WinnerHeroesRingStats[0] + Global.WinnerHeroesRingStats[3], 1.300,
			Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		Create Effect(Filtered Array(All Players(Team 1), Current Array Element.IsWinner), Ring, Color(Rose),
			Global.WinnerResetRingStats[0], Global.WinnerResetRingStats[1], Visible To);
		Global.WinnerResetRingStats[2] = Last Created Entity;
		Create In-World Text(Filtered Array(All Players(Team 1), Current Array Element.IsWinner), Custom String("[Reload] to Start Over",
			Input Binding String(Button(Reload))), Global.WinnerResetRingStats[0] + Global.WinnerResetRingStats[3], 1.300,
			Clip Against Surfaces, Visible To, Color(White), Default Visibility);
	}
}

rule("Select the next winner hero using ring (END GAME)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.IsWinner == True;
		Global.WinnerHeroesRingStats[2] != Null;
		Is Button Held(Event Player, Button(Jump)) == True;
		"Fail-safe mechanism to prevent server from crashing!"
		Round To Integer(Server Load / 255 * 100, To Nearest) < Global.MaxSafetyServerLoadWS;
		Is True For Any(Players Within Radius(Global.WinnerHeroesRingStats[0], Global.WinnerHeroesRingStats[1], Team 1, Off),
			Current Array Element == Event Player) == True;
	}

	actions
	{
		If(Event Player.WinnerHeroCursor == Count Of(Global.WinnerHeroesList) - 1);
			Event Player.WinnerHeroCursor = 0;
		Else;
			Event Player.WinnerHeroCursor += 1;
		End;
		Start Forcing Player To Be Hero(Event Player, Global.WinnerHeroesList[Event Player.WinnerHeroCursor]);
		Preload Hero(Event Player, Array Slice(Global.WinnerHeroesList, Min(0, Event Player.WinnerHeroCursor - 2), 5));
		Wait(2, Ignore Condition);
	}
}

rule("Select the previous winner hero using ring (END GAME)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.IsWinner == True;
		Global.WinnerHeroesRingStats[2] != Null;
		Is Button Held(Event Player, Button(Crouch)) == True;
		"Fail-safe mechanism for server crashes! Prevents usage if above specified percentage"
		Round To Integer(Server Load / 255 * 100, To Nearest) < Global.MaxSafetyServerLoadWS;
		Is True For Any(Players Within Radius(Global.WinnerHeroesRingStats[0], Global.WinnerHeroesRingStats[1], Team 1, Off),
			Current Array Element == Event Player) == True;
	}

	actions
	{
		If(Event Player.WinnerHeroCursor == 0);
			Event Player.WinnerHeroCursor = Count Of(Global.WinnerHeroesList) - 1;
		Else;
			Event Player.WinnerHeroCursor -= 1;
		End;
		Start Forcing Player To Be Hero(Event Player, Global.WinnerHeroesList[Event Player.WinnerHeroCursor]);
		Preload Hero(Event Player, Array Slice(Global.WinnerHeroesList, Min(0, Event Player.WinnerHeroCursor - 2), 5));
		Wait(2, Ignore Condition);
	}
}

rule("Reset winner using ring (END GAME)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.IsWinner == True;
		Global.WinnerResetRingStats[2] != Null;
		Is Button Held(Event Player, Button(Reload)) == True;
		Is True For Any(Players Within Radius(Global.WinnerResetRingStats[0], Global.WinnerResetRingStats[1], Team 1, Off),
			Current Array Element == Event Player) == True;
	}

	actions
	{
		Event Player.BacktrackDeaths = 0;
		Event Player.IsWinner = False;
		Event Player.Deaths = 0;
		Event Player.WinnerHeroCursor = 0;
		Event Player.CurrentHero = 0;
		Event Player.TargetHero = 0;
		Modify Global Variable(SavedHero, Remove From Array By Index, Index Of Array Value(Global.SavedIndex, Custom String("{0}",
			Event Player)));
		Modify Global Variable(SavedDeaths, Remove From Array By Index, Index Of Array Value(Global.SavedIndex, Custom String("{0}",
			Event Player)));
		Modify Global Variable(SavedWinners, Remove From Array By Index, Index Of Array Value(Global.SavedIndex, Custom String("{0}",
			Event Player)));
		Modify Global Variable(SavedBacktrackDeaths, Remove From Array By Index, Index Of Array Value(Global.SavedIndex, Custom String(
			"{0}", Event Player)));
		Modify Global Variable(SavedIndex, Remove From Array By Value, Custom String("{0}", Event Player));
		Stop Forcing Player Outlines(Event Player, All Players(Team 1));
		Set Move Speed(Event Player, 100);
		If(Event Player.WinnerDeathID != Null);
			Destroy HUD Text(Event Player.WinnerDeathID);
			Event Player.WinnerDeathID = Null;
	}
}

rule("Spawn ALL players at alternate spawn location[SR]")
{
	event
	{
		Subroutine;
		SpawnAllAtAltLoc;
	}

	actions
	{
		If(Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter));
			Teleport(All Players(Team 1), Global.BlizzWorldSpawnLoc);
			Set Facing(All Players(Team 1), Forward + Left, To World);
		Else If(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween));
			Teleport(All Players(Team 1), Global.HollywoodSpawns[0]);
			Set Facing(All Players(Team 1), Right, To World);
		End;
	}
}

rule("Spawn players at alternate spawn location[SR]")
{
	event
	{
		Subroutine;
		SpawnAtAltLoc;
	}

	actions
	{
		If(Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter));
			Teleport(Event Player, Global.BlizzWorldSpawnLoc);
			Set Facing(Event Player, Forward + Left, To World);
		Else If(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween));
			Teleport(Event Player, Global.HollywoodSpawns[0]);
			Set Facing(Event Player, Right, To World);
		End;
	}
}

rule("Game settings world HUD")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		Call Subroutine(SetupGameSettingsText);
		For Global Variable(TempVar, Count Of(Global.GameSettingsHUDWT) - 1, -1, -1);
			Create In-World Text(All Players(Team 1), Global.GameSettingsHUDWT[Global.TempVar], Global.GameOptTextVec, 1.500,
				Clip Against Surfaces, Visible To, Color(Lime Green), Default Visibility);
			Call Subroutine(IncrementGameSettingsPos);
		End;
		"World game settings HUD"
		Create In-World Text(All Players(Team 1), Custom String("Prison Escape"), Global.GameSettingTextVec, 2.750, Clip Against Surfaces,
			Visible To, Color(Rose), Default Visibility);
	}
}

rule("setup game option settings text for world HUD [SR]")
{
	event
	{
		Subroutine;
		SetupGameSettingsText;
	}

	actions
	{
		Global.GameSettingsHUDWT = Empty Array;
		Modify Global Variable(GameSettingsHUDWT, Append To Array, Custom String("Hero Order: [{0}]",
			Global.HeroListTypeWS == 0 ? Custom String("Normal") : (Global.HeroListTypeWS == 1 ? Custom String("Random") : (
			Global.HeroListTypeWS == 2 ? Custom String("Independent") : Custom String("Custom")))));
		Modify Global Variable(GameSettingsHUDWT, Append To Array, Custom String("Global Effect: [{0}]",
			Global.IsGEEnabledWS ? Custom String("Enabled") : Custom String("Disabled")));
		If(Global.BacktrackDeathsWS != 0);
			Modify Global Variable(GameSettingsHUDWT, Append To Array, Custom String("Backtrack Range: [{0}] <-----> [{1}]",
				Global.BacktrackMinMaxListWS[0], Global.BacktrackMinMaxListWS[1]));
		End;
		Modify Global Variable(GameSettingsHUDWT, Append To Array, Custom String("Bastion Position: [{0}]",
			Global.BastionPosTypeWS == 0 ? Custom String("Original") : (Global.BastionPosTypeWS == 1 ? Custom String("Randomized") : (
			Global.BastionPosTypeWS == 2 ? Custom String("Random Once") : Custom String("On Escape")))));
		Global.GameOptTextVec = Global.GameSettingTextVec;
		"Height of \"Game Setting\" title from options"
		Global.GameSettingTextVec += Vector(0, 0.150, 0);
		"(Experimental) \"7th Bastion Option\""
		If(Global.BastionBotCount == 7 && Global.HasSeventhBastionWS);
			Create In-World Text(All Players(Team 1), Custom String("7th Bastion is present!"), Global.GameOptTextVec, 1.500,
				Clip Against Surfaces, Visible To and String, Color(Orange), Default Visibility);
			Call Subroutine(IncrementGameSettingsPos);
		End;
		"The \"Next Map Cycle Option\""
		If(Global.HasAllWinnersToCycleWS);
			Create In-World Text(All Players(Team 1), Custom String("Completions Until Next Map: [{0}] / [{1}]", Global.CurWinnerCount,
				Count Of(All Players(Team 1))), Global.GameOptTextVec, 1.500, Clip Against Surfaces, Visible To and String, Color(Yellow),
				Default Visibility);
			Call Subroutine(IncrementGameSettingsPos);
		End;
	}
}

rule("Increment game settings HUD position[SR]")
{
	event
	{
		Subroutine;
		IncrementGameSettingsPos;
	}

	actions
	{
		"The spacing between each game setting in the HUD"
		Global.GameOptTextSpacing = Vector(0, 0.600, 0);
		Global.GameOptTextVec += Global.GameOptTextSpacing;
		Global.GameSettingTextVec += Global.GameOptTextSpacing;
	}
}

rule("Buff positions (Default) (Global T, Global J)")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.T = Empty Array;
		Global.JumpPadLocList = Empty Array;
		Global.JumpPadPowerList = Empty Array;
		Global.Y = -1;
	}
}

rule("Activate teleporters if spawn room doors is inaccessible - hollywood")
{
	event
	{
		Player Joined Match;
		Team 1;
		Slot 0;
	}

	conditions
	{
		(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween)) == True;
		"Bad spawn point"
		Distance Between(Event Player, Global.HollywoodSpawns[1]) <= 15;
	}

	actions
	{
		"Sometimes, the doors to spawn room 3 would be closed. These actions will force the players inside the room. The teleporters will allow players to leave the room at will."
		Global.isTeleporterEnabled = True;
		Call Subroutine(SpawnAtAltLoc);
	}
}

rule("Teleporter position init (global T) -  volskaya industries")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.T == Empty Array;
		Current Map == Map(Volskaya Industries);
	}

	actions
	{
		"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
		Global.T = Array(Vector(33.510, -3.200, 71.280), Vector(20.840, -4.230, 48.830));
	}
}

rule("Teleporter position init (global T) - temple of anubis")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.T == Empty Array;
		Current Map == Map(Temple of Anubis);
	}

	actions
	{
		"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
		Global.T = Array(Vector(-44.946, 10.509, 27.075), Vector(-10.927, 13.007, 15.272));
	}
}

rule("Teleporter position init (global T) - paris")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.T == Empty Array;
		Current Map == Map(Paris);
	}

	actions
	{
		"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
		Global.T = Array(Vector(-23.879, 16.341, 15.498), Vector(-10.647, 15.349, -39.465));
	}
}

rule("Teleporter position init (global T) - nepal")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.T == Empty Array;
		Current Map == Map(Nepal);
	}

	actions
	{
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		"Village"
		If(Count Of(Players Within Radius(Vector(-160.389, -94.271, -84.060), 30, Team 1, Off)) != 0);
			"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
			Global.T = Array(Vector(-220.003, -94.746, -24.949), Vector(-220.392, -93.377, -10.542), Vector(-220.104, -94.205, 13.117), Vector(
				-220.205, -94.747, 25.866));
	}
}

rule("Teleporter position init (global T) - hollywood")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.isTeleporterEnabled == True;
		Global.T == Empty Array;
		(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween)) == True;
	}

	actions
	{
		Global.T = Array(Vector(-52.836, 5.050, -148.546), Vector(-52.562, 5.050, -147.402), Vector(-14.796, 5.050, -147.334), Vector(
			-15.813, 5.050, -146.567));
	}
}

rule("Teleporter position init (global T) - hanamura")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.T == Empty Array;
		(Current Map == Map(Hanamura) || Current Map == Map(Hanamura Winter)) == True;
	}

	actions
	{
		Global.T = Array(Vector(-28.532, 2.301, -57.827), Vector(-12.406, 2.299, -32.859), Vector(26.500, 1.200, 7.857), Vector(46.023,
			1.768, 38.157));
	}
}

rule("Teleporter position init (global T) - king's row")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.T == Empty Array;
		(Current Map == Map(King's Row) || Current Map == Map(King's Row Winter)) == True;
	}

	actions
	{
		"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
		Global.T = Array(Vector(-13.206, 1.700, 2.599), Vector(-26.548, 7.744, 8.545), Vector(-69.864, 1.050, 0.780), Vector(-67.829,
			1.550, 1.166), Vector(-56.445, 6.450, -11.168), Vector(-58.004, 6.122, -11.574));
	}
}

rule("Teleporter position init (global T) - illios")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.T == Empty Array;
		Current Map == Map(Ilios);
	}

	actions
	{
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		"Well"
		If(Count Of(Players Within Radius(Vector(-152.014, -1.104, -93.120), 30, Team 1, Off)) != 0);
			"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
			Global.T = Array(Vector(-219.430, 1.300, -22.312), Vector(-199.053, 2.315, -6.979), Vector(-196.207, 2.315, -4.372), Vector(
				-214.369, 1.300, -26.572));
		"Ruins"
		Else If(Count Of(Players Within Radius(Vector(131.609, 64.254, -159.135), 30, Team 1, Off)) != 0);
			"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
			Global.T = Array(Vector(59.421, 61.917, -140.094), Vector(41.130, 67.671, -144.216), Vector(-1.989, 61.668, -167.644), Vector(
				-0.496, 65.784, -170.078));
	}
}

rule("Jump pad position init (global J)(global K) - nepal")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.JumpPadLocList == Empty Array;
		Current Map == Map(Nepal);
	}

	actions
	{
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		"Shrine"
		If(Count Of(Players Within Radius(Vector(-41.729, 19.079, -93.923), 30, Team 1, Off)) != 0);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-27.684, 16.779, -62.910));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 16);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-45.142, 16.300, -60.279));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 12);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-28.075, 16.300, 81.503));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 16);
		"Village"
		Else If(Count Of(Players Within Radius(Vector(-160.389, -94.271, -84.060), 30, Team 1, Off)) != 0);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-216.263, -94.689, 24.938));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 12);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-194.944, -92.303, -10.583));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 16);
		"Sanctum"
		Else If(Count Of(Players Within Radius(Vector(82.236, 133.730, -90.834), 30, Team 1, Off)) != 0);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(106.045, 129.817, -0.222));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 12);
	}
}

rule("Jump pad position init (global J)(global K) - illios")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.JumpPadLocList == Empty Array;
		Current Map == Map(Ilios);
	}

	actions
	{
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		"Town"
		If(Count Of(Players Within Radius(Vector(322.692, -21.520, 42.832), 30, Team 1, Off)) != 0);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(370.190, -27.343, -56.901));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 20);
		"Well"
		Else If(Count Of(Players Within Radius(Vector(-152.014, -1.104, -93.120), 30, Team 1, Off)) != 0);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-230.206, 0.300, -32.998));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 16);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-224.623, 0.300, -38.636));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 16);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-198.022, 2.300, 5.441));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 16);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-218.367, 6.529, 15.425));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 12);
		"Ruins"
		Else If(Count Of(Players Within Radius(Vector(131.609, 64.254, -159.135), 30, Team 1, Off)) != 0);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(77.862, 60.082, -171.666));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 16);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-49.604, 61.667, -178.331));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 14);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-54.233, 61.619, -158.073));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 18);
			"The location of the jump pad"
			Modify Global Variable(JumpPadLocList, Append To Array, Vector(-56.603, 66.734, -171.348));
			"The strength of the jump pad. How high to to bounce players upwards?"
			Modify Global Variable(JumpPadPowerList, Append To Array, 14);
	}
}

rule("Jump pad position init (global J) - havana")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.JumpPadLocList == Empty Array;
		Current Map == Map(Havana);
	}

	actions
	{
		Modify Global Variable(JumpPadLocList, Append To Array, Vector(103.926, 3.104, -25.884));
		Modify Global Variable(JumpPadPowerList, Append To Array, 18);
	}
}

rule("Jump pad position init (global J, global K) - hanamura")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.JumpPadLocList == Empty Array;
		(Current Map == Map(Hanamura) || Current Map == Map(Hanamura Winter)) == True;
	}

	actions
	{
		Modify Global Variable(JumpPadLocList, Append To Array, Vector(33.167, 3, -24.676));
		Modify Global Variable(JumpPadPowerList, Append To Array, 18);
	}
}

rule("bastion enable turret mode")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
		Is In Alternate Form(Event Player) == False;
		"Bastion Bullets"
		Global.BUChoices[0] != 4;
	}

	actions
	{
		Allow Button(Event Player, Button(Ability 1));
		Press Button(Event Player, Button(Ability 1));
		Teleport(Event Player, Global.AllBastionPositions[Slot Of(Event Player)]);
		Disable Nameplates(Event Player, All Players(All Teams));
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("bastion teleport and init (player E, global d)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Wait(0.250, Ignore Condition);
		Teleport(Event Player, Global.AllBastionPositions[Slot Of(Event Player)]);
		Set Status(Event Player, Null, Unkillable, 99999);
		Set Damage Dealt(Event Player, Global.BastionDamages[0]);
		Set Knockback Received(Event Player, 1);
	}
}

rule("Randomize Bastion positions (RBP)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Global.BastionPosTypeWS == 1 || Global.BastionPosTypeWS == 2) == True;
	}

	actions
	{
		If(Global.BastionPosTypeWS == 1);
			"Lag intervals"
			Wait(Random Real(Global.BastionPosIntervalMinMaxWS[0], Global.BastionPosIntervalMinMaxWS[1]), Ignore Condition);
			Big Message(All Players(Team 1), Custom String("Relocating Bastions..."));
			Wait(1.500, Ignore Condition);
		End;
		Global.RBPIndex = 0;
		While(Global.RBPIndex < Count Of(Global.AllBastionPositions));
			Call Subroutine(SetNewBastionPosition);
			Wait(0.200, Ignore Condition);
		End;
		Loop If(Global.BastionPosTypeWS == 1);
	}
}

rule("Set new randomized Bastion positions (RBP)[SR]")
{
	event
	{
		Subroutine;
		SetNewBastionPosition;
	}

	actions
	{
		Global.BastionPosLocType = Random Integer(0, 25);
		Global.BastionPosDistance = Random Real(1, 50);
		If(Global.BastionPosLocType == 0);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(
				Global.AllBastionPositions[Global.RBPIndex] + Forward * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 1);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Forward + Right) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 2);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(
				Global.AllBastionPositions[Global.RBPIndex] + Right * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 3);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Backward + Right) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 4);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(
				Global.AllBastionPositions[Global.RBPIndex] + Backward * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 5);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Backward + Left) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 6);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(
				Global.AllBastionPositions[Global.RBPIndex] + Left * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 7);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Forward + Left) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 8);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Forward + Down) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 9);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Forward + Up) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 10);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (Right + Up)
				* Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 11);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Right + Down) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 12);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Backward + Down) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 13);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Backward + Up) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 14);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (Left + Up)
				* Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 15);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (Left + Down)
				* Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 16);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Forward + Right + Up) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 17);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Forward + Right + Down) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 18);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Backward + Right + Down) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 19);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Backward + Right + Up) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 20);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Forward + Left + Up) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 21);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Forward + Left + Down) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 22);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Backward + Left + Down) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 23);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(Global.AllBastionPositions[Global.RBPIndex] + (
				Backward + Left + Up) * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 24);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(
				Global.AllBastionPositions[Global.RBPIndex] + Up * Global.BastionPosDistance);
		Else If(Global.BastionPosLocType == 25);
			Global.AllBastionPositions[Global.RBPIndex] = Nearest Walkable Position(
				Global.AllBastionPositions[Global.RBPIndex] + Down * Global.BastionPosDistance);
		End;
		Call Subroutine(RBPCheckAndSet);
	}
}

rule("Check Bastion position before setting it (RPB)[SR]")
{
	event
	{
		Subroutine;
		RBPCheckAndSet;
	}

	actions
	{
		If(!Is In Spawn Room(First Of(Players In Slot(Global.RBPIndex, Team 2))));
			If(((Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter)) && Distance Between(
				Global.AllBastionPositions[Global.RBPIndex], Global.BlizzWorldSpawnLoc) > 30) || ((Current Map == Map(Hollywood)
				|| Current Map == Map(Hollywood Halloween)) && Distance Between(Global.AllBastionPositions[Global.RBPIndex],
				Global.HollywoodSpawns[0]) > 30) || (Current Map == Map(Dorado) && Distance Between(
				Global.AllBastionPositions[Global.RBPIndex], Vector(189.103, 8.041, 42.415)) > 18) || ((Current Map == Map(Ilios)
				|| Current Map == Map(Lijiang Tower) || Current Map == Map(Lijiang Tower Lunar New Year) || Current Map == Map(Oasis)
				|| Current Map == Map(Nepal)) && Distance Between(Global.AllBastionPositions[Global.RBPIndex], Random Value In Array(
				Spawn Points(Team 1))) > 37) || (Current Map == Map(Junkertown) && Distance Between(
				Global.AllBastionPositions[Global.RBPIndex], Random Value In Array(Spawn Points(Team 1))) > 27) || (Current Map == Map(
				Watchpoint: Gibraltar) && Distance Between(Global.AllBastionPositions[Global.RBPIndex], Random Value In Array(Spawn Points(
				Team 1))) > 38) || (Array Contains(Global.RBPDefaultMaps, Current Map) && Distance Between(
				Global.AllBastionPositions[Global.RBPIndex], Random Value In Array(Spawn Points(Team 1))) > 30));
				Global.RBPIndex += 1;
				Teleport(Players In Slot(Global.RBPIndex, Team 2), Global.AllBastionPositions[Global.RBPIndex]);
	}
}

rule("Change Bastion positions when player escapes (RBP)[SR]")
{
	event
	{
		Subroutine;
		NewBastionPosOnEscape;
	}

	actions
	{
		If(Global.BastionPosTypeWS == 3);
			Global.RBPIndex = 0;
			While(Global.RBPIndex < Count Of(Global.AllBastionPositions));
				Call Subroutine(SetNewBastionPosition);
				Wait(0.300, Ignore Condition);
			End;
	}
}

rule("teleport bastions back")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Distance Between(Event Player, Global.AllBastionPositions[Slot Of(Event Player)]) > 2;
	}

	actions
	{
		Teleport(Event Player, Global.AllBastionPositions[Slot Of(Event Player)]);
		Wait(0.100, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Display message to players attempting to shoot Bastion")
{
	event
	{
		Player Took Damage;
		Team 2;
		Bastion;
	}

	conditions
	{
		Attacker.IsWinner == False;
	}

	actions
	{
		Big Message(Attacker, Custom String("I'm invincible! Stop hurting me!"));
		Wait(2, Ignore Condition);
	}
}

rule("Display info about the goal of the game")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		(Event Player.CurrentHero == 0 || Event Player.CurrentHero == 1) == True;
		Event Player.IsInSpawnRoom == True;
	}

	actions
	{
		Small Message(Event Player, Custom String("Goal: Reach the exit with all heroes!"));
		Wait(2.900, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Go to next hero [SR]")
{
	event
	{
		Subroutine;
		NextHero;
	}

	actions
	{
		Event Player.CurrentHero += 1;
		Event Player.TargetHero = Event Player.CurrentHero;
	}
}

rule("winner effects on reach to end")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.IsWinner != True;
		Y Component Of(Position Of(Event Player)) >= Y Component Of(Global.EndPosition);
		((Global.GEChoice == 36 && Event Player == Global.GEAffectedPlayer) || (Global.GEChoice == 29 && Event Player.GEIsAffectedPlayer)
			|| (Global.GEChoice != 36 && Global.GEChoice != 29)) == True;
		"Fail-safe mechanism for server crashes! Prevents usage if above specified percentage"
		Round To Integer(Server Load / 255 * 100, To Nearest) < Global.MaxSafetyServerLoadWS;
		Distance Between(Position Of(Event Player), Vector(X Component Of(Global.EndPosition), Y Component Of(Position Of(Event Player)),
			Z Component Of(Global.EndPosition))) <= 4;
	}

	actions
	{
		Call Subroutine(ResetPlayerSideEffect);
		Call Subroutine(GEPromoteWingman);
		Call Subroutine(OneForAllGoal);
		Call Subroutine(CompleteGlobalEffect);
		Call Subroutine(PromoteHeroRider);
		Respawn(Event Player);
		Wait(0.032, Ignore Condition);
		If(Event Player.CurrentHero < Count Of(Global.HeroList) && Event Player.CurrentHero == Event Player.TargetHero);
			Call Subroutine(NextHero);
		End;
		Event Player.BacktrackDeaths = 0;
		If(Event Player.CurrentHero == Count Of(Global.HeroList));
			Event Player.IsWinner = True;
			Skip If(!Global.HasAllWinnersToCycleWS, 1);
			Global.CurWinnerCount += 1;
			Skip If(Global.HeroDataSaveIndexWS == -1, 1);
			Modify Global Variable(SavedWinners, Append To Array, Custom String("{0}", Event Player));
			Big Message(All Players(Team 1), Custom String("{0} escaped with {1} deaths!!!", Event Player, Event Player.Deaths));
		End;
		Play Effect(All Players(Team 1), Buff Explosion Sound, Color(White), Event Player, 200);
		Call Subroutine(SpawnAtAltLoc);
		Call Subroutine(SavePlayerData);
		"RANDOMIZE BASTION POSITION: On Escape mode"
		Call Subroutine(NewBastionPosOnEscape);
	}
}

rule("goal effects")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Create Effect(All Players(Team 1), Light Shaft, Round To Integer(Server Load / 255 * 100, To Nearest)
			< Global.MaxSafetyServerLoadWS ? Color(Team 1) : Color(Gray), Global.EndPosition, 4, Visible To Position Radius and Color);
		Create Icon(All Players(All Teams), Global.EndPosition + Vector(0, 5, 0), Flag, Visible To and Position, Color(Blue), True);
	}
}

rule("player hud")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsDebugMode == False;
	}

	actions
	{
		If(Global.HeroListTypeWS != 2);
			Create HUD Text(Event Player, Hero Icon String(Global.HeroList[Event Player.TargetHero + 1]), Custom String("Next Hero"),
				Global.HeroList[Event Player.TargetHero + 1], Left, 2, Color(Blue), Color(White), Color(White), Visible To and String,
				Default Visibility);
			Create HUD Text(Event Player, String("{0}: {1}", String("Hero"), !Event Player.IsWinner ? String("{0} / {1}",
				Event Player.CurrentHero + 1, Count Of(Global.HeroList)) : Custom String("Done!")), Null, Null, Left, 0, Color(White), Color(
				White), Color(White), Visible To and String, Default Visibility);
		Else;
			Create HUD Text(Event Player, Hero Icon String(Event Player.IndieHeroList[Event Player.TargetHero + 1]), Custom String(
				"Next Hero"), Event Player.IndieHeroList[Event Player.TargetHero + 1], Left, 2, Color(Blue), Color(White), Color(White),
				Visible To and String, Default Visibility);
			Create HUD Text(Event Player, String("{0}: {1}", String("Hero"), !Event Player.IsWinner ? String("{0} / {1}",
				Event Player.CurrentHero + 1, Count Of(Event Player.IndieHeroList)) : Custom String("Done!")), Null, Null, Left, 0, Color(
				White), Color(White), Color(White), Visible To and String, Default Visibility);
		End;
		Skip If(Global.BacktrackDeathsWS == 0, 1);
		Create HUD Text(Event Player, Custom String("Backtrack Deaths: {0}/{1}, [{2}x]", Event Player.BacktrackDeaths,
			Global.BacktrackDeathsWS, Global.BacktrackSteps), Null, Null, Left, 1, Color(Red), Color(White), Color(White),
			Visible To and String, Default Visibility);
	}
}

rule("Player is in spawn room (CHECK)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		(Is In Spawn Room(Event Player) || ((Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter))
			&& Distance Between(Position Of(Event Player), Global.BlizzWorldSpawnLoc) <= 30) == True || ((Current Map == Map(Hollywood)
			|| Current Map == Map(Hollywood Halloween)) && Distance Between(Position Of(Event Player), Global.HollywoodSpawns[0]) <= 30)
			== True) == True;
	}

	actions
	{
		Event Player.IsInSpawnRoom = True;
	}
}

rule("Player is NOT in spawn room (CHECK)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		(((Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter)) && Distance Between(Position Of(Event Player),
			Global.BlizzWorldSpawnLoc) <= 30) == False && ((Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween))
			&& Distance Between(Position Of(Event Player), Global.HollywoodSpawns[0]) <= 30) == False && !Is In Spawn Room(Event Player))
			== True;
	}

	actions
	{
		Event Player.IsInSpawnRoom = False;
	}
}

rule("infinity game")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is In Setup == False;
	}

	actions
	{
		Wait(300, Ignore Condition);
		Set Match Time(3599);
	}
}

rule("heal")
{
	event
	{
		Player Took Damage;
		Team 1;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Global.GEToggles[0] == False;
		Event Player.IsWinner == False;
	}

	actions
	{
		Stop All Heal Over Time(Event Player);
		Wait(2, Abort When False);
		Play Effect(All Players(All Teams), Buff Impact Sound, Color(Yellow), Event Player, 2);
		Start Heal Over Time(Event Player, Event Player, 9999, 25);
	}
}

rule("deaths counter")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.IsWinner == False;
		Attacker != Null;
		Attacker != Event Player;
	}

	actions
	{
		Event Player.Deaths += 1;
		Call Subroutine(AddBacktrackDeath);
	}
}

rule("Backtrack a hero after many deaths")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.IsWinner == False;
		Global.BacktrackDeathsWS != 0;
		Event Player.BacktrackDeaths >= Global.BacktrackDeathsWS;
	}

	actions
	{
		Respawn(Event Player);
		Call Subroutine(SpawnAtAltLoc);
		Event Player.BacktrackDeaths = 0;
		If(Event Player.CurrentHero != 0);
			Event Player.randBacktrackNum = Random Integer(Global.BacktrackMinMaxListWS[0], Global.BacktrackMinMaxListWS[1]);
			If(Event Player.CurrentHero - Event Player.randBacktrackNum < 0);
				Event Player.CurrentHero = 0;
			Else;
				Event Player.CurrentHero = Event Player.CurrentHero - Event Player.randBacktrackNum;
			End;
			Event Player.TargetHero = Event Player.CurrentHero;
		End;
		Call Subroutine(SavePlayerData);
		Wait(3, Ignore Condition);
		If(Event Player.CurrentHero == 0);
			Small Message(Event Player, Custom String("Backtracked to the very first hero!"));
		Else If(Event Player.randBacktrackNum == 1);
			Small Message(Event Player, Custom String("Backtracked a single hero!"));
		Else If(Event Player.randBacktrackNum >= 7);
			Small Message(Event Player, Custom String("Yikes! Backtracked {0} heroes! Be careful next time!"));
		Else;
			Small Message(Event Player, Custom String("Backtracked {0} heroes!", Event Player.randBacktrackNum));
		End;
	}
}

rule("Increment backtrack death & save [SR]")
{
	event
	{
		Subroutine;
		AddBacktrackDeath;
	}

	actions
	{
		Skip If(Global.BacktrackDeathsWS == 0, 1);
		Event Player.BacktrackDeaths += Global.BacktrackSteps;
		Call Subroutine(SavePlayerData);
	}
}

rule("Destroy D.Va's mech goal HUD")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Is In Alternate Form(Event Player) == False;
		Event Player.H[1] != Null;
	}

	actions
	{
		Call Subroutine(DestroyDVAMechHUD);
	}
}

rule("Destroy goal HUD for D.Va mech [SR]")
{
	event
	{
		Subroutine;
		DestroyDVAMechHUD;
	}

	actions
	{
		If(Event Player.H[1] != Null);
			Wait(0.250, Abort When False);
			Destroy HUD Text(Event Player.H[1]);
			Event Player.H[1] = Null;
	}
}

rule("Create D.Va's goal HUD for mech")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Is In Alternate Form(Event Player) == True;
		Event Player.H[1] == Null;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.M = Position Of(Event Player) * Vector(1, Empty Array, 1);
		Create HUD Text(Event Player, String("{0}: {1}", String("{0} {1}", String("Goal"), String("Distance")), Max(0,
			50 - Distance Between(Position Of(Event Player) * Vector(1, Empty Array, 1), Event Player.M))), Null, Null, Top, 5, Color(
			White), Color(White), Color(White), Visible To and String, Default Visibility);
		Event Player.H[1] = Last Text ID;
	}
}

rule("if D.Va haven't reached 50 meters yet")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Is In Alternate Form(Event Player) == True;
		Is In Spawn Room(Event Player) == False;
		Event Player.H[1] != Null;
		Distance Between(Position Of(Event Player) * Vector(1, Empty Array, 1), Event Player.M) < 50;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 2 * Distance Between(Position Of(Event Player) * Vector(1, Empty Array, 1), Event Player.M));
		Wait(0.100, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("If D.Va passes 50 meters")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Is In Alternate Form(Event Player) == True;
		Is In Spawn Room(Event Player) == False;
		Event Player.H[1] != Null;
		Distance Between(Position Of(Event Player) * Vector(1, Empty Array, 1), Event Player.M) >= 50;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 100);
	}
}

rule("If D.Va calls mech")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Is In Alternate Form(Event Player) == True;
		Ultimate Charge Percent(Event Player) == 100;
		Event Player.H[1] != Null;
	}

	actions
	{
		Allow Button(Event Player, Button(Ultimate));
		Wait(0.400, Ignore Condition);
		"Automatically place D.Va in her mech if she has her ultimate"
		Press Button(Event Player, Button(Ultimate));
		Loop If(Ultimate Charge Percent(Event Player) == 100);
		Disallow Button(Event Player, Button(Ultimate));
	}
}

rule("If D.Va respawns in alternative form")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Is In Spawn Room(Event Player) == True;
		Is In Alternate Form(Event Player) == True;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 100);
	}
}

rule("Removes ult gained from D.Va while in mech")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Is In Alternate Form(Event Player) == False;
		Ultimate Charge Percent(Event Player) > 0;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 0);
	}
}

rule("If D.Va dies")
{
	event
	{
		Player Died;
		Team 1;
		D.Va;
	}

	actions
	{
		Set Move Speed(Event Player, 0);
		Wait(0.300, Ignore Condition);
		If(Is Alive(Event Player) && !Is In Spawn Room(Event Player));
			"This extra respawn is important!!! If Baby D.Va dies while getting into her mech, she will be permanently stuck at spawn point unrendered.  "
			Respawn(Event Player);
		End;
		If(Is In Alternate Form(Event Player) == True);
			Set Ultimate Charge(Event Player, 100);
		Else;
			Call Subroutine(DestroyDVAMechHUD);
			Event Player.H[1] = Null;
		End;
		Set Move Speed(Event Player, 100);
	}
}

rule("destroy hud if player is not D.Va anymore")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Hero Of(Event Player) != Hero(D.Va);
		Event Player.H[1] != Null;
	}

	actions
	{
		Destroy HUD Text(Event Player.H[1]);
		Wait(0.032, Ignore Condition);
		Event Player.H[1] = Null;
	}
}

rule("Create jump pad effects [SR]")
{
	event
	{
		Subroutine;
		CreateJumpPads;
	}

	actions
	{
		If(Global.Y < Count Of(Global.JumpPadLocList) && Global.JumpPadLocList != Empty Array);
			Create Effect(All Players(All Teams), Sparkles, Color(Green), Global.JumpPadLocList[Global.Y], Global.JumpPadRadius, Visible To);
	}
}

rule("Create teleport effects [SR]")
{
	event
	{
		Subroutine;
		CreateTeleporters;
	}

	actions
	{
		If(Global.Y < Count Of(Global.T) && Global.T != Empty Array);
			Skip If(Global.Y % 2 == 0, 1);
			Create Effect(All Players(All Teams), Bad Aura, Color(Red), Global.T[Global.Y], 1, Visible To);
			Skip If(Global.Y % 2 == 1, 1);
			Create Effect(All Players(All Teams), Good Aura, Color(Red), Global.T[Global.Y], 1, Visible To);
	}
}

rule("Chase Y from 0 to 100 to create effects")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.Y == -1;
	}

	actions
	{
		Global.Y += 1;
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		Wait Until(Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)), 99999);
		Call Subroutine(CreateJumpPads);
		Call Subroutine(CreateTeleporters);
		Wait(0.100, Ignore Condition);
		Loop If(Global.Y < 100);
	}
}

rule("If player near a portal")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.T != Empty Array;
		Is True For Any(Global.T, Distance Between(Current Array Element, Position Of(Event Player)) < 1.500) == True;
	}

	actions
	{
		Event Player.W = Filtered Array(Global.T, Distance Between(Current Array Element, Position Of(Event Player)) < 1.500);
		Skip If(Index Of Array Value(Global.T, Event Player.W) % 2 == 1, 1);
		Teleport(Event Player, Global.T[Index Of Array Value(Global.T, Event Player.W) + 1]);
		Play Effect(All Players(All Teams), Buff Impact Sound, Color(Yellow), Event Player, 1);
	}
}

rule("If player near a jump pad")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.JumpPadLocList != Empty Array;
		Is True For Any(Global.JumpPadLocList, Distance Between(Current Array Element, Position Of(Event Player)) <= Global.JumpPadRadius)
			== True;
	}

	actions
	{
		Apply Impulse(Event Player, Up, Global.JumpPadPowerList[Index Of Array Value(Global.JumpPadLocList, First Of(Filtered Array(
			Global.JumpPadLocList, Distance Between(Position Of(Event Player), Current Array Element) < Global.JumpPadRadius)))], To World,
			Cancel Contrary Motion);
		Play Effect(All Players(Team 1), Buff Impact Sound, Color(White), Event Player, 50);
	}
}

rule("Create current hero HUD (pl h)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.CurrentHero != Event Player.TargetHero;
	}

	actions
	{
		Wait(Random Real(0, 0.100), Ignore Condition);
		Create HUD Text(Event Player, Hero Icon String(Global.HeroList[Event Player.CurrentHero]), Custom String("Current Hero"),
			Global.HeroList[Event Player.CurrentHero], Left, 4, Color(Green), Color(White), Color(White), Visible To and String,
			Default Visibility);
		Event Player.H[0] = Last Text ID;
	}
}

rule("Destroy current hero HUD (pl h)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.CurrentHero == Event Player.TargetHero;
		First Of(Event Player.H) != Null;
	}

	actions
	{
		Destroy HUD Text(First Of(Event Player.H));
		Event Player.H[0] = Null;
	}
}

disabled rule("no dmg (debug)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsDebugMode == True;
	}

	actions
	{
		Set Status(Event Player, Null, Invincible, 9999);
	}
}

disabled rule("speed (debug)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Global.IsDebugMode == True;
	}

	actions
	{
		Set Move Speed(Event Player, 200);
		Set Projectile Speed(Event Player, 200);
	}
}

disabled rule("All positions (debug)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.IsDebugMode == True;
	}

	actions
	{
		Create HUD Text(All Players(All Teams), String("{0}: {1}", Event Player, Position Of(Event Player)), Null, Null, Left, 0, Color(
			White), Color(White), Color(White), Visible To and String, Default Visibility);
	}
}

disabled rule("Ball position (debug)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsDebugMode == True;
		Host Player == Event Player;
	}

	actions
	{
		Create HUD Text(Host Player, Custom String("Ball Position: {0}", Global.GEBallPosition), Null, Null, Left, 0, Color(White), Color(
			White), Color(White), Visible To and String, Default Visibility);
	}
}

disabled rule("======== set debug mode on/off")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.IsDebugMode = True;
		Enable Inspector Recording;
	}
}

disabled rule("Last Hero (debug)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsDebugMode == True;
	}

	actions
	{
		Event Player.CurrentHero = 31;
		Event Player.TargetHero = Event Player.CurrentHero;
	}
}

disabled rule("Fast Hero (debug)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsDebugMode == True;
		Is Button Held(Event Player, Button(Melee)) == True;
	}

	actions
	{
		If(Event Player.CurrentHero < 31);
			Call Subroutine(NextHero);
			Wait(0.625, Ignore Condition);
	}
}

rule("Add Bastion Bots")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Count Of(Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Bastion))) < Global.BastionBotCount;
	}

	actions
	{
		Create Dummy Bot(Hero(Bastion), Team 2, -1, Random Value In Array(Spawn Points(Team 2)), Left - Left);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("No Hud")
{
	event
	{
		Player Joined Match;
		Team 1;
		All;
	}

	actions
	{
		Disable Game Mode HUD(Event Player);
		Disable Kill Feed(Event Player);
		Disable Scoreboard(Event Player);
		Disable Built-In Game Mode Respawning(Event Player);
	}
}

rule("Rename Bastion On Join")
{
	event
	{
		Player Joined Match;
		Team 2;
		Bastion;
	}

	actions
	{
		Start Forcing Dummy Bot Name(Event Player, Custom String("BASTION {0}", Slot Of(Event Player) + 1));
	}
}

rule("Bastion Bot Enemy Search")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Event Player.temp = Filtered Array(All Living Players(Team 1), (Is In Line of Sight(Eye Position(Event Player), Eye Position(
			Current Array Element), Barriers Do Not Block LOS) == True || Is In Line of Sight(Eye Position(Event Player), Position Of(
			Current Array Element), Barriers Do Not Block LOS) == True) && Has Spawned(Current Array Element)
			&& !Current Array Element.IsWinner && (Hero Of(Current Array Element) != Hero(Sombra) || !Is Using Ability 1(
			Current Array Element)) && (Hero Of(Current Array Element) != Hero(Reaper) || !Is Using Ability 1(Current Array Element)) && (
			Hero Of(Current Array Element) != Hero(Moira) || !Is Using Ability 1(Current Array Element)));
		Wait(0.016, Ignore Condition);
		Event Player.Enemy = Random Value In Array(Event Player.temp);
		Wait(Random Real(0.256, 0.512), Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Bastion Bot Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Event Player.Enemy != Null;
		Is Button Held(Event Player, Button(Primary Fire)) == False;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Primary Fire));
	}
}

rule("Bastion Bot Stop Fire")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Event Player.Enemy == Null;
	}

	actions
	{
		Stop Holding Button(Event Player, Button(Primary Fire));
	}
}

rule("Bastion Bot Aim Position")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Event Player.Enemy != Null;
	}

	actions
	{
		Event Player.TempAimPosition = Vector(X Component Of(Eye Position(Event Player.Enemy)), Y Component Of(Position Of(
			Event Player.Enemy)) + (Y Component Of(Eye Position(Event Player.Enemy)) - Y Component Of(Position Of(Event Player.Enemy)))
			/ 2, Z Component Of(Eye Position(Event Player.Enemy)));
		If(Is In Line of Sight(Eye Position(Event Player), Event Player.TempAimPosition, Barriers Do Not Block LOS) == True);
			Event Player.AimPosition = Event Player.TempAimPosition;
		Else;
			If(Is In Line of Sight(Eye Position(Event Player), Eye Position(Event Player.Enemy), Barriers Do Not Block LOS) == True);
				Event Player.AimPosition = Eye Position(Event Player.Enemy);
			Else;
				Event Player.AimPosition = Position Of(Event Player.Enemy);
			End;
		End;
		Wait(0.032, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Bastion Bot Aim Position 2")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Event Player.Enemy == Null;
	}

	actions
	{
		Event Player.EnemyUnSeen = First Of(Sorted Array(Filtered Array(All Living Players(Opposite Team Of(Team Of(Event Player))),
			Has Spawned(Current Array Element) && Event Player.IsWinner != True && (Hero Of(Current Array Element) != Hero(Sombra)
			|| !Is Using Ability 1(Current Array Element))), Distance Between(Eye Position(Event Player), Eye Position(
			Current Array Element))));
		Skip If(Event Player.EnemyUnSeen == Null, 1);
		Event Player.AimPosition = Eye Position(Event Player.EnemyUnSeen) + Vector(Random Real(-1, 1), Random Real(-1, 1), Random Real(-1,
			1));
		Wait(Random Real(1, 4), Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Bastion Bot Aim Smoother")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Event Player.Enemy != Null;
	}

	actions
	{
		Event Player.TurnSpeed = Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player),
			Eye Position(Event Player.Enemy))) * 6;
		Event Player.TurnSpeed += Speed Of(Event Player.Enemy) * 6;
		Wait(Server Load Average / 1000, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Bastion Bot Aim Smoother 2")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Event Player.Enemy == Null;
		Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Position Of(
			Event Player.AimPosition))) >= 1;
	}

	actions
	{
		Event Player.TurnSpeed = Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player),
			Position Of(Event Player.AimPosition))) * 7;
		Wait(Server Load Peak / 1000, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Bastion Bot Start Facing")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Event Player.AimPosition), Has Status(Event Player,
			Asleep) ? 0 : Event Player.TurnSpeed, To World, Direction and Turn Rate);
	}
}

rule("Bastion Bot Hello")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
		Is Communicating(Player Closest To Reticle(Event Player, Opposite Team Of(Team Of(Event Player))), Hello) == True;
	}

	actions
	{
		Wait(Random Real(1, 3), Ignore Condition);
		Communicate(Event Player, Hello);
	}
}

rule("Bastion Bot Hello 2")
{
	event
	{
		Player Earned Elimination;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
		Random Integer(1, 3) == 1;
	}

	actions
	{
		Wait(Random Real(1, 3), Ignore Condition);
		Communicate(Event Player, Hello);
	}
}

rule("Bastion Bot NULL ENEMY")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Is Alive(Event Player.Enemy) == False;
	}

	actions
	{
		Event Player.Enemy = Null;
		Event Player.EnemyUnSeen = Null;
	}
}

rule("Sombra Text")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Sombra;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Event Player.Invis = 100;
		Destroy Progress Bar HUD Text(Event Player.InvisibleText);
		Wait(0.032, Ignore Condition);
		Create Progress Bar HUD Text(Event Player.Invis < 100 ? Event Player : Null, Event Player.Invis, Custom String("{0} INVISIBILITY",
			Ability Icon String(Hero(Sombra), Button(Ability 1))), Top, 6, Color(Purple), Color(White), Visible To Values and Color,
			Default Visibility);
		Event Player.InvisibleText = Last Text ID;
	}
}

rule("Sombra Limited Ability 1")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Sombra;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Skip If(Event Player.Invis > 1, 1);
		Press Button(Event Player, Button(Ability 1));
		Skip If(Event Player.Invis <= 0, 1);
		Event Player.Invis -= 0.128;
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Sombra Limited Ability 2")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Sombra;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
		Is Using Ability 1(Event Player) == False;
		Event Player.Invis < 100;
	}

	actions
	{
		Event Player.Invis += 0.128;
		Wait(0.032, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Sombra Remove Text")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
		Hero Of(Event Player) != Hero(Sombra);
	}

	actions
	{
		Destroy Progress Bar HUD Text(Event Player.InvisibleText);
		Event Player.Invis = 100;
	}
}

rule("Spawn Dead Players (ENEMY)")
{
	event
	{
		Player Died;
		Team 2;
		All;
	}

	conditions
	{
		Is Dead(Event Player) == True;
	}

	actions
	{
		Wait(0.048, Abort When False);
		Respawn(Event Player);
	}
}

rule("Spawn Dead Players (PLAYERS)")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		Is Dead(Event Player) == True;
	}

	actions
	{
		Disable Built-In Game Mode Respawning(Event Player);
		If(Is True For Any(All Players(Team 1), Hero Of(Current Array Element) == Hero(Mercy) && !Current Array Element.IsWinner));
			Wait(6, Abort When False);
		Else If(Is True For Any(All Players(Team 1), Hero Of(Current Array Element) == Hero(Mercy) && Current Array Element.IsWinner));
			Wait(4, Abort When False);
		Else;
			Wait(0.048, Abort When False);
		End;
		Respawn(Event Player);
		If(Hero Of(Event Player) == Hero(Tracer));
			Set Ability Cooldown(Event Player, Button(Ability 2), 5);
		Else If(Hero Of(Event Player) == Hero(Sombra) && Is Using Ability 2(Event Player));
			Press Button(Event Player, Button(Interact));
		Else If(Hero Of(Event Player) == Hero(Symmetra) && Is Using Ability 2(Event Player));
			Press Button(Event Player, Button(Ability 2));
		End;
	}
}

rule("Show Bastions Position")
{
	event
	{
		Player Dealt Final Blow;
		Team 2;
		All;
	}

	actions
	{
		Start Forcing Dummy Bot Name(Event Player, Custom String("BASTION {0}", Slot Of(Event Player) + 1));
		Start Forcing Player Outlines(Attacker, Victim, True, Color(Red), Always);
		Wait(12, Ignore Condition);
		Stop Forcing Player Outlines(Attacker, Victim);
	}
}

rule("Sym broke teleport")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Symmetra;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Wait(0.256, Ignore Condition);
		Press Button(Event Player, Button(Ability 2));
	}
}

rule("Sym tel limit")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Symmetra;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Wait(1, Ignore Condition);
		Skip If(!Is Using Ability 2(Event Player), 1);
		Press Button(Event Player, Button(Ability 2));
		Loop If Condition Is True;
	}
}

rule("Update Escape Status Board (Scoreboard)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.ShowEscapeStatusWS == True;
	}

	actions
	{
		Global.EscapeBoardStats[0] = Sorted Array(Filtered Array(All Players(Team 1), Current Array Element.IsWinner == False),
			0 - Current Array Element.CurrentHero);
		Global.EscapeBoardStats[1] = First Of(Global.EscapeBoardStats[0]);
		Global.EscapeBoardStats[2] = Global.EscapeBoardStats[0][1];
		Global.EscapeBoardStats[3] = Global.EscapeBoardStats[0][2];
		Wait(Random Real(2, 4), Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("SPAWN FIX")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		(Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter)) == True;
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Teleport(Event Player, Vector(-166.920, 2.948, 97.847));
		Set Facing(Event Player, Forward, To World);
	}
}

rule("Saving Player Data [SR]")
{
	event
	{
		Subroutine;
		SavePlayerData;
	}

	actions
	{
		If((Event Player.CurrentHero >= Global.HeroDataSaveIndexWS && Global.HeroDataSaveIndexWS != -1) || Array Contains(
			Global.SavedIndex, Custom String("{0}", Event Player)));
			"We're saving data as string, because we cant hold entity id's but we can hold entity names as string."
			Skip If(Array Contains(Global.SavedIndex, Custom String("{0}", Event Player)), 1);
			Modify Global Variable(SavedIndex, Append To Array, Custom String("{0}", Event Player));
			Wait(0.032, Ignore Condition);
			Global.SavedHero[Index Of Array Value(Global.SavedIndex, Custom String("{0}", Event Player))] = Event Player.CurrentHero;
			Global.SavedDeaths[Index Of Array Value(Global.SavedIndex, Custom String("{0}", Event Player))] = Event Player.Deaths;
			Global.SavedBacktrackDeaths[Index Of Array Value(Global.SavedIndex, Custom String("{0}", Event Player))
				] = Event Player.BacktrackDeaths;
			Call Subroutine(PlaySaveUnlockedMSG);
			Small Message(Event Player, Custom String("YOUR PROGRESS DATA WAS SAVED TO SERVER"));
	}
}

rule("Loading Player Data")
{
	event
	{
		Player Joined Match;
		Team 1;
		All;
	}

	conditions
	{
		Global.HeroDataSaveIndexWS != -1;
		Array Contains(Global.SavedIndex, Custom String("{0}", Event Player)) == True;
	}

	actions
	{
		Event Player.CurrentHero = Global.SavedHero[Index Of Array Value(Global.SavedIndex, Custom String("{0}", Event Player))];
		Event Player.TargetHero = Event Player.CurrentHero;
		Event Player.IsWinner = Array Contains(Global.SavedWinners, Custom String("{0}", Event Player));
		Skip If(Event Player.CurrentHero < Global.HeroDataSaveIndexWS, 1);
		Event Player.Deaths = Global.SavedDeaths[Index Of Array Value(Global.SavedIndex, Custom String("{0}", Event Player))];
		Skip If(Global.BacktrackDeathsWS == 0, 1);
		Event Player.BacktrackDeaths = Global.SavedBacktrackDeaths[Index Of Array Value(Global.SavedIndex, Custom String("{0}",
			Event Player))];
		Wait Until(Has Spawned(Event Player), 99999);
		Skip If(Event Player.CurrentHero < Global.HeroDataSaveIndexWS, 1);
		Big Message(Event Player, Custom String("Welcome Back, {0}!", Event Player));
		Call Subroutine(PlaySaveUnlockedMSG);
		Small Message(Event Player, Custom String("YOUR PROGRESS DATA WAS SUCCESSFULLY LOADED FROM THE SERVER"));
		Small Message(Filtered Array(All Players(Team 1), Event Player != Current Array Element), Custom String("HERO {0} LOADED FOR {1}",
			Hero Icon String(Global.HeroList[Event Player.CurrentHero]), Event Player));
	}
}

rule("Display save feature unlocked message [SR]")
{
	event
	{
		Subroutine;
		PlaySaveUnlockedMSG;
	}

	actions
	{
		If(Event Player.CurrentHero == Global.HeroDataSaveIndexWS && !Event Player.hasPlayedSaveMessage);
			Big Message(Event Player, Custom String("Unlocked Save Feature!"));
			Wait(3, Ignore Condition);
		End;
		Event Player.hasPlayedSaveMessage = True;
	}
}

rule("Green outlines for winners")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Event Player.IsWinner == True;
	}

	actions
	{
		Call Subroutine(ApplyWinnerStats);
	}
}

rule("Apply winner outlines [SR]")
{
	event
	{
		Subroutine;
		ApplyWinnerStats;
	}

	actions
	{
		If(Event Player.IsWinner);
			Start Forcing Player Outlines(Event Player, All Players(Team 1), True, Color(Green), Always);
			Disable Nameplates(Event Player, All Players(Team 1));
			Set Move Speed(Event Player, 120);
			If(Event Player.WinnerDeathID == Null);
				Create HUD Text(Event Player, Custom String("Total Deaths: {0}", Event Player.Deaths), Null, Null, Left, 2, Color(Turquoise),
					Color(White), Color(White), Visible To, Default Visibility);
				Event Player.WinnerDeathID = Last Text ID;
	}
}

rule("force player hero")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.IsWinner == False;
		Is Dummy Bot(Event Player) == False;
		((Global.HeroListTypeWS != 2 && Hero Of(Event Player) != Global.HeroList[Event Player.CurrentHero]) || (
			Global.HeroListTypeWS == 2 && Hero Of(Event Player) != Event Player.IndieHeroList[Event Player.CurrentHero])) == True;
	}

	actions
	{
		If(Global.HeroListTypeWS != 2);
			Start Forcing Player To Be Hero(Event Player, Global.HeroList[Event Player.CurrentHero]);
			Wait(0.250, Ignore Condition);
			Preload Hero(Event Player, Array Slice(Global.HeroList, Event Player.CurrentHero + 1, 12));
		Else;
			Start Forcing Player To Be Hero(Event Player, Event Player.IndieHeroList[Event Player.CurrentHero]);
			Wait(0.250, Ignore Condition);
			Preload Hero(Event Player, Array Slice(Event Player.IndieHeroList, Event Player.CurrentHero + 1, 12));
		End;
		Loop If Condition Is True;
		Small Message(Filtered Array(All Players(Team 1), Current Array Element != Event Player), Custom String("{0} is now {1}!",
			Event Player, Hero Icon String(Hero Of(Event Player))));
	}
}

rule("force winner player hero")
{
	event
	{
		Player Joined Match;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.IsWinner == True;
		((Global.HeroListTypeWS != 2 && Event Player.CurrentHero == Count Of(Global.HeroList)) || (
			Global.HeroListTypeWS == 2 && Event Player.CurrentHero == Count Of(Event Player.IndieHeroList))) == True;
	}

	actions
	{
		If(Global.HeroListTypeWS != 2);
			Start Forcing Player To Be Hero(Event Player, Last Of(Global.HeroList));
		Else;
			Start Forcing Player To Be Hero(Event Player, Last Of(Event Player.IndieHeroList));
		End;
		Start Forcing Player Outlines(Event Player, All Players(Team 1), True, Color(Green), Always);
	}
}

rule("Player reset button combo shortcut (BUTTONS)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Reload)) == True;
		Is Button Held(Event Player, Button(Jump)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
	}

	actions
	{
		Small Message(Event Player, Custom String("Teleporting to spawn. Continue Holding!"));
		If(!Event Player.IsWinner);
			Wait(5, Abort When False);
		Else;
			Wait(3, Abort When False);
		End;
		Respawn(Event Player);
		Call Subroutine(SpawnAtAltLoc);
	}
}

disabled rule("Spawn a lot of friendly soldiers. Stress Test (debug)")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Call Subroutine(SpawnFriendlySoldier);
		Call Subroutine(SpawnFriendlySoldier);
	}
}

rule("spawn a friendly soldier (debug)[SR]")
{
	event
	{
		Subroutine;
		SpawnFriendlySoldier;
	}

	actions
	{
		Wait(10, Ignore Condition);
		Create Dummy Bot(Hero(Soldier: 76), Team 1, -1, Eye Position(Host Player) + Facing Direction Of(Host Player) * 5,
			Facing Direction Of(Host Player) * -1);
		Wait(5, Ignore Condition);
		Teleport(Players In Slot(1, Team 1), Position Of(Players In Slot(0, Team 1)));
	}
}

rule("Global Effect (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.GEChoice == 0;
	}

	actions
	{
		"\"DEACTIVATE if not debugging\""
		disabled Call Subroutine(SpawnFriendlySoldier);
		If(Global.IsGEIntervalRandomWS);
			Wait(Random Integer(0.500 * Global.GEIntervalWS, 1.500 * Global.GEIntervalWS), Ignore Condition);
		Else;
			Wait(Global.GEIntervalWS, Ignore Condition);
		End;
		Call Subroutine(SelectGlobalEffect);
	}
}

rule("Select a global effect & configurate (GE)[SR]")
{
	event
	{
		Subroutine;
		SelectGlobalEffect;
	}

	actions
	{
		Global.TempVar = Random Integer(1, 54);
		Global.GEMinPlayerReq = 1;
		"Current NUMBER of players currently around. Used if global effect requires more than 1 player"
		Global.TempVar2 = 1;
		"DEBUG: Chose a specific global effect"
		disabled Global.TempVar = 49;
		If(Global.TempVar == 1 || Global.TempVar == 51);
			Global.GEMinPlayerReq = 2;
			"The Patrol Guard to use"
			Global.GEPatrolChoice = Random Integer(0, 5);
			"DEBUGGING: Deactivate if not trying to debug this Global Effect"
			disabled Global.GEPatrolChoice = 4;
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Is In Spawn Room(Current Array Element)
				&& !Current Array Element.IsWinner));
			Global.TempVar3 = Custom String("Incoming patrols are here to cause mayhem!");
			Global.GEName = Custom String("Patrol Guards!");
			"Set the timer for the Global Effect"
			Call Subroutine(SetPatrolDuration);
		Else If(Global.TempVar == 2);
			Global.GEName = Custom String("Drug Packs!");
			Global.GEToggles[2] = !Global.GEToggles[2];
			Global.TempVar3 = Custom String("Health Packs [{0}] side effects!", Global.GEToggles[2] ? Custom String("introduces")
				: Custom String("no longer causes"));
		Else If(Global.TempVar == 3);
			Global.TempVar3 = Custom String("The floor is HOT! Stay in the air!");
			Global.GEName = Custom String("Lava Floor!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(15, 40);
		Else If(Global.TempVar == 4);
			Global.GEMinPlayerReq = 2;
			Global.TempVar3 = Custom String("Some players will switch places!");
			"Switcharoo"
			Global.TempVar2 = Count Of(All Players(Team 1));
			Global.GEName = Custom String("Switcharoo!");
		Else If(Global.TempVar == 5);
			Global.TempVar3 = Custom String("Some players will be sent back to spawn. Yikes!");
			Global.GEName = Custom String("Oof Teleport!");
		Else If(Global.TempVar == 6);
			Global.TempVar3 = Custom String("Some players are invincible!");
			Global.GEName = Custom String("Invincible!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(10, 20);
		Else If(Global.TempVar == 7);
			Global.TempVar3 = Custom String("Say 'Hello','Thanks', 'No', etc. Wait 5 seconds \nbefore each usage.\n\n(Voice pitch changes).");
			Global.GEName = Custom String("Communicate or Die!");
			"Amount of times to communicate"
			Global.GERequiredNum = Random Integer(1, 5);
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Global.GERequiredNum * 6 + 10;
		Else If(Global.TempVar == 8);
			Global.TempVar3 = Custom String("Stay away from certain players, otherwise you will explode!");
			"I'm the bomb"
			Global.TempVar2 = Count Of(Filtered Array(All Living Players(Team 1), !Is In Spawn Room(Current Array Element)
				&& !Current Array Element.IsWinner));
			Global.GEMinPlayerReq = 2;
			Global.GEName = Custom String("I'm the Bomb!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(15, 20);
			"Bomb explosion radius"
			Global.GERadius = Random Integer(14, 22);
		Else If(Global.TempVar == 9);
			"Passenger"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.TempVar3 = Custom String("You are slow! Stay near a teammate to go FAST!");
			Global.GEMinPlayerReq = 3;
			Global.GEName = Custom String("Passenger!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 180);
			"Buff range"
			Global.GERadius = 4;
		Else If(Global.TempVar == 10 || Global.TempVar == 54);
			Global.BUChoices[3] = Random Value In Array(Filtered Array(Array(0, 1, 2, 3), Current Array Element != Global.BUChoices[3]));
			Global.TempVar3 = Custom String("Bastion receives [{0}] buff!", Global.BUChoices[3] == 1 ? Custom String("Projectile Speed") : (
				Global.BUChoices[3] == 2 ? Custom String("Damage Boost") : (Global.BUChoices[3] == 3 ? Custom String("Ample Damage Boost")
				: String("No"))));
			Global.GEName = Custom String("Bastion Buff Upgrade!");
		Else If(Global.TempVar == 11);
			Global.TempVar3 = Custom String("Bastion will spawn on top of a player. Watch out!");
			"Bastion Drop"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1),
				!Current Array Element.IsWinner && !Current Array Element.IsInSpawnRoom));
			Global.GEMinPlayerReq = 3;
			Global.GEName = Custom String("Bastion Drop!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 120);
		Else If(Global.TempVar == 12);
			Global.GEMinPlayerReq = 2;
			"Hacked"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.TempVar3 = Custom String("Some players are HACKED!");
			Global.GEName = Custom String("Hacked!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(20, 50);
		Else If(Global.TempVar == 13);
			Global.TempVar3 = Custom String("Emote or you will surely die!");
			Global.GEName = Custom String("Emote or Die!");
			Global.GERequiredNum = Random Integer(1, 3);
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Global.GERequiredNum * 6 + 10;
		Else If(Global.TempVar == 14);
			Global.GEMinPlayerReq = 2;
			"Personal Space"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Is In Spawn Room(Current Array Element)
				&& !Current Array Element.IsWinner));
			Global.TempVar3 = Custom String("Some players need space! They will push you away \nif you come too close.");
			Global.GEName = Custom String("Personal Space!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 90);
			"Amount of personal space"
			Global.GERadius = Random Integer(12, 21);
		Else If(Global.TempVar == 15);
			Global.TempVar3 = Custom String(
				"Use voice lines or die! Wait at least 5 seconds before each voice line.\n\n(Voice pitch changes)");
			Global.GEName = Custom String("Voice Line or Die!");
			Global.GERequiredNum = Random Integer(1, 5);
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Global.GERequiredNum * 6 + 10;
		Else If(Global.TempVar == 16);
			Global.TempVar3 = Custom String("All Bastions are deactivated!");
			Global.GEName = Custom String("Deactivated Bastions!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(5, 12);
		Else If(Global.TempVar == 17);
			Global.TempVar3 = Custom String("Beware! When a player dies everyone nearby will too.");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 180);
			Global.GEName = Custom String("Die with Me!");
			Global.GEMinPlayerReq = 2;
			Global.TempVar2 = Count Of(All Players(Team 1));
			Global.GERadius = 8;
		Else If(Global.TempVar == 18);
			Global.TempVar3 = Custom String("Your max health has been increased!");
			Global.GEName = Custom String("More Health!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(45, 180);
		Else If(Global.TempVar == 19);
			Global.GEMinPlayerReq = 2;
			Global.TempVar3 = Custom String("Some players are Medusa's servants. Don't look at them!");
			Global.GEName = Custom String("Medusa!");
			"Medusa"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Is In Spawn Room(Current Array Element)
				&& !Current Array Element.IsWinner));
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 180);
			"Players' vision"
			Global.GEViewAngle = 45;
		Else If(Global.TempVar == 20);
			Global.TempVar2 = Count Of(All Players(Team 1));
			Global.TempVar3 = Custom String("Players are invisible and can phase through \nobjects!");
			Global.GEName = Custom String("Friendly Ghosts!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 150);
			Global.GEMinPlayerReq = 2;
		Else If(Global.TempVar == 21);
			"Sleepy Tbags"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.GEMinPlayerReq = 3;
			Global.TempVar3 = Custom String("TBag sleeping players to wake them and gain movement speed.");
			Global.GEName = Custom String("Sleepy TBags!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 120);
			"Tbag radius"
			Global.GERadius = 1.800;
			"TBag amount"
			Global.GERequiredNum = 5;
		Else If(Global.TempVar == 22);
			"Piggyback"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.GEMinPlayerReq = 2;
			Global.TempVar3 = Custom String("Some players can now carry other players.\nCarry limit is 1.");
			Global.GEName = Custom String("Piggyback!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 160);
			Global.GEViewAngle = 45;
			Global.GEMeleeDistance = 3;
		Else If(Global.TempVar == 23);
			"Guardian Angel"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.TempVar3 = Custom String(
				"Some players have guardian angels.\nInstead of dying, the guardian angel will take the blow instead.");
			Global.GEMinPlayerReq = 2;
			Global.GEName = Custom String("Guardian Angel!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 120);
		Else If(Global.TempVar == 24);
			"Wingman"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.GEMinPlayerReq = 2;
			Global.TempVar3 = Custom String("Stick close to your wingman!");
			Global.GEName = Custom String("Wingman!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 180);
			"Tether Distance"
			Global.GERadius = 7;
		Else If(Global.TempVar == 25);
			"Staring Contest"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.GEMinPlayerReq = 3;
			Global.TempVar3 = Custom String("Players alternate staring at each other.");
			Global.GEName = Custom String("Staring Contest!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 150);
		Else If(Global.TempVar == 26);
			Global.GEMinPlayerReq = 3;
			"World Tag"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.TempVar3 = Custom String(
				"A Tagger is chosen. The Tagger must tag players \nwho have NOT been tagged before.\n\nThe penalty is demotion!!!");
			Global.GEName = Custom String("World Tag!");
			Global.GERequiredNum = Random Integer(1, Global.TempVar2 - 1);
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Global.GERequiredNum * 20 + 8;
			Global.GEMeleeDistance = 3;
			Global.GEViewAngle = 45;
		Else If(Global.TempVar == 27);
			Global.TempVar3 = Custom String("Some players are bugs! Don't squish them!");
			Global.GEName = Custom String("Bugs!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 90);
			Global.GERadius = 2;
		Else If(Global.TempVar == 28);
			Global.TempVar3 = Custom String("Players jump high & fall slowly.");
			Global.GEName = Custom String("Leap Frog!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 90);
		Else If(Global.TempVar == 29);
			"President"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.TempVar3 = Custom String("Exit Closed! Escort the President to the exit.");
			Global.GEName = Custom String("President!");
			Global.GEMinPlayerReq = 3;
			"Set the timer for the Global Effect"
			Global.GEWaitTime = 100000000;
		Else If(Global.TempVar == 30);
			Global.TempVar3 = Custom String("The Target must hit the ball to deflect it! \n(Ball resets at spawn.)");
			"Hot Potato"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.GEMinPlayerReq = 2;
			Global.GEName = Custom String("Extreme Pong!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(50, 150);
			"Potato Speed"
			Call Subroutine(GESetPongBallSpeed);
			"Potato size"
			Global.GERadius = 3;
			"Initial potato position"
			Global.GEBallPosition = Vector(0, -110, 0);
			Global.GEMeleeDistance = 3;
		Else If(Global.TempVar == 31);
			Global.TempVar3 = Custom String("All players will randomly be placed in random locations.");
			Global.GEName = Custom String("I'm Lagging!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 90);
		Else If(Global.TempVar == 32);
			Global.TempVar2 = Count Of(All Players(Team 1));
			Global.TempVar3 = Custom String("All players will teleport to a chosen player.");
			Global.GEName = Custom String("Group Up!");
			Global.GEMinPlayerReq = 3;
		Else If(Global.TempVar == 33);
			"Toggle on/off self-healing regeneration"
			Global.GEToggles[0] = !Global.GEToggles[0];
			Global.TempVar3 = Custom String("Self-healing is [{0}].", Global.GEToggles[0] ? Custom String("no longer active") : Custom String(
				"now active"));
			Global.GEName = Custom String("I Need Healing!");
		Else If(Global.TempVar == 34 || Global.TempVar == 52);
			Call Subroutine(BeforeNewBastionBulletUpgrade);
			Global.BUChoices[0] = Random Value In Array(Filtered Array(Array(0, 1, 2, 3, 4, 5, 6),
				Current Array Element != Global.BUChoices[0]));
			"DEBUGGING only"
			disabled Global.BUChoices[0] = 4;
			"Tank Shell Type"
			If(Global.BUChoices[0] == 4);
				Global.BUChoices[2] = Random Integer(0, 4);
			End;
			Global.GEName = Custom String("Bastion Bullet Upgrade!");
			Global.TempVar3 = Custom String("Bastions' bullets has been upgraded to [{0}]!", Global.BUChoices[0] == 1 ? Custom String(
				"Knockback Bullets") : (Global.BUChoices[0] == 2 ? Custom String("Flame Bullets") : (Global.BUChoices[0] == 3 ? Custom String(
				"Warp Bullets") : (Global.BUChoices[0] == 4 ? Custom String("Tank Shells") : (Global.BUChoices[0] == 5 ? Custom String(
				"Concussion Bullets") : (Global.BUChoices[0] == 6 ? Custom String("Shock Bullets") : Custom String("None")))))));
		Else If(Global.TempVar == 35);
			Global.TempVar3 = Custom String("Incremental value for backtrack deaths has changed.");
			Global.GEName = Custom String("Blood Sacrifice!");
		Else If(Global.TempVar == 36);
			Global.GEMinPlayerReq = 3;
			Global.TempVar3 = Custom String("The exit is locked! Find the key (blue orb)! It emits sound.");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = 100000000;
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.GEName = Custom String("Lockdown!");
			Global.GERadius = 1;
		Else If(Global.TempVar == 37);
			Global.TempVar3 = Custom String("Alternating game speed!");
			Global.GEName = Custom String("Warped Slo-mo!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 90);
		Else If(Global.TempVar == 38);
			Global.GEMinPlayerReq = 3;
			Global.TempVar3 = Custom String("Avoid spotlight or risk teleporting to a Bastion!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(160, 250);
			Global.GEBallPosition = Nearest Walkable Position(Random Value In Array(Spawn Points(Team 2)));
			Global.GEBallSpeed = 2.560;
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.GEName = Custom String("Spotlight!");
			Global.GERadius = 6.600;
		Else If(Global.TempVar == 39);
			Global.TempVar3 = Custom String("The winds are blowing strong!");
			Global.GEName = Custom String("Strong Winds!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 120);
		Else If(Global.TempVar == 40);
			Global.GECameraChoice = Random Integer(0, 3);
			"DEBUGGING ONLY: Selects a camera view"
			disabled Global.GECameraChoice = 3;
			Global.TempVar3 = Custom String("Camera is now in [{0}] mode!", Global.GECameraChoice == 0 ? Custom String("3rd-person") : (
				Global.GECameraChoice == 1 ? Custom String("top-down") : (Global.GECameraChoice == 2 ? Custom String("selfie") : Custom String(
				"cinematic"))));
			Global.GEName = Custom String("Wacky Camera!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 120);
		"Space Propulsion"
		Else If(Global.TempVar == 41);
			Global.TempVar3 = Custom String("Zero gravity! Propel yourself to move!");
			Global.GEName = Custom String("Space Propulsion!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 120);
		Else If(Global.TempVar == 42);
			Global.TempVar3 = Custom String("Bastions are revealed!");
			Global.GEName = Custom String("Reveal!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 120);
		Else If(Global.TempVar == 43 || Global.TempVar == 53);
			Global.BUChoices[1] = Random Value In Array(Filtered Array(Array(0, 1, 2, 3, 4), Current Array Element != Global.BUChoices[1]));
			Global.GEName = Custom String("Bastion Extra Upgrade!");
			"DEBUGGING only"
			disabled Global.BUChoices[1] = 6;
			Global.TempVar3 = Custom String("Bastion receives an extra upgrade! [{0}]", Global.BUChoices[1] == 1 ? Custom String("Camo") : (
				Global.BUChoices[1] == 2 ? Custom String("Bastion Jr.") : (Global.BUChoices[1] == 3 ? Custom String("Bastion Sr.") : (
				Global.BUChoices[1] == 4 ? Custom String("Shining Armor") : Custom String("None")))));
		Else If(Global.TempVar == 44);
			Global.GEMinPlayerReq = 3;
			Global.TempVar3 = Custom String(
				"Players randomly take turns controlling one body. \nIf the body dies or escapes, it affects everyone.");
			"Switcharoo"
			Global.TempVar2 = Count Of(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Global.GEName = Custom String("One-For-All!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 280);
		Else If(Global.TempVar == 45);
			Global.TempVar3 = Custom String("Players move forward very fast! No emotes allowed!");
			Global.GEName = Custom String("Forward March!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 50);
		Else If(Global.TempVar == 46);
			Global.TempVar3 = Custom String("Some players are taller! Don't squish your smaller allies!");
			Global.GEName = Custom String("Growth Spurt!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(30, 90);
			Global.GERadius = 3;
		Else If(Global.TempVar == 47);
			Global.TempVar3 = Custom String("Avoid the expanding sphere!");
			Global.GEName = Custom String("Kill Sphere!");
			Global.GEMaxNum = Random Integer(30, 70);
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Global.GEMaxNum + 15;
			Global.GERadius = 1;
		Else If(Global.TempVar == 48);
			Global.TempVar3 = Custom String("All players get booped!");
			Global.GEName = Custom String("Boop!");
		Else If(Global.TempVar == 49);
			"Toggle on/off trap zones"
			Global.GEToggles[1] = !Global.GEToggles[1];
			Global.TempVar3 = Custom String("{0}", Global.GEToggles[1] ? Custom String("Trap zones have been set! Be careful!")
				: Custom String("Trap zones are no longer present!"));
			Global.GEName = Custom String("Trap Zones!");
		Else If(Global.TempVar == 50);
			Global.TempVar3 = Custom String(
				"(Optional) Play the lottery by betting at ONE of the zones.\n\nEarnings: Demotion, Promotion, Nothing");
			Global.GEName = Custom String("Rigged Lottery!");
			"Set the timer for the Global Effect"
			Global.GEWaitTime = 120;
			Global.GERadius = 5;
		End;
		Wait(0.300, Ignore Condition);
		"DEBUGGING ONLY: bypass minimum player req."
		disabled Global.GEMinPlayerReq = 1;
		Loop If((Global.GEMinPlayerReq != 1 && Global.TempVar2 < Global.GEMinPlayerReq) || (
			Global.TempVar == 35 && Global.BacktrackDeathsWS == 0));
		Global.GEChoice = Global.TempVar;
		Global.GEHelpText = Global.TempVar3;
		Big Message(All Players(Team 1), Custom String("Global Effect ---> {0}", Global.GEName));
		Wait(2, Ignore Condition);
		Global.CanStartGE = 1;
		Global.GEMaxBacktrackSteps = 3;
	}
}

rule("Global Effect Timer (GE)[SR]")
{
	event
	{
		Subroutine;
		StartGETimer;
	}

	actions
	{
		"Start the timer for the duration of the Global Effect"
		Global.IsGETimerStart = True;
		Global.CanStartGE = 2;
		"Current match time in seconds"
		Global.GEEndTime = Round To Integer(Total Time Elapsed, To Nearest);
		Global.GEEndTime += Global.GEWaitTime;
		"How long to apply the global effect"
		Wait Until(!Global.IsGETimerStart, Global.GEWaitTime);
		Global.IsGETimerStart = False;
	}
}

rule("End current Global Effect (GE)[SR]")
{
	event
	{
		Subroutine;
		EndGlobalEffect;
	}

	actions
	{
		Global.CanStartGE = 0;
		Global.GEChoice = 0;
	}
}

rule("Set HUD recent help text for players (GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Event Player.GEHelpTextIDs == Null;
	}

	actions
	{
		Create HUD Text(Event Player, Custom String("{0} World Actives: {1}{2}", Icon String(Recycle),
			!Global.GEToggles[0] ? Ability Icon String(Hero(Soldier: 76), Button(Ability 2)) : String(""), Custom String("{0}{1}",
			Global.GEToggles[1] ? Ability Icon String(Hero(Junkrat), Button(Ability 2)) : String(""),
			Global.GEToggles[2] ? Ability Icon String(Hero(Ana), Button(Ability 2)) : String(""))), Null, Null, Right, -3, Color(Green),
			Color(White), Color(White), Visible To and String, Default Visibility);
		Event Player.GEHelpTextIDs = Array(Last Text ID);
		Create HUD Text(Event Player, Custom String("{0} Recent Effect:", Ability Icon String(Hero(Wrecking Ball), Button(Ability 1))),
			Null, Null, Right, -2, Color(Sky Blue), Color(White), Color(White), Visible To and String, Default Visibility);
		Modify Player Variable(Event Player, GEHelpTextIDs, Append To Array, Last Text ID);
		Create HUD Text(Event Player, Null, Custom String("                                   "), Custom String("{0}{1}\n", Icon String(
			Question Mark), Global.GEHelpText == Null ? Custom String("") : Global.GEHelpText), Right, -1, Color(White), Color(White),
			Color(White), Visible To and String, Default Visibility);
		Modify Player Variable(Event Player, GEHelpTextIDs, Append To Array, Last Text ID);
		Create HUD Text(Event Player, Custom String("{0} Bastion Upgrades: {1}{2}", Hero Icon String(Hero(Bastion)), Custom String(
			"{0}{1}{2}", Global.BUChoices[0] == 1 || (Global.BUChoices[0] == 4 && Global.BUChoices[2] == 2) ? Icon String(Arrow: Right) : (
			Global.BUChoices[0] == 2 || (Global.BUChoices[0] == 4 && Global.BUChoices[2] == 1) ? Icon String(Fire) : (
			Global.BUChoices[0] == 3 ? Icon String(Spiral) : (Global.BUChoices[0] == 5 || (
			Global.BUChoices[0] == 4 && Global.BUChoices[2] == 3) ? Icon String(Dizzy) : (Global.BUChoices[0] == 6 || (
			Global.BUChoices[0] == 4 && Global.BUChoices[2] == 4) ? Icon String(Bolt) : String(""))))),
			Global.BUChoices[0] == 4 ? Ability Icon String(Hero(Bastion), Button(Ultimate)) : String(""),
			Global.BUChoices[3] == 1 ? Ability Icon String(Hero(Soldier: 76), Button(Ability 1)) : (
			Global.BUChoices[3] == 2 ? Ability Icon String(Hero(Hanzo), Button(Ability 2)) : (
			Global.BUChoices[3] == 3 ? Ability Icon String(Hero(Genji), Button(Ability 1)) : String("")))),
			Global.BUChoices[1] == 1 ? Ability Icon String(Hero(Sombra), Button(Ability 1)) : (Global.BUChoices[1] == 2 ? Icon String(
			Arrow: Down) : (Global.BUChoices[1] == 3 ? Icon String(Arrow: Up) : (Global.BUChoices[1] == 4 ? Icon String(Eye) : String(
			""))))), Null, Null, Right, -4, Color(Aqua), Color(White), Color(White), Visible To and String, Default Visibility);
		Modify Player Variable(Event Player, GEHelpTextIDs, Append To Array, Last Text ID);
	}
}

rule("Set Global Effect duration progress bar HUD (GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
	}

	actions
	{
		Play Effect(Event Player, Symmetra Teleporter Reappear Sound, Color(White), Position Of(Event Player), 100);
		Create Progress Bar HUD Text(Event Player, Min((Global.GEEndTime - Round To Integer(Total Time Elapsed, To Nearest))
			/ Global.GEWaitTime * 100, 100), Custom String("{0} {1}", Icon String(Diamond), Global.GEName), Top, 5, Color(Yellow), Color(
			White), Visible To and Values, Default Visibility);
		Event Player.GETimerID = Last Text ID;
	}
}

rule("Remove Global Effect progress bar HUD (GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGETimerStart == False;
		Event Player.GETimerID != Null;
	}

	actions
	{
		Destroy Progress Bar HUD Text(Event Player.GETimerID);
		Event Player.GETimerID = Null;
	}
}

rule("Remove Global Effect duration progress bar HUD when player leaves")
{
	event
	{
		Player Left Match;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GETimerID != Null;
	}

	actions
	{
		Destroy Progress Bar HUD Text(Event Player.GETimerID);
		Event Player.GETimerID = Null;
	}
}

rule("Player left during *ANY* Global Effect (GE)")
{
	event
	{
		Player Left Match;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGETimerStart == True;
	}

	actions
	{
		"Remove HUDs"
		If(Count Of(Event Player.GEHUDID) == 0 && Event Player.GEHUDID != Null);
			Destroy HUD Text(Event Player.GEHUDID);
		Else If(Count Of(Event Player.GEHUDID) > 0);
			For Player Variable(Event Player, loopNum, 0, Count Of(Event Player.GEHUDID), 1);
				Destroy HUD Text(Event Player.GEHUDID[Event Player.loopNum]);
			End;
		End;
		Event Player.GEHUDID = Null;
		"Remove Effects"
		If(Count Of(Event Player.GEID) == 0 && Event Player.GEID != Null);
			Destroy Effect(Event Player.GEID);
		Else If(Count Of(Event Player.GEID) > 0);
			For Player Variable(Event Player, loopNum, 0, Count Of(Event Player.GEID), 1);
				Destroy Effect(Event Player.GEID[Event Player.loopNum]);
			End;
		End;
		Event Player.GEID = Null;
	}
}

rule("Player left during a *SPECIFIC* Global Effect (GE)")
{
	event
	{
		Player Left Match;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGETimerStart == True;
	}

	actions
	{
		Stop Chasing Global Variable(GEBallPosition);
		"Extreme Pong"
		If(Global.GEChoice == 30);
			Global.GETarget = Random Value In Array(Filtered Array(All Players(Team 1),
				!Current Array Element.IsWinner && Current Array Element != Event Player));
			Wait(2.500, Ignore Condition);
			Chase Global Variable At Rate(GEBallPosition, Eye Position(Global.GETarget) - Vector(0, 0.500, 0), Global.GEBallSpeed,
				Destination and Rate);
		"Spotlight"
		Else If(Global.GEChoice == 38);
			Global.GETarget = Random Value In Array(Filtered Array(All Players(Team 1),
				Current Array Element != Event Player && !Current Array Element.IsWinner && !Is In Spawn Room(Current Array Element)));
			Chase Global Variable At Rate(GEBallPosition, Position Of(Global.GETarget), Global.GEBallSpeed, Destination and Rate);
		"One-For-All"
		Else If(Global.GEChoice == 44 && Event Player == Global.GEAffectedPlayer);
			Global.GEAffectedPlayer = Null;
	}
}

rule("Start Global Effect -- [Type A] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.CanStartGE == 1;
		(Global.GEChoice == 1 || Global.GEChoice == 50 || Global.GEChoice == 51) == True;
	}

	actions
	{
		Global.GEMultiChoice = Random Integer(0, 14);
		Global.TempVar = Randomized Array(Filtered Array(All Players(Team 1), !Is In Spawn Room(Current Array Element)
			&& !Current Array Element.IsWinner));
		If(Global.GEMultiChoice > 5 && Global.GEMultiChoice < 10);
			Global.TempVar = Array Slice(Global.TempVar, 0, Round To Integer(Count Of(Global.TempVar) / 2, Up));
		"Apply Global Effect against a SINGLE player"
		Else If(Global.GEMultiChoice >= 10);
			Global.TempVar = Array Slice(Global.TempVar, 0, 1);
		End;
		Call Subroutine(GEStartTypeA);
		Call Subroutine(StartGETimer);
	}
}

rule("Init Type A (CHOICE:Variety)(NOT:Winners,In spawn) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeA;
	}

	actions
	{
		"Patrol Guards"
		If(Global.GEChoice == 1 || Global.GEChoice == 51);
			Call Subroutine(SelectAPatrol);
		"Rigged Lottery"
		Else If(Global.GEChoice == 50);
			"Promotion Lottery Number"
			Global.LotteryStats[0] = Random Integer(1, Count Of(Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(
				Bastion))));
			"Demotion Lottery Number"
			Global.LotteryStats[1] = Random Integer(1, Count Of(Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(
				Bastion))));
	}
}

rule("Start Global Effect -- [Type B] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.CanStartGE == 1;
		(
			Global.GEChoice == 3 || Global.GEChoice == 7 || Global.GEChoice == 9 || Global.GEChoice == 13 || Global.GEChoice == 15 || Global.GEChoice == 16 || Global.GEChoice == 17 || Global.GEChoice == 18 || Global.GEChoice == 20 || Global.GEChoice == 24 || Global.GEChoice == 25 || Global.GEChoice == 28 || Global.GEChoice == 30 || Global.GEChoice == 31 || Global.GEChoice == 39 || Global.GEChoice == 40 || Global.GEChoice == 41 || Global.GEChoice == 42 || Global.GEChoice == 45)
			== True;
	}

	actions
	{
		Global.TempVar = All Players(Team 1);
		Call Subroutine(GEStartTypeB);
		Call Subroutine(StartGETimer);
	}
}

rule("Init Type B (CHOICE:All) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeB;
	}

	actions
	{
		"Voice Line/Communicate Or Die"
		If(Global.GEChoice == 7 || Global.GEChoice == 15);
			Start Modifying Hero Voice Lines(Global.TempVar, Random Real(0.500, 1.500), False);
		"Bastion Deactivated"
		Else If(Global.GEChoice == 16);
			Set Status(All Players(Team 2), Null, Frozen, 9999);
		"More Health"
		Else If(Global.GEChoice == 18);
			Set Max Health(Global.TempVar, 300);
		"Friendly Ghosts"
		Else If(Global.GEChoice == 20);
			Set Invisible(Global.TempVar, All);
			Disable Movement Collision With Environment(Global.TempVar, False);
			Disable Movement Collision With Players(Global.TempVar);
		"Wingman"
		Else If(Global.GEChoice == 24);
			Respawn(Global.TempVar);
			Call Subroutine(SpawnAllAtAltLoc);
		"Leap Frog"
		Else If(Global.GEChoice == 28);
			Set Jump Vertical Speed(Global.TempVar, 200);
		"Extreme Pong"
		Else If(Global.GEChoice == 30);
			Create Effect(Global.TempVar, Orb, Color(White), Global.GEBallPosition, Global.GERadius, Visible To Position and Radius);
			Global.GEBallID = Array(Last Created Entity);
			Create Effect(All Players(Team 1), Energy Sound, Color(White), Global.GEBallPosition, 80, Visible To Position and Radius);
			Modify Global Variable(GEBallID, Append To Array, Last Created Entity);
		"Strong Winds"
		Else If(Global.GEChoice == 39);
			Call Subroutine(SelectWindDir);
			Call Subroutine(SetWindSpeedRate);
		"Reveal"
		Else If(Global.GEChoice == 42);
			Create Dummy Bot(Hero(Widowmaker), Team 1, 9, Random Value In Array(Spawn Points(Team 1)), Vector(0, 0, 0));
			Global.TempVar = Filtered Array(All Players(Team 1), Hero Of(Current Array Element) == Hero(Widowmaker) && Is Dummy Bot(
				Current Array Element))[0];
			Disable Movement Collision With Players(Global.TempVar);
			Set Ultimate Ability Enabled(Global.TempVar, True);
			Set Ultimate Charge(Global.TempVar, 100);
			Press Button(Global.TempVar, Button(Ultimate));
			Disallow Button(Global.TempVar, Button(Ultimate));
			Start Forcing Player Outlines(Global.TempVar, All Players(Team 1), True, Color(Yellow), Always);
			If(Global.BUChoices[1] == 1);
				Set Invisible(Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Bastion)), None);
			End;
	}
}

rule("Start Global Effect -- [Type C] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.CanStartGE == 1;
		(
			Global.GEChoice == 2 || Global.GEChoice == 4 || Global.GEChoice == 10 || Global.GEChoice == 32 || Global.GEChoice == 33 || Global.GEChoice == 34 || Global.GEChoice == 35 || Global.GEChoice == 43 || Global.GEChoice == 48 || Global.GEChoice == 49 || Global.GEChoice == 52 || Global.GEChoice == 53 || Global.GEChoice == 54)
			== True;
	}

	actions
	{
		Call Subroutine(GEStartTypeC);
		Global.CanStartGE = 2;
	}
}

rule("Init Type C (CHOICE:All)(NOT:Timer) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeC;
	}

	actions
	{
		"Switcharoo"
		If(Global.GEChoice == 4);
			Global.TempVar3 = Randomized Array(Mapped Array(All Players(Team 1), Position Of(Current Array Element)));
			Global.TempVar = Randomized Array(All Players(Team 1));
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				Teleport(Global.TempVar[Global.TempVar2], Global.TempVar3[Global.TempVar2]);
			End;
		"Bastion Buff Upgrade"
		Else If(Global.GEChoice == 10 || Global.GEChoice == 54);
			Call Subroutine(SelectBastionBuffUpgrade);
		"Group Up"
		Else If(Global.GEChoice == 32);
			Global.TempVar = Random Value In Array(All Players(Team 1));
			Teleport(Filtered Array(All Players(Team 1), Global.TempVar != Current Array Element), Position Of(Global.TempVar));
		"I Need Healing"
		Else If(Global.GEChoice == 33);
			"I Need Healing"
			If(!Global.GEToggles[0]);
				Heal(All Players(Team 1), Null, 9999);
			Else;
				Stop All Heal Over Time(All Players(All Teams));
			End;
		"Bastion Bullet Upgrade"
		Else If(Global.GEChoice == 34 || Global.GEChoice == 52);
			Call Subroutine(SelectBastionBulletUpgrade);
		"Blood Sacrifice"
		Else If(Global.GEChoice == 35);
			"ones = 4; twos = 4; threes = 2; "
			Global.BacktrackSteps = Random Value In Array(Filtered Array(Array(1, 2, 1, 3, 1, 2, 2, 3, 1, 2),
				Current Array Element != Global.BacktrackSteps));
		"Bastion Extra Upgrade"
		Else If(Global.GEChoice == 43 || Global.GEChoice == 53);
			Call Subroutine(SelectBastionExtraUpgrade);
		"Boop"
		Else If(Global.GEChoice == 48);
			Call Subroutine(SetBoopDirection);
			Global.TempVar = All Players(Team 1);
			Apply Impulse(Global.TempVar, Global.GEBallPosition, Random Real(8000, 12000), To World, Cancel Contrary Motion);
		"Trap Zones"
		Else If(Global.GEChoice == 49 && !Global.GEToggles[1]);
			Call Subroutine(CleanUpAllTrapsAndStats);
	}
}

rule("Start Global Effect -- [Type D] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.CanStartGE == 1;
		(Global.GEChoice == 8 || Global.GEChoice == 14 || Global.GEChoice == 19) == True;
	}

	actions
	{
		Global.GECarriers = Randomized Array(Filtered Array(All Living Players(Team 1), !Is In Spawn Room(Current Array Element)
			&& !Current Array Element.IsWinner));
		Global.GECarriers = Array Slice(Global.GECarriers, 0, Round To Integer(Count Of(Global.GECarriers) / 2, Up));
		Call Subroutine(GEStartTypeD);
		Call Subroutine(StartGETimer);
	}
}

rule("Init Type D (CHOICE:Some)(SPECIAL:Carriers)(NOT:Winners,In spawn) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeD;
	}

	actions
	{
		"I'm the Bomb"
		If(Global.GEChoice == 8 || Global.GEChoice == 14);
			For Global Variable(TempVar2, 0, Count Of(Global.GECarriers), 1);
				Global.GECarriers[Global.TempVar2].GEID = -1;
			End;
		"Medusa"
		Else If(Global.GEChoice == 19);
			Start Forcing Player Outlines(Global.GECarriers, All Players(Team 1), True, Color(Orange), Always);
	}
}

rule("Start Global Effect -- [Type E] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.CanStartGE == 1;
		Global.GEChoice == 11;
	}

	actions
	{
		Global.TempVar = Random Value In Array(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner && !Is In Spawn Room(
			Current Array Element)));
		Call Subroutine(GEStartTypeE);
		Call Subroutine(StartGETimer);
	}
}

rule("Init Type E (CHOICE:Single)(NOT:Winners,In spawn) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeE;
	}

	actions
	{
		"Bastion Drop"
		If(Global.GEChoice == 11);
			Modify Global Variable(AllBastionPositions, Append To Array, Position Of(Global.TempVar));
			Create Dummy Bot(Hero(Bastion), Team 2, -1, Position Of(Global.TempVar), Left - Left);
			Play Effect(All Players(Team 1), Ring Explosion Sound, Color(White), Position Of(Global.TempVar), 90);
			Play Effect(All Players(Team 1), Bad Pickup Effect, Color(Orange), Position Of(Global.TempVar), 3);
	}
}

rule("Start Global Effect -- [Type F] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.CanStartGE == 1;
		(Global.GEChoice == 12 || Global.GEChoice == 21 || Global.GEChoice == 23) == True;
	}

	actions
	{
		Global.TempVar = Randomized Array(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
		Global.TempVar = Array Slice(Global.TempVar, 0, Round To Integer(Count Of(Global.TempVar) / 2, Up));
		Call Subroutine(GEStartTypeF);
		Call Subroutine(StartGETimer);
	}
}

rule("Init Type F (CHOICE:Some)(NOT:Winners) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeF;
	}

	actions
	{
		"Hacked"
		If(Global.GEChoice == 12);
			Set Status(Global.TempVar, Null, Hacked, 9999);
		"Sleepy tbags"
		Else If(Global.GEChoice == 21);
			Set Status(Global.TempVar, Null, Asleep, 9999);
			Start Forcing Player Outlines(Global.TempVar, All Players(Team 1), True, Color(Violet), Always);
		"Piggyback"
		Else If(Global.GEChoice == 22);
			"Enter logic below"
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				Global.TempVar[Global.TempVar2].GEIsHeroCarrier = True;
			End;
		"Guardian Angel"
		Else If(Global.GEChoice == 23);
			Global.TempVar3 = Filtered Array(All Players(Team 1), !Current Array Element.IsWinner);
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				Global.TempVar3 = Filtered Array(Global.TempVar3, Global.TempVar[Global.TempVar2] != Current Array Element);
				Global.TempVar[Global.TempVar2].GEGuardianAngel = First Of(Global.TempVar3);
				Global.TempVar[Global.TempVar2].GEGuardianAngel.GEHumanProtect = Global.TempVar[Global.TempVar2];
				Modify Global Variable(TempVar3, Remove From Array By Index, 0);
			End;
	}
}

rule("Start Global Effect -- [Type G] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.CanStartGE == 1;
		Global.GEChoice == 5;
	}

	actions
	{
		Global.GEMultiChoice = Random Integer(0, 14);
		Global.TempVar = Randomized Array(Filtered Array(All Players(Team 1), !Is In Spawn Room(Current Array Element)
			&& !Current Array Element.IsWinner));
		If(Global.GEMultiChoice > 5 && Global.GEMultiChoice < 10);
			Global.TempVar = Array Slice(Global.TempVar, 0, Round To Integer(Count Of(Global.TempVar) / 2, Up));
		"Apply Global Effect against a SINGLE player"
		Else If(Global.GEMultiChoice >= 10);
			Global.TempVar = Array Slice(Global.TempVar, 0, 1);
		End;
		Call Subroutine(GEStartTypeG);
		Global.CanStartGE = 2;
	}
}

rule("Init Type G (CHOICE:Variety)(NOT:Winners,In spawn,Timer) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeG;
	}

	actions
	{
		"Oof Teleport"
		If(Global.GEChoice == 5);
			Respawn(Global.TempVar);
			If(Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter));
				Teleport(Global.TempVar, Global.BlizzWorldSpawnLoc);
				Set Facing(Global.TempVar, Forward + Left, To World);
				Global.TempVar2 = Global.BlizzWorldSpawnLoc;
			Else If(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween));
				Teleport(Global.TempVar, Global.HollywoodSpawns[0]);
				Set Facing(Global.TempVar, Right, To World);
				Global.TempVar2 = Global.HollywoodSpawns[0];
			Else;
				Global.TempVar2 = First Of(Randomized Array(Spawn Points(Team 1)));
			End;
			Play Effect(Global.TempVar, Debuff Impact Sound, Color(White), Global.TempVar2, 200);
	}
}

rule("Start Global Effect -- [Type H] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.CanStartGE == 1;
		(Global.GEChoice == 22 || Global.GEChoice == 46) == True;
	}

	actions
	{
		Global.GEMultiChoice = Random Integer(0, 14);
		Global.TempVar = Randomized Array(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
		"Apply global effect against SOME players"
		If(Global.GEMultiChoice < 7);
			Global.TempVar = Array Slice(Global.TempVar, 0, Round To Integer(Count Of(Global.TempVar) / 2, Up));
		Else;
			Global.TempVar = Array Slice(Global.TempVar, 0, 1);
		End;
		Call Subroutine(GEStartTypeH);
		Call Subroutine(StartGETimer);
	}
}

rule("Init Type H (CHOICE:Some or Single)(NOT:Winners) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeH;
	}

	actions
	{
		"Piggyback"
		If(Global.GEChoice == 22);
			"Enter logic below"
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				Global.TempVar[Global.TempVar2].GEIsHeroCarrier = True;
			End;
		"Growth Spurt"
		Else If(Global.GEChoice == 46);
			Start Scaling Player(Global.TempVar, 3, False);
			Set Move Speed(Global.TempVar, 80);
			Set Max Health(Global.TempVar, 250);
			"Enter logic below"
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				"Is a bug"
				Global.TempVar[Global.TempVar2].GEIsAffectedPlayer = True;
			End;
			Disable Movement Collision With Environment(Global.TempVar, False);
			Disable Nameplates(All Players(Team 1), All Players(Team 1));
			Start Modifying Hero Voice Lines(Global.TempVar, 0.500, False);
	}
}

rule("Start Global Effect -- [Type I] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.CanStartGE == 1;
		(
			Global.GEChoice == 26 || Global.GEChoice == 29 || Global.GEChoice == 36 || Global.GEChoice == 37 || Global.GEChoice == 38 || Global.GEChoice == 44 || Global.GEChoice == 47)
			== True;
	}

	actions
	{
		Global.TempVar = Random Value In Array(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
		Call Subroutine(GEStartTypeI);
		Call Subroutine(StartGETimer);
	}
}

rule("Init Type I (CHOICE:Single)(NOT:Winners) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeI;
	}

	actions
	{
		"World Tag"
		If(Global.GEChoice == 26);
			Global.TempVar.GEIsTagger = True;
			Global.TempVar.GEIsTagged = True;
		"Lockdown"
		Else If(Global.GEChoice == 36);
			Call Subroutine(SelectLocFromAllDirs);
			Create Effect(All Players(Team 1), Orb, Color(Blue), Global.GEBallPosition, Global.GERadius, Visible To Position and Radius);
			Global.GEBallID = Array(Last Created Entity);
			Create Effect(All Players(Team 1), Sparkles Sound, Color(White), Global.GEBallPosition, 70, Visible To Position and Radius);
			Modify Global Variable(GEBallID, Append To Array, Last Created Entity);
		"Spotlight"
		Else If(Global.GEChoice == 38);
			Create Effect(All Players(Team 1), Light Shaft, Custom Color(255, 36, 36, 255), Position Of(Global.GEBallPosition),
				Global.GERadius, Visible To Position and Radius);
			Global.GEBallID = Array(Last Created Entity);
			Create Effect(All Players(Team 1), Decal Sound, Color(White), Global.GEBallPosition, 90, Visible To Position and Radius);
			Modify Global Variable(GEBallID, Append To Array, Last Created Entity);
		"One-For-All"
		Else If(Global.GEChoice == 44);
			Respawn(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
			Call Subroutine(SpawnAllAtAltLoc);
		"Kill Sphere"
		Else If(Global.GEChoice == 47);
			Call Subroutine(SelectLocFromAllDirs);
			Create Effect(All Players(Team 1), Sphere, Color(Red), Global.GEBallPosition, Global.GERadius, Visible To Position and Radius);
			Global.GEBallID[0] = Last Created Entity;
			Create Effect(All Players(Team 1), Energy Sound, Color(White), Global.GEBallPosition, 100, Visible To);
			Global.GEBallID[1] = Last Created Entity;
			Chase Global Variable Over Time(GERadius, Global.GEMaxNum, Global.GEWaitTime, None);
	}
}

rule("Start Global Effect -- [Type J] (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.CanStartGE == 1;
		(Global.GEChoice == 27 || Global.GEChoice == 6) == True;
	}

	actions
	{
		Global.GEMultiChoice = Random Integer(0, 14);
		Global.TempVar = Randomized Array(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
		If(Global.GEMultiChoice > 5 && Global.GEMultiChoice < 10);
			Global.TempVar = Array Slice(Global.TempVar, 0, Round To Integer(Count Of(Global.TempVar) / 2, Up));
		"Apply Global Effect against a SINGLE player"
		Else If(Global.GEMultiChoice >= 10);
			Global.TempVar = Array Slice(Global.TempVar, 0, 1);
		End;
		Call Subroutine(GEStartTypeJ);
		Call Subroutine(StartGETimer);
	}
}

rule("Init Type J (CHOICE:Variety)(NOT:Winners) (GE)[SR]")
{
	event
	{
		Subroutine;
		GEStartTypeJ;
	}

	actions
	{
		"Invincible"
		If(Global.GEChoice == 6);
			Global.TempVar3 = Filtered Array(All Players(Team 1), !Array Contains(Global.TempVar, Current Array Element));
			For Global Variable(TempVar4, 0, Count Of(Global.TempVar3), 1);
				Global.TempVar3[Global.TempVar4].GEHUDID = -2;
			End;
			Set Status(Global.TempVar, Null, Invincible, 99999);
		"Bugs"
		Else If(Global.GEChoice == 27);
			Start Scaling Player(Global.TempVar, 0.099, False);
			Set Max Health(Global.TempVar, 5);
			"Enter logic below"
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				"Is a bug"
				Global.TempVar[Global.TempVar2].GEIsAffectedPlayer = True;
			End;
			Disable Nameplates(Global.TempVar, All Players(Team 1));
			Start Modifying Hero Voice Lines(Global.TempVar, 1.500, False);
	}
}

rule("Clean up specific Global Effect at the end (GE)[SR]")
{
	event
	{
		Subroutine;
		GESpecificEndCleanUp;
	}

	actions
	{
		Stop Forcing Player Outlines(All Players(Team 1), All Players(Team 1));
		"Patrol Guards"
		If(Global.GEChoice == 1 || Global.GEChoice == 51);
			Call Subroutine(CleanUpPatrol);
		"Drug Packs"
		Else If(Global.GEChoice == 2 && !Global.GEToggles[2]);
			Call Subroutine(ResetAllSideEffects);
		"Lava Floor"
		Else If(Global.GEChoice == 3);
			Clear Status(All Players(Team 1), Burning);
			Heal(All Living Players(Team 1), Null, 600);
			Stop All Damage Over Time(All Players(Team 1));
		"Invincible"
		Else If(Global.GEChoice == 6);
			Clear Status(All Players(Team 1), Invincible);
		"X or Die"
		Else If(Global.GEChoice == 7 || Global.GEChoice == 13 || Global.GEChoice == 15);
			Kill(Filtered Array(All Players(Team 1), Current Array Element.GECount < Global.GERequiredNum && !Current Array Element.IsWinner),
				Random Value In Array(All Players(Team 2)));
			Stop Modifying Hero Voice Lines(All Players(Team 1));
		"I'm the Bomb"
		Else If(Global.GEChoice == 8);
			For Global Variable(TempVar2, 0, Count Of(Global.GECarriers), 1);
				Global.TempVar = Filtered Array(Players Within Radius(Global.GECarriers[Global.TempVar2], Global.GERadius, Team 1, Off),
					Current Array Element != Global.GECarriers[Global.TempVar2]);
				Kill(Global.TempVar, Random Value In Array(All Players(Team 2)));
				Play Effect(Filtered Array(All Players(Team 1), Global.TempVar[Global.TempVar2] != Current Array Element),
					DVa Self Destruct Explosion Sound, Color(Orange), Global.GECarriers[Global.TempVar2], 80);
				Play Effect(All Players(Team 1), Good Explosion, Color(Orange), Global.GECarriers[Global.TempVar2], Global.GERadius);
			End;
		"Passenger"
		Else If(Global.GEChoice == 9);
			Set Move Speed(All Players(Team 1), 100);
		"Bastion Drop"
		Else If(Global.GEChoice == 11);
			Destroy Dummy Bot(Team 2, Count Of(Global.AllBastionPositions) - 1);
			Modify Global Variable(AllBastionPositions, Remove From Array By Index, Count Of(Global.AllBastionPositions) - 1);
		"Hacked"
		Else If(Global.GEChoice == 12);
			Clear Status(All Players(Team 1), Hacked);
		"Bastion Deactivated"
		Else If(Global.GEChoice == 16);
			Clear Status(All Players(Team 2), Frozen);
		"More Health"
		Else If(Global.GEChoice == 18);
			Set Max Health(All Players(Team 1), 100);
		"Medusa"
		Else If(Global.GEChoice == 19);
			Clear Status(All Players(Team 1), Frozen);
		"Friendly Ghosts"
		Else If(Global.GEChoice == 20);
			Set Invisible(All Players(Team 1), None);
			Enable Movement Collision With Environment(All Players(Team 1));
			Enable Movement Collision With Players(All Players(Team 1));
		"Sleepy TBags"
		Else If(Global.GEChoice == 21);
			Clear Status(All Players(Team 1), Asleep);
			Set Move Speed(All Players(Team 1), 100);
			Global.TempVar = All Players(Team 1);
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				Global.TempVar[Global.TempVar2].IsGETBagCrouched = False;
				Global.TempVar[Global.TempVar2].IsGETBagStand = False;
			End;
		"Piggyback"
		Else If(Global.GEChoice == 22);
			Global.TempVar = All Players(Team 1);
			Stop Scaling Player(Global.TempVar);
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				Global.TempVar[Global.TempVar2].GEHeroCarrier = Null;
				Global.TempVar[Global.TempVar2].GEIsHeroCarrier = False;
				Detach Players(Global.TempVar[Global.TempVar2].GEHeroRider);
				If(Count Of(Global.TempVar[Global.TempVar2].GEHUDID) == 2);
					Destroy HUD Text(Global.TempVar[Global.TempVar2].GEHUDID[0]);
					Destroy HUD Text(Global.TempVar[Global.TempVar2].GEHUDID[1]);
					Global.TempVar[Global.TempVar2].GEHUDID = Null;
				End;
				Global.TempVar[Global.TempVar2].GEHeroRider = Null;
			End;
			Clear Status(Global.TempVar, Unkillable);
		"Guardian Angel"
		Else If(Global.GEChoice == 23);
			Global.TempVar = All Players(Team 1);
			Clear Status(Global.TempVar, Unkillable);
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				If(Global.TempVar[Global.TempVar2].GEHUDID != Null);
					Destroy HUD Text(Global.TempVar[Global.TempVar2].GEHUDID[0]);
					Destroy HUD Text(Global.TempVar[Global.TempVar2].GEHUDID[1]);
					Global.TempVar[Global.TempVar2].GEHUDID = Null;
				End;
				Global.TempVar[Global.TempVar2].GEGuardianAngel = Null;
				Global.TempVar[Global.TempVar2].GEHumanProtect = Null;
			End;
		"Staring Contest"
		Else If(Global.GEChoice == 25);
			Stop Facing(All Players(Team 1));
		"World Tag"
		Else If(Global.GEChoice == 26);
			If(Global.GECurReqNum < Global.GERequiredNum);
				If(Global.BacktrackDeathsWS != 0);
					Global.TempVar = Filtered Array(All Players(Team 1), !Current Array Element.IsWinner);
					For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
						Global.TempVar[Global.TempVar2].BacktrackDeaths = Global.BacktrackDeathsWS;
					End;
					Big Message(Global.TempVar, Custom String("Failed! Everyone was demoted!"));
				Else;
					Kill(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner), Random Value In Array(All Players(Team 2)));
				End;
			End;
			Global.TempVar = All Players(Team 1);
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				If(Global.TempVar[Global.TempVar2].GEHUDID != Null);
					Destroy HUD Text(Global.TempVar[Global.TempVar2].GEHUDID[0]);
					Destroy HUD Text(Global.TempVar[Global.TempVar2].GEHUDID[1]);
					Destroy HUD Text(Global.TempVar[Global.TempVar2].GEHUDID[2]);
					Global.TempVar[Global.TempVar2].GEHUDID = Null;
				End;
				Global.TempVar[Global.TempVar2].GEIsTagger = False;
				Global.TempVar[Global.TempVar2].GEIsTagged = False;
			End;
		"Bugs & Growth Spurt"
		Else If(Global.GEChoice == 27 || Global.GEChoice == 46);
			Enable Nameplates(All Players(Team 1), All Players(Team 1));
			Set Max Health(All Players(Team 1), 100);
			Stop Scaling Player(All Players(Team 1));
			Set Move Speed(All Players(Team 1), 100);
			Enable Movement Collision With Environment(All Players(Team 1));
			Stop Modifying Hero Voice Lines(All Players(Team 1));
		"Leap Frog"
		Else If(Global.GEChoice == 28);
			Set Jump Vertical Speed(All Players(Team 1), 100);
		"President"
		Else If(Global.GEChoice == 29);
			Set Max Health(All Players(Team 1), 100);
		"Lockdown"
		Else If(Global.GEChoice == 36);
			Destroy Effect(Global.GEBallID);
			Stop Forcing Player Outlines(Global.GEAffectedPlayer, All Players(Team 1));
			Global.GEBallID = Null;
		"Warped Slo-mo"
		Else If(Global.GEChoice == 37);
			Set Slow Motion(90);
			Set Move Speed(All Players(Team 1), 100);
		"Spotlight & Extreme Pong"
		Else If(Global.GEChoice == 38 || Global.GEChoice == 30);
			Destroy Effect(Global.GEBallID);
			Global.GEBallID = Null;
		"Strong Winds"
		Else If(Global.GEChoice == 39);
			Stop Chasing Global Variable(GEBallSpeed);
		"Wacky Camera"
		Else If(Global.GEChoice == 40);
			Stop Camera(All Players(Team 1));
		"Space Propulsion"
		Else If(Global.GEChoice == 41);
			Allow Button(All Players(Team 1), Button(Primary Fire));
			Allow Button(All Players(Team 1), Button(Secondary Fire));
			Stop Forcing Throttle(All Players(Team 1));
			Set Gravity(All Players(Team 1), 100);
		"Reveal"
		Else If(Global.GEChoice == 42);
			Destroy Dummy Bot(Team 1, Slot Of(Filtered Array(All Players(Team 1), Hero Of(Current Array Element) == Hero(Widowmaker)
				&& Is Dummy Bot(Current Array Element))[0]));
			If(Global.BUChoices[1] == 1);
				Set Invisible(Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Bastion)), All);
			End;
		"One-For-All"
		Else If(Global.GEChoice == 44);
			Stop Camera(All Players(Team 1));
			Global.GEAffectedPlayer = All Players(Team 1);
			Call Subroutine(EnablePlayer);
		"Forward March"
		Else If(Global.GEChoice == 45);
			Set Move Speed(All Players(Team 1), 100);
			Stop Throttle In Direction(All Players(Team 1));
		"Kill Sphere"
		Else If(Global.GEChoice == 47);
			Destroy Effect(Global.GEBallID);
			Global.GEBallID = Null;
			Stop Chasing Global Variable(GERadius);
		"Rigged Lottery"
		Else If(Global.GEChoice == 50);
			If(Global.LotteryStats[0] != Global.LotteryStats[1]);
				Global.TempVar = Filtered Array(All Players(Team 1), Current Array Element.LotteryChoice == Global.LotteryStats[0]);
				Teleport(Global.TempVar, Global.EndPosition + Vector(0, 5, 0));
				Big Message(Global.TempVar, Custom String("You Won the lottery! Congrats!"));
				If(Global.BacktrackDeathsWS != 0);
					Global.TempVar = Filtered Array(All Players(Team 1), Current Array Element.LotteryChoice == Global.LotteryStats[1]);
					For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
						Global.TempVar[Global.TempVar2].BacktrackDeaths = Global.BacktrackDeathsWS;
					End;
					Big Message(Global.TempVar, Custom String("You were demoted! Better luck next time!"));
				End;
				Global.TempVar = Filtered Array(All Players(Team 1),
					Current Array Element.LotteryChoice != Global.LotteryStats[0] && Current Array Element.LotteryChoice != Global.LotteryStats[1] && Current Array Element.LotteryChoice != 0);
				Big Message(Global.TempVar, Custom String("Nice try! Better luck next time!"));
			Else;
				Big Message(Filtered Array(All Players(Team 1), Current Array Element.LotteryChoice > 0), Custom String(
					"Nice try! Better luck next time!"));
			End;
			Wait(3, Ignore Condition);
			Big Message(All Players(Team 1), Custom String("{0}", Global.LotteryStats[0] == Global.LotteryStats[1] ? Custom String(
				"All zones were Nothing... Sorry!") : Custom String("Promotion #: {0}\nDemotion #: {1}", Global.LotteryStats[0],
				Global.LotteryStats[1])));
		End;
	}
}

rule("End of Global Effect *EVENT PLAYER*(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.GEChoice == 0;
	}

	actions
	{
		"Clean up applied effects"
		If(Event Player.GEID != Null);
			If(Count Of(Event Player.GEID) == 0);
				Destroy Effect(Event Player.GEID);
			Else;
				For Player Variable(Event Player, GETempVar, 0, Count Of(Event Player.GEID), 1);
					Destroy Effect(Event Player.GEID[Event Player.GETempVar]);
				End;
			End;
		End;
		Event Player.GEID = Null;
		"Clean up global effect huds"
		If(Event Player.GEHUDID != Null);
			If(Count Of(Event Player.GEHUDID) == 0);
				Destroy HUD Text(Event Player.GEHUDID);
			Else;
				For Player Variable(Event Player, GETempVar, 0, Count Of(Event Player.GEHUDID), 1);
					Destroy HUD Text(Event Player.GEHUDID[Event Player.GETempVar]);
				End;
			End;
		End;
		Event Player.GEHUDID = Null;
		Event Player.GEIsAffectedPlayer = False;
		Event Player.GECount = 0;
		Event Player.LotteryChoice = 0;
		Event Player.GEPartner = Null;
		Event Player.EnemyTrapEntity = Null;
		Call Subroutine(ApplyWinnerStats);
	}
}

rule("End of Global Effect ENEMY *EVENT PLAYER*(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Global.IsGEEnabledWS == True;
		Global.GEChoice == 0;
	}

	actions
	{
		"Clean up applied effects"
		If(Event Player.GEID != Null);
			If(Count Of(Event Player.GEID) == 0);
				Destroy Effect(Event Player.GEID);
			Else;
				For Player Variable(Event Player, GETempVar, 0, Count Of(Event Player.GEID), 1);
					Destroy Effect(Event Player.GEID[Event Player.GETempVar]);
				End;
			End;
		End;
		Event Player.GEID = Null;
		Destroy In-World Text(Event Player.GEHUDID);
		Event Player.GEHUDID = Null;
	}
}

rule("End of Global Effect *GLOBAL* (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.GEChoice > 0;
		Global.IsGETimerStart == False;
		Global.CanStartGE == 2;
	}

	actions
	{
		Call Subroutine(GESpecificEndCleanUp);
		Global.GECarriers = Null;
		Global.GEMaxNum = 0;
		Global.GECurReqNum = 0;
		Global.GERequiredNum = 0;
		Global.GETarget = Null;
		If(Global.GEBallID != Null);
			Destroy Effect(Global.GEBallID);
			Global.GEBallID = Null;
		End;
		Global.GEBallSpeed = 0;
		If(Global.GEBallPosition != Null);
			Stop Chasing Global Variable(GEBallPosition);
			Global.GEBallPosition = Null;
		End;
		Global.GEAffectedPlayer = Null;
		Call Subroutine(EndGlobalEffect);
	}
}

rule("Select a position from ALL directions (Kill Sphere & Lockdown)(GE)[SR]")
{
	event
	{
		Subroutine;
		SelectLocFromAllDirs;
	}

	actions
	{
		"47 = Kill Sphere"
		Global.TempVar = Global.GEChoice == 47 ? Random Value In Array(All Players(Team 2)) : Random Value In Array(Filtered Array(
			All Players(Team 1), !Current Array Element.IsWinner));
		Global.TempVar2 = Random Integer(0, 25);
		Global.GESpawnDistance = Global.GEChoice == 47 ? Random Real(0, 60) : Random Real(15, 90);
		If(Global.TempVar2 == 0);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + Forward * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 1);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Right) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 2);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + Right * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 3);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Right) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 4);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + Backward * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 5);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Left) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 6);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + Left * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 7);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Left) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 8);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 9);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 10);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Right + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 11);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Right + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 12);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 13);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 14);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Left + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 15);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Left + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 16);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Right + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 17);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Right + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 18);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Right + Down)
				* Global.GESpawnDistance);
		Else If(Global.TempVar2 == 19);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Right + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 20);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Left + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 21);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Forward + Left + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 22);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Left + Down) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 23);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + (Backward + Left + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 24);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + Up * Global.GESpawnDistance);
		Else If(Global.TempVar2 == 25);
			Global.GEBallPosition = Nearest Walkable Position(Position Of(Global.TempVar) + Down * Global.GESpawnDistance);
		End;
		Global.GEBallPosition += Vector(0, Global.GEChoice == 47 ? Random Real(0, 10) : Random Real(0, 5), 0);
	}
}

rule("Completed Global Effect task! (GE)[SR]")
{
	event
	{
		Subroutine;
		CompleteGlobalEffect;
	}

	actions
	{
		"President & Lockdown"
		If(Global.GEChoice == 29 || Global.GEChoice == 36);
			Global.IsGETimerStart = False;
			Big Message(All Players(Team 1), Custom String("Task Complete!"));
			"President"
			If(Global.GEChoice == 29);
				Global.TempVar = Filtered Array(All Players(Team 1), !Current Array Element.GEIsAffectedPlayer && !Current Array Element.IsWinner);
				For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
					If((Global.HeroListTypeWS != 2 && Global.TempVar[Global.TempVar2].CurrentHero == Count Of(Global.HeroList) - 1) || (
						Global.HeroListTypeWS == 2 && Global.TempVar[Global.TempVar2].CurrentHero == Count Of(
						Global.TempVar[Global.TempVar2].IndieHeroList) - 1));
						Teleport(Global.TempVar[Global.TempVar2], Global.EndPosition + Vector(0, 5, 0));
					Else;
						Global.TempVar[Global.TempVar2].CurrentHero += 1;
						Global.TempVar[Global.TempVar2].TargetHero = Global.TempVar[Global.TempVar2].CurrentHero;
						Respawn(Global.TempVar[Global.TempVar2]);
						If(Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter));
							Teleport(Global.TempVar[Global.TempVar2], Global.BlizzWorldSpawnLoc);
						Else If(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween));
							Teleport(Global.TempVar[Global.TempVar2], Global.HollywoodSpawns[0]);
						End;
					End;
				End;
			End;
		End;
	}
}

rule("Set basic HUD & stats (GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEHUDID == Null;
		(
			Global.GEChoice == 7 || Global.GEChoice == 13 || Global.GEChoice == 15 || Global.GEChoice == 21 || Global.GEChoice == 25 || Global.GEChoice == 26 || Global.GEChoice == 29 || Global.GEChoice == 30 || Global.GEChoice == 36 || Global.GEChoice == 38 || Global.GEChoice == 39 || Global.GEChoice == 50)
			== True;
	}

	actions
	{
		"communicate or die"
		If(Global.GEChoice == 7);
			"Set status id for player(if needed)"
			Create HUD Text(Event Player, Custom String("Communication Count: {0}/{1}", Event Player.GECount, Global.GERequiredNum), Null,
				Null, Right, 1, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Last Text ID;
		"emote or die"
		Else If(Global.GEChoice == 13);
			"Set status id for player(if needed)"
			Create HUD Text(Event Player, Custom String("Emote Count: {0}/{1}", Event Player.GECount, Global.GERequiredNum), Null, Null, Right,
				1, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Last Text ID;
		"voice line or die"
		Else If(Global.GEChoice == 15);
			Create HUD Text(Event Player, Custom String("Voice Line Count: {0}/{1}", Event Player.GECount, Global.GERequiredNum), Null, Null,
				Right, 1, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Last Text ID;
		"Sleepy Tbags"
		Else If(Global.GEChoice == 21);
			Create HUD Text(Event Player, Custom String("TBags Count: {0}/{1}", Event Player.GECount, Global.GERequiredNum), Null, Null, Right,
				0, Color(Blue), Color(White), Color(White), Visible To and String, Default Visibility);
			Event Player.GEHUDID = Last Text ID;
		"Staring Contest"
		Else If(Global.GEChoice == 25);
			Create HUD Text(Event Player, Custom String("Staring At: {0}", Event Player.GEPartner), Null, Null, Right, 0, Color(Orange), Color(
				White), Color(White), Visible To and String, Default Visibility);
			Event Player.GEHUDID = Last Text ID;
		"World Tag"
		Else If(Global.GEChoice == 26);
			Create HUD Text(Event Player, Custom String("Status: {0}", Event Player.GEIsTagger ? Custom String("Tagger") : Custom String(
				"Player")), Null, Null, Right, 0, Color(Yellow), Color(White), Color(White), Visible To and String, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Array(Last Text ID);
			"Count the number of times something happens (if neccessary)"
			Create HUD Text(Event Player, Custom String("Was Tagged?: {0}", Event Player.GEIsTagged ? String("Yes") : String("No")), Null,
				Null, Right, 0, Color(Green), Color(White), Color(White), Visible To and String, Default Visibility);
			Modify Player Variable(Event Player, GEHUDID, Append To Array, Last Text ID);
			Create HUD Text(Event Player, Custom String("Required: {0}/{1}", Global.GECurReqNum, Global.GERequiredNum), Null, Null, Right, 0,
				Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
			Modify Player Variable(Event Player, GEHUDID, Append To Array, Last Text ID);
		"President"
		Else If(Global.GEChoice == 29);
			Create HUD Text(Event Player, Custom String("Status: {0}", Event Player.GEIsAffectedPlayer ? Custom String("President")
				: Custom String("Bodyguard")), Null, Null, Right, 0, Color(Yellow), Color(White), Color(White), Visible To and String,
				Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Last Text ID;
		"Lockdown"
		Else If(Global.GEChoice == 36);
			Create HUD Text(Event Player, Custom String("Has Key?: {0}", Event Player == Global.GEAffectedPlayer ? String("Yes") : String(
				"No")), Null, Null, Right, 0, Color(Yellow), Color(White), Color(White), Visible To and String, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Last Text ID;
		"Extreme Pong or Spotlight"
		Else If(Global.GEChoice == 30 || Global.GEChoice == 38);
			Create HUD Text(Event Player, Custom String("Target: {0} {1}", Hero Icon String(Hero Of(Global.GETarget)), Global.GETarget), Null,
				Null, Right, 0, Color(Orange), Color(White), Color(White), Visible To and String, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Last Text ID;
		"Strong Winds"
		Else If(Global.GEChoice == 39);
			"Set status id for player(if needed)"
			Create HUD Text(Event Player, Custom String("Wind Direction: {0}", Global.GEText), Null, Null, Right, 1, Color(White), Color(
				White), Color(White), Visible To and String, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Last Text ID;
		"Rigged Lottery"
		Else If(Global.GEChoice == 50);
			"Set status id for player(if needed)"
			Create HUD Text(Event Player, Custom String("Zone Choice: {0}",
				Event Player.LotteryChoice != 0 ? Event Player.LotteryChoice : Custom String("None")), Null, Null, Right, 1, Color(Yellow),
				Color(White), Color(White), Visible To and String, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Last Text ID;
	}
}

rule("Player dies (GE)")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		(Global.GEChoice == 22 || Global.GEChoice == 29 || Global.GEChoice == 36 || Global.GEChoice == 44) == True;
	}

	actions
	{
		If(Global.GEChoice == 22);
			"Piggyback"
			If(Event Player.GEHeroRider != Null);
				Call Subroutine(GEResetHeroCarrierStats);
			Else If(Event Player.GEHeroCarrier != Null);
				Call Subroutine(GEResetHeroRiderStats);
			End;
		"President"
		Else If(Global.GEChoice == 29 && Event Player.GEIsAffectedPlayer);
			Kill(Filtered Array(All Players(Team 1), Current Array Element != Event Player && !Current Array Element.IsWinner),
				Closest Player To(Position Of(Event Player), Team 2));
		Else If(Global.GEChoice == 36 && Event Player == Global.GEAffectedPlayer);
			Stop Forcing Player Outlines(Global.GEAffectedPlayer, All Players(Team 1));
			Global.GEBallPosition = Position Of(Global.GEAffectedPlayer);
			Global.GEAffectedPlayer = Null;
		Else If(Global.GEChoice == 44 && Event Player == Global.GEAffectedPlayer);
			Kill(Filtered Array(All Players(Team 1), Current Array Element != Global.GEAffectedPlayer), Closest Player To(Event Player,
				Team 2));
	}
}

rule("Player joins match (GE)")
{
	event
	{
		Player Joined Match;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGETimerStart == True;
		"Change the ID # from -1 to a positive number"
		(Global.GEChoice == 20 || Global.GEChoice == 40) == True;
	}

	actions
	{
		"Friendly Ghosts"
		If(Global.GEChoice == 20);
			Set Invisible(Event Player, All);
			Disable Movement Collision With Environment(Event Player, False);
			Disable Movement Collision With Players(Event Player);
		"Wacky Camera"
		Else If(Global.GEChoice == 40);
			Call Subroutine(SetCameraView);
	}
}

rule("Instructions for players (GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		(Global.GEChoice == 30 || Global.GEChoice == 22 || Global.GEChoice == 26 || Global.GEChoice == 41 || Global.GEChoice == 50)
			== True;
	}

	actions
	{
		If(Event Player.GEIsHeroCarrier && Event Player.GEHeroRider == Null && Global.GEChoice == 22);
			"Save IDs of something for the player(if needed)"
			Small Message(Event Player, Custom String("Press {0} to carry a player!", Input Binding String(Button(Melee))));
		Else If(Global.GEChoice == 30);
			Small Message(Event Player, Custom String("Press {0} to deflect ball!", Input Binding String(Button(Melee))));
		Else If(Global.GEChoice == 26 && Event Player.GEIsTagger);
			Small Message(Event Player, Custom String("Press {0} to tag a player!", Input Binding String(Button(Melee))));
		Else If(Global.GEChoice == 41);
			Small Message(Event Player, Custom String("{0} = heavy pulse! {1} = light pulse!", Input Binding String(Button(Primary Fire)),
				Input Binding String(Button(Secondary Fire))));
		Else If(Global.GEChoice == 50);
			Small Message(Event Player, Custom String("Hold {0} to place your bets at a zone!", Input Binding String(Button(Reload))));
		End;
		Wait(2.900, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("All players reached required number early (GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 26;
		Global.IsGETimerStart == True;
		Global.GECurReqNum >= Global.GERequiredNum;
	}

	actions
	{
		Global.IsGETimerStart = False;
		Big Message(All Players(Team 1), Custom String("Success!"));
	}
}

rule("Select a patrol guard (Patrol Guards)[SR]")
{
	event
	{
		Subroutine;
		SelectAPatrol;
	}

	actions
	{
		Global.GETempVar5 = Global.GEPatrolChoice == 0 ? Hero(Roadhog) : (Global.GEPatrolChoice == 1 ? Hero(Winston) : (
			Global.GEPatrolChoice == 2 ? Hero(Reinhardt) : (Global.GEPatrolChoice == 3 ? Hero(Widowmaker) : (
			Global.GEPatrolChoice == 4 ? Hero(Hanzo) : Hero(D.Va)))));
		For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
			If(Global.GEPatrolChoice < 3 || Global.GEPatrolChoice == 5);
				Call Subroutine(SpawnPatrolLoc);
			Else;
				Call Subroutine(SpawnDistantPatrolLoc);
			End;
			Create Dummy Bot(Global.GETempVar5, Team 2, -1, Nearest Walkable Position(Global.TempVar3), Global.TempVar4);
		End;
	}
}

rule("Set the timer for (Patrol Guards)[SR]")
{
	event
	{
		Subroutine;
		SetPatrolDuration;
	}

	actions
	{
		"Roadhog"
		If(Global.GEPatrolChoice == 0);
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(7, 11);
		"Widowmaker"
		Else If(Global.GEPatrolChoice == 3);
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(90, 120);
		"D.Va"
		Else If(Global.GEPatrolChoice == 5);
			"Set the timer for the Global Effect"
			Global.GEWaitTime = 10;
		Else;
			"Set the timer for the Global Effect"
			Global.GEWaitTime = Random Integer(60, 120);
	}
}

rule("Clean up (Patrol Guards)[SR]")
{
	event
	{
		Subroutine;
		CleanUpPatrol;
	}

	actions
	{
		Global.TempVar = Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Roadhog) || Hero Of(
			Current Array Element) == Hero(Winston) || Hero Of(Current Array Element) == Hero(Reinhardt) || Hero Of(Current Array Element)
			== Hero(Widowmaker) || Hero Of(Current Array Element) == Hero(Hanzo) || Hero Of(Current Array Element) == Hero(D.Va));
		Stop Facing(Global.TempVar);
		Stop Forcing Throttle(Global.TempVar);
		Stop Holding Button(Global.TempVar, Button(Secondary Fire));
		For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
			Destroy Dummy Bot(Team 2, Slot Of(Global.TempVar[Global.TempVar2]));
		End;
	}
}

rule("Location to spawn near a player (Patrols Guards)(GE)[SR]")
{
	event
	{
		Subroutine;
		SpawnPatrolLoc;
	}

	actions
	{
		Global.TempVar3 = Random Integer(0, 7);
		Global.GESpawnDistance = 2.500;
		If(Global.TempVar3 == 0);
			Global.TempVar3 = Eye Position(Global.TempVar[Global.TempVar2]) + Forward * Global.GESpawnDistance;
			Global.TempVar4 = Forward * -1;
		Else If(Global.TempVar3 == 1);
			Global.TempVar3 = Eye Position(Global.TempVar[Global.TempVar2]) + (Forward + Right) * Global.GESpawnDistance * -1;
			Global.TempVar4 = (Forward + Right) * -1;
		Else If(Global.TempVar3 == 2);
			Global.TempVar3 = Eye Position(Global.TempVar[Global.TempVar2]) + Right * Global.GESpawnDistance;
			Global.TempVar4 = Right * -1;
		Else If(Global.TempVar3 == 3);
			Global.TempVar3 = Eye Position(Global.TempVar[Global.TempVar2]) + (Backward + Right) * Global.GESpawnDistance * -1;
			Global.TempVar4 = (Backward + Right) * -1;
		Else If(Global.TempVar3 == 4);
			Global.TempVar3 = Eye Position(Global.TempVar[Global.TempVar2]) + Backward * Global.GESpawnDistance;
			Global.TempVar4 = Backward * -1;
		Else If(Global.TempVar3 == 5);
			Global.TempVar3 = Eye Position(Global.TempVar[Global.TempVar2]) + (Backward + Left) * Global.GESpawnDistance * -1;
			Global.TempVar4 = (Backward + Left) * -1;
		Else If(Global.TempVar3 == 6);
			Global.TempVar3 = Eye Position(Global.TempVar[Global.TempVar2]) + Left * Global.GESpawnDistance;
			Global.TempVar4 = Left * -1;
		Else;
			Global.TempVar3 = Eye Position(Global.TempVar[Global.TempVar2]) + (Forward + Left) * Global.GESpawnDistance * -1;
			Global.TempVar4 = (Forward + Left) * -1;
	}
}

rule("Location to spawn distant from a player *GLOBAL* (Patrols Guards)(GE)[SR]")
{
	event
	{
		Subroutine;
		SpawnDistantPatrolLoc;
	}

	actions
	{
		Global.TempVar3 = Random Integer(0, 16);
		Global.GESpawnDistance = Random Real(5, 70);
		If(Global.TempVar3 == 0);
			Global.TempVar3 = Nearest Walkable Position(Position Of(Global.TempVar[Global.TempVar2]) + Forward * Global.GESpawnDistance);
		Else If(Global.TempVar3 == 1);
			Global.TempVar3 = Nearest Walkable Position(Position Of(Global.TempVar[Global.TempVar2]) + (Forward + Right)
				* Global.GESpawnDistance);
		Else If(Global.TempVar3 == 2);
			Global.TempVar3 = Nearest Walkable Position(Position Of(Global.TempVar[Global.TempVar2]) + Right * Global.GESpawnDistance);
		Else If(Global.TempVar3 == 3);
			Global.TempVar3 = Nearest Walkable Position(Position Of(Global.TempVar[Global.TempVar2]) + (Backward + Right)
				* Global.GESpawnDistance);
		Else If(Global.TempVar3 == 4);
			Global.TempVar3 = Nearest Walkable Position(Position Of(Global.TempVar[Global.TempVar2]) + Backward * Global.GESpawnDistance);
		Else If(Global.TempVar3 == 5);
			Global.TempVar3 = Nearest Walkable Position(Position Of(Global.TempVar[Global.TempVar2]) + (Backward + Left)
				* Global.GESpawnDistance);
		Else If(Global.TempVar3 == 6);
			Global.TempVar3 = Nearest Walkable Position(Position Of(Global.TempVar[Global.TempVar2]) + Left * Global.GESpawnDistance);
		Else If(Global.TempVar3 == 7);
			Global.TempVar3 = Nearest Walkable Position(Position Of(Global.TempVar[Global.TempVar2]) + (Forward + Left)
				* Global.GESpawnDistance);
		Else If(Global.TempVar3 == 8);
			Global.TempVar3 = Nearest Walkable Position(Position Of(Global.TempVar[Global.TempVar2]) + (Forward + Up)
				* Global.GESpawnDistance);
		Else If(Global.TempVar3 == 9);
			Global.TempVar3 = Nearest Walkable Position(Position Of(Global.TempVar[Global.TempVar2]) + (Right + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar3 == 10);
			Global.TempVar3 = Nearest Walkable Position(Position Of(Global.TempVar[Global.TempVar2]) + (Backward + Up)
				* Global.GESpawnDistance);
		Else If(Global.TempVar3 == 11);
			Global.TempVar3 = Nearest Walkable Position(Position Of(Global.TempVar[Global.TempVar2]) + (Left + Up) * Global.GESpawnDistance);
		Else If(Global.TempVar3 == 12);
			Global.TempVar3 = Nearest Walkable Position(Position Of(Global.TempVar[Global.TempVar2]) + (Forward + Right + Up)
				* Global.GESpawnDistance);
		Else If(Global.TempVar3 == 13);
			Global.TempVar3 = Nearest Walkable Position(Position Of(Global.TempVar[Global.TempVar2]) + (Backward + Right + Up)
				* Global.GESpawnDistance);
		Else If(Global.TempVar3 == 14);
			Global.TempVar3 = Nearest Walkable Position(Position Of(Global.TempVar[Global.TempVar2]) + (Forward + Left + Up)
				* Global.GESpawnDistance);
		Else If(Global.TempVar3 == 15);
			Global.TempVar3 = Nearest Walkable Position(Position Of(Global.TempVar[Global.TempVar2]) + (Backward + Left + Up)
				* Global.GESpawnDistance);
		Else If(Global.TempVar3 == 16);
			Global.TempVar3 = Nearest Walkable Position(Position Of(Global.TempVar[Global.TempVar2]) + Up * Global.GESpawnDistance);
		End;
		Global.TempVar4 = Forward;
	}
}

rule("Location to spawn distant from a player *EVENT PLAYER* (Patrols Guards)(GE)[SR]")
{
	event
	{
		Subroutine;
		SpawnDistantPlayerPatrolLoc;
	}

	actions
	{
		Event Player.PatrolMoveStats[0] = Random Integer(0, 16);
		Event Player.PatrolMoveStats[1] = Random Real(5, 70);
		If(Event Player.PatrolMoveStats[0] == 0);
			Event Player.PatrolMoveStats[0] = Nearest Walkable Position(Position Of(Event Player) + Forward * Event Player.PatrolMoveStats[1]);
		Else If(Event Player.PatrolMoveStats[0] == 1);
			Event Player.PatrolMoveStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Forward + Right)
				* Event Player.PatrolMoveStats[1]);
		Else If(Event Player.PatrolMoveStats[0] == 2);
			Event Player.PatrolMoveStats[0] = Nearest Walkable Position(Position Of(Event Player) + Right * Event Player.PatrolMoveStats[1]);
		Else If(Event Player.PatrolMoveStats[0] == 3);
			Event Player.PatrolMoveStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Backward + Right)
				* Event Player.PatrolMoveStats[1]);
		Else If(Event Player.PatrolMoveStats[0] == 4);
			Event Player.PatrolMoveStats[0] = Nearest Walkable Position(Position Of(Event Player)
				+ Backward * Event Player.PatrolMoveStats[1]);
		Else If(Event Player.PatrolMoveStats[0] == 5);
			Event Player.PatrolMoveStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Backward + Left)
				* Event Player.PatrolMoveStats[1]);
		Else If(Event Player.PatrolMoveStats[0] == 6);
			Event Player.PatrolMoveStats[0] = Nearest Walkable Position(Position Of(Event Player) + Left * Event Player.PatrolMoveStats[1]);
		Else If(Event Player.PatrolMoveStats[0] == 7);
			Event Player.PatrolMoveStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Forward + Left)
				* Event Player.PatrolMoveStats[1]);
		Else If(Event Player.PatrolMoveStats[0] == 8);
			Event Player.PatrolMoveStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Forward + Up)
				* Event Player.PatrolMoveStats[1]);
		Else If(Event Player.PatrolMoveStats[0] == 9);
			Event Player.PatrolMoveStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Right + Up)
				* Event Player.PatrolMoveStats[1]);
		Else If(Event Player.PatrolMoveStats[0] == 10);
			Event Player.PatrolMoveStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Backward + Up)
				* Event Player.PatrolMoveStats[1]);
		Else If(Event Player.PatrolMoveStats[0] == 11);
			Event Player.PatrolMoveStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Left + Up)
				* Event Player.PatrolMoveStats[1]);
		Else If(Event Player.PatrolMoveStats[0] == 12);
			Event Player.PatrolMoveStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Forward + Right + Up)
				* Event Player.PatrolMoveStats[1]);
		Else If(Event Player.PatrolMoveStats[0] == 13);
			Event Player.PatrolMoveStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Backward + Right + Up)
				* Event Player.PatrolMoveStats[1]);
		Else If(Event Player.PatrolMoveStats[0] == 14);
			Event Player.PatrolMoveStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Forward + Left + Up)
				* Event Player.PatrolMoveStats[1]);
		Else If(Event Player.PatrolMoveStats[0] == 15);
			Event Player.PatrolMoveStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Backward + Left + Up)
				* Event Player.PatrolMoveStats[1]);
		Else If(Event Player.PatrolMoveStats[0] == 16);
			Event Player.PatrolMoveStats[0] = Nearest Walkable Position(Position Of(Event Player) + Up * Event Player.PatrolMoveStats[1]);
		End;
	}
}

rule("init Roadhogs stats (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Roadhog;
	}

	conditions
	{
		(Global.GEChoice == 1 || Global.GEChoice == 51) == True;
		Global.GEPatrolChoice == 0;
		Has Spawned(Event Player) == True;
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		Set Ultimate Ability Enabled(Event Player, True);
		Set Knockback Dealt(Event Player, Random Real(400, 500));
		Set Damage Dealt(Event Player, 0);
		Start Facing(Event Player, Position Of(Closest Player To(Event Player, Team 1)) - Event Player, 300, To World,
			Direction and Turn Rate);
		Start Throttle In Direction(Event Player, Position Of(Closest Player To(Event Player, Team 1)) - Position Of(Event Player),
			Random Real(0.500, 0.800), To World, Replace existing throttle, Direction and Magnitude);
		Set Status(Event Player, Null, Invincible, 9999);
	}
}

rule("set Roadhog ultimate (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Roadhog;
	}

	conditions
	{
		(Global.GEChoice == 1 || Global.GEChoice == 51) == True;
		Global.GEPatrolChoice == 0;
		Is Dummy Bot(Event Player) == True;
		Ultimate Charge Percent(Event Player) < 100;
	}

	actions
	{
		Set Ultimate Ability Enabled(Event Player, True);
		Set Ultimate Charge(Event Player, 100);
	}
}

rule("Use Roadhog ultimate (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Roadhog;
	}

	conditions
	{
		(Global.GEChoice == 1 || Global.GEChoice == 51) == True;
		Global.GEPatrolChoice == 0;
		Is Dummy Bot(Event Player) == True;
		Ultimate Charge Percent(Event Player) == 100;
	}

	actions
	{
		Wait(0.100, Ignore Condition);
		Press Button(Event Player, Button(Ultimate));
		Loop If Condition Is True;
	}
}

rule("init Winstons stats (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Winston;
	}

	conditions
	{
		(Global.GEChoice == 1 || Global.GEChoice == 51) == True;
		Global.GEPatrolChoice == 1;
		Has Spawned(Event Player) == True;
		Is Dummy Bot(Event Player) == True;
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		Set Ultimate Ability Enabled(Event Player, True);
		Set Damage Dealt(Event Player, 50);
		Start Facing(Event Player, Position Of(Closest Player To(Event Player, Team 1)) - Position Of(Event Player), 300, To World,
			Direction and Turn Rate);
		Start Throttle In Direction(Event Player, Position Of(Closest Player To(Event Player, Team 1)) - Event Player, Random Real(0.500,
			0.800), To World, Replace existing throttle, Direction and Magnitude);
		Allow Button(Event Player, Button(Primary Fire));
		Allow Button(Event Player, Button(Ability 1));
		Set Status(Event Player, Null, Invincible, 9999);
		Set Ultimate Charge(Event Player, 100);
		Allow Button(Event Player, Button(Ultimate));
		Wait(0.250, Ignore Condition);
		Press Button(Event Player, Button(Ultimate));
	}
}

rule("Winston Attack (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Winston;
	}

	conditions
	{
		(Global.GEChoice == 1 || Global.GEChoice == 51) == True;
		Global.GEPatrolChoice == 1;
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Primary Fire));
	}
}

rule("Winston Jumps (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Winston;
	}

	conditions
	{
		(Global.GEChoice == 1 || Global.GEChoice == 51) == True;
		Global.GEPatrolChoice == 1;
		Is Using Ultimate(Event Player) == True;
		Is Using Ability 1(Event Player) == False;
	}

	actions
	{
		Press Button(Event Player, Button(Ability 1));
		Wait(Ability Cooldown(Event Player, Button(Ability 1)), Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Teleport Winston to player (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Winston;
	}

	conditions
	{
		(Global.GEChoice == 1 || Global.GEChoice == 51) == True;
		Global.GEPatrolChoice == 1;
		Is Using Ultimate(Event Player) == True;
		Is In Line of Sight(Position Of(Closest Player To(Event Player, Team 1)), Position Of(Event Player), Barriers Do Not Block LOS)
			== False;
	}

	actions
	{
		Wait(2, Abort When False);
		Event Player.GETempVar = Random Integer(0, 3);
		If(Event Player.GETempVar == 0);
			Teleport(Event Player, Nearest Walkable Position(Eye Position(Closest Player To(Event Player, Team 1)) + Forward * 2.500));
		Else If(Event Player.GETempVar == 1 || Event Player.GETempVar == 2);
			Teleport(Event Player, Nearest Walkable Position(Eye Position(Farthest Player From(Event Player, Team 1)) + Forward * 2.500));
		Else;
			Teleport(Event Player, Nearest Walkable Position(Eye Position(Random Value In Array(Filtered Array(All Players(Team 1),
				!Current Array Element.IsWinner))) + Forward * 2.500));
		End;
		Loop If Condition Is True;
	}
}

rule("init Reinhardt stats (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		(Global.GEChoice == 1 || Global.GEChoice == 51) == True;
		Global.GEPatrolChoice == 2;
		Has Spawned(Event Player) == True;
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		Allow Button(Event Player, Button(Ability 1));
		Start Facing(Event Player, Position Of(Closest Player To(Event Player, Team 1)) - Position Of(Event Player), 500, To World,
			Direction and Turn Rate);
		Start Throttle In Direction(Event Player, Position Of(Closest Player To(Event Player, Team 1)) - Event Player, Random Real(0.300,
			0.600), To World, Replace existing throttle, Direction and Magnitude);
		Set Status(Event Player, Null, Invincible, 9999);
	}
}

rule("Reinhardt charges (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Reinhardt;
	}

	conditions
	{
		(Global.GEChoice == 1 || Global.GEChoice == 51) == True;
		Global.GEPatrolChoice == 2;
	}

	actions
	{
		Play Effect(All Players(Team 1), Bad Pickup Effect, Color(Orange), Event Player, 5);
		Play Effect(All Players(Team 1), Debuff Impact Sound, Color(White), Event Player, 80);
		Teleport(Event Player, Nearest Walkable Position(Eye Position(Random Value In Array(All Players(Team 1))) + Forward * Random Real(
			3, 5)));
		Wait(Random Real(1.500, 2.100), Abort When False);
		Press Button(Event Player, Button(Ability 1));
		Wait Until(!Is Using Ability 1(Event Player), 99999);
		If(Random Integer(0, 20) == 6);
			Communicate(Event Player, Hello);
		End;
		Wait(Ability Cooldown(Event Player, Button(Ability 1)), Abort When False);
		Loop If Condition Is True;
	}
}

rule("Init Widowmaker (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Widowmaker;
	}

	conditions
	{
		(Global.GEChoice == 1 || Global.GEChoice == 51) == True;
		Global.GEPatrolChoice == 3;
		Is Dummy Bot(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Set Status(Event Player, Null, Phased Out, 9999);
		Set Status(Event Player, Null, Invincible, 9999);
		Disable Movement Collision With Environment(Event Player, False);
		Disable Movement Collision With Players(Event Player);
		Start Holding Button(Event Player, Button(Secondary Fire));
	}
}

rule("Move Widowmaker (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Widowmaker;
	}

	conditions
	{
		(Global.GEChoice == 1 || Global.GEChoice == 51) == True;
		Global.GEPatrolChoice == 3;
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		Wait(Random Real(10, 25), Abort When False);
		Call Subroutine(SpawnDistantPlayerPatrolLoc);
		Teleport(Event Player, Event Player.PatrolMoveStats[0]);
		Play Effect(All Players(Team 1), Bad Pickup Effect, Color(Orange), Event Player, 5);
		Play Effect(All Players(Team 1), Debuff Impact Sound, Color(White), Event Player, 80);
		Loop If Condition Is True;
	}
}

rule("Target is in line of sight of Widowmaker (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Widowmaker;
	}

	conditions
	{
		(Global.GEChoice == 1 || Global.GEChoice == 51) == True;
		Global.GEPatrolChoice == 3;
		Is Dummy Bot(Event Player) == True;
		Is True For Any(All Players(Team 1), !Current Array Element.IsWinner && Is In Line of Sight(Eye Position(Event Player),
			Eye Position(Current Array Element), Barriers Do Not Block LOS)) == True;
	}

	actions
	{
		Stop Facing(Event Player);
		Event Player.GETarget = Random Value In Array(Filtered Array(All Players(Team 1),
			!Current Array Element.IsWinner && Is In Line of Sight(Eye Position(Event Player), Eye Position(Current Array Element),
			Barriers Do Not Block LOS)));
		Start Facing(Event Player, Eye Position(Event Player.GETarget) - Vector(X Component Of(Throttle Of(Event Player.GETarget) * -1)
			/ 10, 1.300, Z Component Of(Throttle Of(Event Player.GETarget) * -1) / 10) - Position Of(Event Player), 900, To World,
			Direction and Turn Rate);
		Wait(Random Real(0.900, 4), Ignore Condition);
		Press Button(Event Player, Button(Primary Fire));
		Loop If Condition Is True;
	}
}

rule("Widowmaker hits a player (Patrol Guards)(GE)")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		Widowmaker;
	}

	conditions
	{
		(Global.GEChoice == 1 || Global.GEChoice == 51) == True;
		Global.GEPatrolChoice == 3;
		Is Dummy Bot(Event Player) == True;
		Array Contains(All Tank Heroes, Hero Of(Victim)) == True;
		Event Was Critical Hit == False;
	}

	actions
	{
		Damage(Victim, Event Player, Event Damage);
	}
}

rule("Init Hanzo (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Hanzo;
	}

	conditions
	{
		(Global.GEChoice == 1 || Global.GEChoice == 51) == True;
		Global.GEPatrolChoice == 4;
		Is Dummy Bot(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Set Status(Event Player, Null, Phased Out, 9999);
		Set Status(Event Player, Null, Invincible, 9999);
		Disable Movement Collision With Environment(Event Player, False);
		Disable Movement Collision With Players(Event Player);
	}
}

rule("Set Hanzo Ult (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Hanzo;
	}

	conditions
	{
		(Global.GEChoice == 1 || Global.GEChoice == 51) == True;
		Global.GEPatrolChoice == 4;
		Is Dummy Bot(Event Player) == True;
		Has Spawned(Event Player) == True;
		Ultimate Charge Percent(Event Player) < 100;
	}

	actions
	{
		Set Ultimate Ability Enabled(Event Player, True);
		Set Ultimate Charge(Event Player, 100);
	}
}

rule("Move Hanzo (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Hanzo;
	}

	conditions
	{
		(Global.GEChoice == 1 || Global.GEChoice == 51) == True;
		Global.GEPatrolChoice == 4;
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		Wait(Random Real(5, 20), Abort When False);
		Call Subroutine(SpawnDistantPlayerPatrolLoc);
		Teleport(Event Player, Event Player.PatrolMoveStats[0]);
		Play Effect(All Players(Team 1), Bad Pickup Effect, Color(Orange), Event Player, 5);
		Play Effect(All Players(Team 1), Debuff Impact Sound, Color(White), Event Player, 80);
		Start Facing(Event Player, Eye Position(Random Value In Array(Filtered Array(All Players(Team 1),
			!Current Array Element.IsInSpawnRoom))) - Eye Position(Event Player), 2000, To World, Direction and Turn Rate);
		Press Button(Event Player, Button(Ultimate));
		Wait Until(!Is Using Ultimate(Event Player), 99999);
		Stop Facing(Event Player);
		Loop If Condition Is True;
	}
}

rule("Init D.Va (Patrol Guards)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		D.Va;
	}

	conditions
	{
		(Global.GEChoice == 1 || Global.GEChoice == 51) == True;
		Global.GEPatrolChoice == 5;
		Has Spawned(Event Player) == True;
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		Set Knockback Dealt(Event Player, 300);
		Set Status(Event Player, Null, Invincible, 9999);
		Disable Movement Collision With Environment(Event Player, False);
		Set Ultimate Ability Enabled(Event Player, True);
		Wait(Random Integer(2, 4), Ignore Condition);
		Set Facing(Event Player, Eye Position(Closest Player To(Event Player, Team 1)) - Eye Position(Event Player) + Up, To World);
		Communicate(Event Player, Hello);
		"Fly mech towards a player"
		If(Random Integer(0, 1) == 0);
			Press Button(Event Player, Button(Ability 1));
		End;
		Set Ultimate Charge(Event Player, 100);
		Wait Until(Ultimate Charge Percent(Event Player) == 100, 99999);
		Press Button(Event Player, Button(Ultimate));
	}
}

rule("Reset all players' side effects (Drug Packs)(GE)[SR]")
{
	event
	{
		Subroutine;
		ResetAllSideEffects;
	}

	actions
	{
		Global.TempVar = All Players(Team 1);
		For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
			Destroy HUD Text(Global.TempVar[Global.TempVar2].SideEffectStats[1]);
			Global.TempVar[Global.TempVar2].SideEffectStats = Null;
		End;
		Set Jump Vertical Speed(Global.TempVar, 100);
		Stop Holding Button(Global.TempVar, Button(Crouch));
		Set Aim Speed(Global.TempVar, 100);
	}
}

rule("Reset player side effect (Drug Packs)(GE)[SR]")
{
	event
	{
		Subroutine;
		ResetPlayerSideEffect;
	}

	actions
	{
		If(Global.GEToggles[2] && Event Player.SideEffectStats[0] != 0);
			Destroy HUD Text(Event Player.SideEffectStats[1]);
			If(Global.GEChoice != 28);
				Set Jump Vertical Speed(Event Player, 100);
			End;
			Set Aim Speed(Event Player, 100);
			Stop Holding Button(Event Player, Button(Crouch));
			Event Player.SideEffectStats = Null;
	}
}

rule("Player picks up health pack (Drug Packs)(GE)")
{
	event
	{
		Player Received Healing;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEToggles[2] == True;
		Event Was Health Pack == True;
		"0 = Side Effect Type"
		Event Player.SideEffectStats[0] == 0;
	}

	actions
	{
		"1 = Side Effect HUD key"
		If(Event Player.SideEffectStats[1] == Null);
			Create HUD Text(Event Player, Custom String("Side Effect Applied!"), Null, Null, Right, 2, Color(Red), Color(White), Color(White),
				Visible To and String, Default Visibility);
			Event Player.SideEffectStats[1] = Last Text ID;
		End;
		"Select a Side Effect"
		Event Player.SideEffectStats[0] = Random Integer(0, 9);
		"Slow Turn"
		If(Event Player.SideEffectStats[0] == 2);
			Set Aim Speed(Event Player, 10);
		"No Turning"
		Else If(Event Player.SideEffectStats[0] == 3);
			Set Aim Speed(Event Player, 0);
		"High Turn Speed"
		Else If(Event Player.SideEffectStats[0] == 4);
			Set Aim Speed(Event Player, 1500);
	}
}

rule("Side Effect #1: Frostbite (Drug Packs)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEToggles[2] == True;
		Event Player.SideEffectStats[0] == 1;
		Has Status(Event Player, Frozen) == False;
	}

	actions
	{
		Wait(Random Real(2, 8), Abort When False);
		Set Status(Event Player, Null, Frozen, Random Real(1, 3));
		Loop If Condition Is True;
	}
}

rule("Side Effect #5: Jumpy (Drug Packs)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEToggles[2] == True;
		Event Player.SideEffectStats[0] == 5;
		Is On Ground(Event Player) == True;
	}

	actions
	{
		Wait(Random Real(1, 8), Abort When False);
		Set Jump Vertical Speed(Event Player, Random Real(75, 300));
		Press Button(Event Player, Button(Jump));
		Loop If Condition Is True;
	}
}

rule("Side Effect #6: Crouching (Drug Packs)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEToggles[2] == True;
		Event Player.SideEffectStats[0] == 6;
		(Hero Of(Event Player) != Hero(D.Va) && Hero Of(Event Player) != Hero(Wrecking Ball)) == True;
		Is Crouching(Event Player) == False;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Crouch));
	}
}

rule("Side Effect #7A: Abilities (Drug Packs)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEToggles[2] == True;
		Event Player.SideEffectStats[0] == 7;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Wait(Random Real(0.500, 7), Abort When False);
		Press Button(Event Player, Button(Ability 1));
	}
}

rule("Side Effect #7B: Abilities (Drug Packs)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEToggles[2] == True;
		Event Player.SideEffectStats[0] == 7;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Wait(Random Real(0.500, 7), Abort When False);
		Press Button(Event Player, Button(Ability 2));
	}
}

rule("Side Effect #8: Drowsy (Drug Packs)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEToggles[2] == True;
		Event Player.SideEffectStats[0] == 8;
		Has Status(Event Player, Asleep) == False;
	}

	actions
	{
		Wait(Random Real(5, 15), Abort When False);
		Set Status(Event Player, Null, Asleep, Random Real(4, 8));
		Loop If Condition Is True;
	}
}

rule("Side Effect #9: Self-Harm (Drug Packs)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEToggles[2] == True;
		Event Player.SideEffectStats[0] == 9;
	}

	actions
	{
		Wait(Random Real(1, 10), Abort When False);
		Damage(Event Player, Closest Player To(Event Player, Team 2), Max Health(Event Player) * Random Real(0.100, 0.300));
		Loop If Condition Is True;
	}
}

rule("Players die while drugged (Drug Packs)(GE)")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEToggles[2] == True;
		Event Player.SideEffectStats[0] != 0;
	}

	actions
	{
		Call Subroutine(ResetPlayerSideEffect);
		If(Global.BacktrackDeathsWS != 0);
			Event Player.BacktrackDeaths += 1;
			Call Subroutine(SavePlayerData);
	}
}

rule("Player on foot (Lava Floor)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 3;
		Global.IsGETimerStart == True;
		Event Player.IsInSpawnRoom == False;
		Event Player.IsWinner == False;
		Is In Air(Event Player) == False;
		Event Player.GEID == Null;
	}

	actions
	{
		Set Status(Event Player, Null, Burning, 9999);
		Start Damage Over Time(Event Player, Null, 9999, Random Real(40, 100));
		Event Player.GEID = Last Damage Over Time ID;
	}
}

rule("Player in air (Lava Floor)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 3;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEID != Null;
		(Is In Air(Event Player) || Is In Spawn Room(Event Player)) == True;
	}

	actions
	{
		Clear Status(Event Player, Burning);
		Stop Damage Over Time(Event Player.GEID);
		Event Player.GEID = Null;
	}
}

rule("Notify players who AREN'T (Invincible)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEChoice == 6;
		Global.IsGETimerStart == True;
		Event Player.GEHUDID == -2;
	}

	actions
	{
		Create HUD Text(Event Player, Custom String("Not Invincible!"), Null, Null, Right, 0, Color(Red), Color(White), Color(White),
			Visible To, Default Visibility);
		Event Player.GEHUDID = Last Text ID;
	}
}

rule("Notify players who ARE (Invincible) (GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEChoice == 6;
		Global.IsGETimerStart == True;
		Event Player.GEHUDID == Null;
	}

	actions
	{
		Create HUD Text(Event Player, Custom String("You are Invincible!"), Null, Null, Right, 0, Color(Yellow), Color(White), Color(
			White), Visible To, Default Visibility);
		Event Player.GEHUDID = Last Text ID;
		Create Effect(All Players(Team 1), Orisa Amplifier Sound, Color(White), Event Player, 80, Visible To Position and Radius);
		Event Player.GEID = Last Created Entity;
	}
}

rule("Player communicates (Communicate or Die)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 7;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GECount < Global.GERequiredNum;
		"Player will have to delay their \"Hello\" by 5 seconds for input to be read. !Overwatch issue!"
		(Is Communicating(Event Player, Hello) || Is Communicating(Event Player, Need Healing) || Is Communicating(Event Player, Group Up)
			|| Is Communicating(Event Player, Thanks) || Is Communicating(Event Player, Acknowledge) || Is Communicating(Event Player,
			Press the Attack) || Is Communicating(Event Player, You are Welcome) || Is Communicating(Event Player, Yes)
			|| Is Communicating(Event Player, No) || Is Communicating(Event Player, Goodbye) || Is Communicating(Event Player, Go)
			|| Is Communicating(Event Player, Ready) || Is Communicating(Event Player, Fall Back) || Is Communicating(Event Player,
			Push Forward) || Is Communicating(Event Player, Incoming) || Is Communicating(Event Player, With You) || Is Communicating(
			Event Player, Going In) || Is Communicating(Event Player, On My Way) || Is Communicating(Event Player, Attacking)
			|| Is Communicating(Event Player, Defending) || Is Communicating(Event Player, Need Help) || Is Communicating(Event Player,
			Sorry) || Is Communicating(Event Player, Countdown) || Is Communicating(Event Player, Ultimate Status)) == True;
	}

	actions
	{
		"Set status id for player(if needed)"
		Event Player.GECount += 1;
		Play Effect(Event Player, Buff Explosion Sound, Color(White), Event Player, 90);
		Play Effect(All Players(Team 1), Good Explosion, Color(White), Event Player, 1);
	}
}

rule("Set sphere radius effect (I'm the Bomb/Personal Space)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.GEID == -1;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Is In Spawn Room(Event Player) == False;
		"Change the ID # from -1 to a positive number"
		(Global.GEChoice == 8 || Global.GEChoice == 14) == True;
		Array Contains(Global.GECarriers, Event Player) == True;
	}

	actions
	{
		Start Forcing Player Outlines(Event Player, Filtered Array(All Players(Team 1), Current Array Element != Event Player), True,
			Color(Orange), Always);
		If(Global.GEChoice == 8);
			"Count the number of times something happens (if neccessary)"
			Create Effect(Filtered Array(All Players(Team 1), Current Array Element != Event Player), Sphere, Color(Red), Event Player,
				Global.GERadius, Visible To Position and Radius);
		Else If(Global.GEChoice == 14);
			Create Effect(Filtered Array(All Players(Team 1), Current Array Element != Event Player), Sphere, Color(White), Event Player,
				Global.GERadius, Visible To Position and Radius);
		End;
		"Save id of something for the player(if needed)"
		Event Player.GEID = Last Created Entity;
	}
}

rule("Player is with partner (Passenger)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 9;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Is True For Any(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Off),
			Current Array Element != Event Player) == True;
	}

	actions
	{
		Start Forcing Player Outlines(Event Player, All Players(Team 1), True, Color(Lime Green), Always);
		Set Move Speed(Event Player, 120);
		Wait(0.300, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Player is without partner (Passenger)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 9;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Is True For Any(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Off),
			Current Array Element != Event Player) == False;
	}

	actions
	{
		Start Forcing Player Outlines(Event Player, All Players(Team 1), True, Color(Purple), Always);
		Set Move Speed(Event Player, 50);
		Wait(0.300, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Select Bastion buff upgrade (GE)[Buff][BU][SR]")
{
	event
	{
		Subroutine;
		SelectBastionBuffUpgrade;
	}

	actions
	{
		Global.TempVar4 = Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Bastion));
		Set Projectile Speed(Global.TempVar4, Global.BUChoices[0] == 4 ? 135 : 100);
		Global.BastionDamages[2] = 0;
		If(Global.BUChoices[3] == 1);
			Set Projectile Speed(Global.TempVar4, 200);
		"Damage Boost"
		Else If(Global.BUChoices[3] == 2);
			Global.BastionDamages[2] = 50;
		"Ample Damage Boost"
		Else If(Global.BUChoices[3] == 3);
			Global.BastionDamages[2] = 75;
		End;
		Call Subroutine(SetGEBastionDamage);
	}
}

rule("Teleport Bastion on top of a player (Bastion Drop)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.GEChoice == 11;
		Global.IsGETimerStart == True;
		Is True For Any(All Players(Team 1), !Current Array Element.IsInSpawnRoom) == True;
	}

	actions
	{
		Wait(Random Real(15, 20), Abort When False);
		Global.TempVar = Players In Slot(Count Of(Global.AllBastionPositions) - 1, Team 2);
		Global.TempVar2 = Random Value In Array(Filtered Array(All Players(Team 1), !Current Array Element.IsInSpawnRoom));
		Abort If Condition Is False;
		Global.AllBastionPositions[Count Of(Global.AllBastionPositions) - 1] = Position Of(Global.TempVar2);
		Teleport(Global.TempVar, Global.AllBastionPositions[Count Of(Global.AllBastionPositions) - 1]);
		Set Status(Global.TempVar, Null, Frozen, 1);
		Play Effect(All Players(Team 1), Ring Explosion Sound, Color(White), Position Of(Global.TempVar), 90);
		Play Effect(All Players(Team 1), Bad Pickup Effect, Color(Orange), Position Of(Global.TempVar), 3);
		Loop If Condition Is True;
	}
}

rule("Player emotes (Emote or Die)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 13;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GECount < Global.GERequiredNum;
		Is Communicating Any Emote(Event Player) == True;
	}

	actions
	{
		"Set status id for player(if needed)"
		Event Player.GECount += 1;
		Play Effect(Event Player, Buff Explosion Sound, Color(White), Event Player, 90);
		Play Effect(All Players(Team 1), Good Explosion, Color(White), Event Player, 3);
	}
}

rule("Push players within radius (Personal Space)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 14;
		Global.IsGETimerStart == True;
		Is In Spawn Room(Event Player) == False;
		Event Player.IsWinner == False;
		Is True For Any(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Off),
			Current Array Element != Event Player) == True;
		Array Contains(Global.GECarriers, Event Player) == True;
	}

	actions
	{
		Global.TempVar = Filtered Array(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Off),
			Current Array Element != Event Player);
		"Count the number of times something happens (if neccessary)"
		For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
			Apply Impulse(Global.TempVar[Global.TempVar2], Position Of(Global.TempVar[Global.TempVar2]) - Position Of(Event Player),
				Random Integer(7000, 9000), To World, Cancel Contrary Motion);
			Play Effect(All Living Players(Team 1), Explosion Sound, Color(Yellow), Position Of(Event Player), 90);
			Play Effect(All Living Players(Team 1), Good Explosion, Color(Yellow), Position Of(Event Player), Global.GERadius);
		End;
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Player uses voice line (Voice Line or Die)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 15;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GECount < Global.GERequiredNum;
		"Player will have to delay their \"Hello\" by 5 seconds for input to be read. !Overwatch issue!"
		Is Communicating Any Voice line(Event Player) == True;
	}

	actions
	{
		"Set status id for player(if needed)"
		Event Player.GECount += 1;
		Play Effect(Event Player, Buff Explosion Sound, Color(White), Event Player, 90);
		Play Effect(All Players(Team 1), Good Explosion, Color(White), Event Player, 1);
	}
}

rule("Kill nearby players (Die with Me!)(GE)")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEChoice == 17;
		Global.IsGETimerStart == True;
	}

	actions
	{
		"Save IDs of something for the player(if needed)"
		Event Player.GETempVar = Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Off);
		"Save IDs of something for the player(if needed)"
		Kill(Filtered Array(Event Player.GETempVar, (Hero Of(Current Array Element) == Hero(D.Va) && Is In Alternate Form(
			Current Array Element)) || (Hero Of(Current Array Element) != Hero(D.Va))), Closest Player To(Position Of(Event Player),
			Team 2));
		Event Player.GETempVar = Filtered Array(Event Player.GETempVar, Hero Of(Current Array Element) == Hero(D.Va)
			&& !Is In Alternate Form(Current Array Element));
		If(Count Of(Event Player.GETempVar) > 0);
			"Save IDs of something for the player(if needed)"
			Kill(Event Player.GETempVar, Closest Player To(Position Of(Event Player), Team 2));
			Wait(1, Ignore Condition);
			"Save IDs of something for the player(if needed)"
			Kill(Event Player.GETempVar, Closest Player To(Position Of(Event Player), Team 2));
	}
}

rule("Player looks at a (Medusa) (GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 19;
		Global.IsGETimerStart == True;
		Is In Spawn Room(Event Player) == False;
		Event Player.IsWinner == False;
		Is True For Any(Players in View Angle(Event Player, Team 1, Global.GEViewAngle), Array Contains(Global.GECarriers,
			Current Array Element) && Is In Line of Sight(Position Of(Event Player), Position Of(Current Array Element),
			Barriers Do Not Block LOS)) == True;
	}

	actions
	{
		Set Status(Event Player, Null, Frozen, 9999);
		Wait(0.250, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Player not looking at a (Medusa) (GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 19;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Is In Spawn Room(Event Player) == False;
		Is True For Any(Players in View Angle(Event Player, Team 1, Global.GEViewAngle), Array Contains(Global.GECarriers,
			Current Array Element) && Is In Line of Sight(Position Of(Event Player), Position Of(Current Array Element),
			Barriers Do Not Block LOS)) == False;
	}

	actions
	{
		Wait(1.800, Abort When False);
		"Save IDs of something for the player(if needed)"
		Clear Status(Event Player, Frozen);
	}
}

rule("Player is in spawn room (Medusa) (GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 19;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Is In Spawn Room(Event Player) == True;
		Has Status(Event Player, Frozen) == True;
	}

	actions
	{
		"Save IDs of something for the player(if needed)"
		Clear Status(Event Player, Frozen);
	}
}

rule("Sleeping player (Sleepy TBags)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 21;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Has Status(Event Player, Asleep) == True;
		Is True For Any(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Surfaces),
			!Current Array Element.IsWinner && !Has Status(Current Array Element, Asleep)) == True;
	}

	actions
	{
		Event Player.GETempVar = Filtered Array(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Surfaces),
			!Has Status(Current Array Element, Asleep) && !Current Array Element.IsWinner);
		For Player Variable(Event Player, loopNum, 0, Count Of(Event Player.GETempVar), 1);
			If(Is Crouching(Event Player.GETempVar[Event Player.loopNum]) == True);
				Event Player.GETempVar[Event Player.loopNum].IsGETBagCrouched = True;
			Else If(Is Standing(Event Player.GETempVar[Event Player.loopNum])
					&& Event Player.GETempVar[Event Player.loopNum].IsGETBagCrouched);
				Event Player.GETempVar[Event Player.loopNum].IsGETBagStand = True;
			End;
		End;
		Wait(0.200, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Player has made a complete TBag sequence (Sleepy TBags)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 21;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Has Status(Event Player, Asleep) == False;
		Event Player.IsGETBagCrouched == True;
		Event Player.IsGETBagStand == True;
		Event Player.GECount < Global.GERequiredNum;
	}

	actions
	{
		Event Player.IsGETBagCrouched = False;
		Event Player.IsGETBagStand = False;
		Event Player.GECount += 1;
		Play Effect(All Players(Team 1), Ring Explosion, Color(White), Event Player, 2);
		Play Effect(All Players(Team 1), Ring Explosion Sound, Color(White), Event Player, 80);
	}
}

rule("Player walks away from sleeper (Sleepy TBags)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 21;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GECount < Global.GERequiredNum;
		Has Status(Event Player, Asleep) == False;
		Is True For All(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Surfaces), !Has Status(
			Current Array Element, Asleep)) == True;
	}

	actions
	{
		Event Player.GECount = 0;
		Event Player.IsGETBagCrouched = False;
		Event Player.IsGETBagStand = False;
	}
}

rule("Player has completed the required TBag limit (Sleepy TBags)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 21;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEHUDID != -1;
		Has Status(Event Player, Asleep) == False;
		Event Player.GECount >= Global.GERequiredNum;
	}

	actions
	{
		Set Move Speed(Event Player, 180);
		Global.TempVar = First Of(Filtered Array(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Off),
			Has Status(Current Array Element, Asleep)));
		Clear Status(Global.TempVar, Asleep);
		Stop Forcing Player Outlines(Global.TempVar, All Players(Team 1));
		Destroy HUD Text(Event Player.GEHUDID);
		Event Player.GEHUDID = -1;
	}
}

rule("Init Carrier players (Piggyback)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 22;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEIsHeroCarrier == True;
		Event Player.GEHUDID == Null;
	}

	actions
	{
		Create HUD Text(Event Player, Custom String("Status: Carrier"), Null, Null, Right, 0, Color(Yellow), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Event Player.GEHUDID = Array(Last Text ID);
		Create HUD Text(Event Player, Custom String("Rider: {0}", Global.TempVar.GEHeroRider), Null, Null, Right, 0, Color(Orange), Color(
			White), Color(White), Visible To and String, Default Visibility);
		Modify Player Variable(Event Player, GEHUDID, Append To Array, Last Text ID);
		Start Forcing Player Outlines(Event Player, All Players(Team 1), True, Color(Orange), Always);
	}
}

rule("Reset Carrier stats & release rider(Piggyback)(GE)[SR]")
{
	event
	{
		Subroutine;
		GEResetHeroCarrierStats;
	}

	actions
	{
		If(Global.IsGETimerStart && Global.GEChoice == 22 && Event Player.GEHeroRider != Null);
			Detach Players(Event Player.GEHeroRider);
			Stop Scaling Player(Event Player.GEHeroRider);
			Destroy HUD Text(Event Player.GEHeroRider.GEHUDID);
			Event Player.GEHeroRider.GEHeroCarrier = Null;
			Clear Status(Event Player.GEHeroRider, Unkillable);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHeroRider = Null;
	}
}

rule("Reset Rider stats & release (Piggyback)(GE)[SR]")
{
	event
	{
		Subroutine;
		GEResetHeroRiderStats;
	}

	actions
	{
		If(Global.IsGETimerStart && Global.GEChoice == 22 && Event Player.GEHeroCarrier != Null);
			"Count the number of times something happens (if neccessary)"
			Detach Players(Event Player);
			Stop Scaling Player(Event Player);
			Event Player.GEHeroCarrier.GEHeroRider = Null;
			"Save IDs of something for the player(if needed)"
			Event Player.GEHeroCarrier = Null;
			Destroy HUD Text(Event Player.GEHUDID);
			Clear Status(Event Player, Unkillable);
	}
}

rule("Carrier reaches goal with a Rider (PiggyBack)(GE)[SR]")
{
	event
	{
		Subroutine;
		PromoteHeroRider;
	}

	actions
	{
		If(Global.IsGETimerStart && Global.GEChoice == 22 && Event Player.GEHeroRider != Null);
			Detach Players(Event Player.GEHeroRider);
			Stop Scaling Player(Event Player.GEHeroRider);
			Destroy HUD Text(Event Player.GEHeroRider.GEHUDID);
			Event Player.GEHeroRider.GEHeroCarrier = Null;
			Clear Status(Event Player.GEHeroRider, Unkillable);
			Teleport(Event Player.GEHeroRider, Position Of(Event Player));
			"Save IDs of something for the player(if needed)"
			Event Player.GEHeroRider = Null;
	}
}

rule("A Carrier or Rider left the game (Piggyback)(GE)")
{
	event
	{
		Player Left Match;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 22;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
	}

	actions
	{
		If(Event Player.GEIsHeroCarrier && Event Player.GEHeroRider != Null);
			Call Subroutine(GEResetHeroCarrierStats);
		Else If(!Event Player.GEIsHeroCarrier && Event Player.GEHeroCarrier != Null);
			Call Subroutine(GEResetHeroRiderStats);
	}
}

rule("Grabs a Rider(Piggyback)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 22;
		Global.IsGETimerStart == True;
		Is In Spawn Room(Event Player) == False;
		Event Player.IsWinner == False;
		Event Player.GEIsHeroCarrier == True;
		Event Player.GEHeroRider == Null;
		Is Button Held(Event Player, Button(Melee)) == True;
		Is True For Any(Players in View Angle(Event Player, Team 1, Global.GEViewAngle), Distance Between(Position Of(Event Player),
			Position Of(Current Array Element)) <= Global.GEMeleeDistance && Is In Line of Sight(Position Of(Event Player), Position Of(
			Current Array Element), Barriers Do Not Block LOS)
			&& !Current Array Element.IsWinner && !Current Array Element.GEIsHeroCarrier) == True;
	}

	actions
	{
		"Save IDs of something for the player(if needed)"
		Event Player.GEHeroRider = First Of(Filtered Array(Players in View Angle(Event Player, Team 1, Global.GEViewAngle),
			Distance Between(Position Of(Event Player), Position Of(Current Array Element))
			<= Global.GEMeleeDistance && Is In Line of Sight(Position Of(Event Player), Position Of(Current Array Element),
			Barriers Do Not Block LOS) && !Current Array Element.IsWinner && !Current Array Element.GEIsHeroCarrier));
		Event Player.GEHeroRider.GEHeroCarrier = Event Player;
		"Count the number of times something happens (if neccessary)"
		Attach Players(Event Player.GEHeroRider, Event Player, Vector(0, 0.900, -0.425));
		Start Scaling Player(Event Player.GEHeroRider, 0.400, False);
		Play Effect(All Players(Team 1), Good Pickup Effect, Color(Yellow), Event Player, 3);
		Play Effect(All Players(Team 1), Explosion Sound, Color(White), Event Player, 90);
		Create HUD Text(Event Player.GEHeroRider, Custom String("You are being carried!"), Null, Null, Right, 0, Color(Yellow), Color(
			White), Color(White), Visible To, Default Visibility);
		Event Player.GEHeroRider.GEHUDID = Last Text ID;
		Set Status(Event Player.GEHeroRider, Null, Unkillable, 9999);
	}
}

rule("When Carrier enters spawn, detach Rider(Piggyback)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 22;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEHeroRider != Null;
		Is In Spawn Room(Event Player) == True;
	}

	actions
	{
		"Count the number of times something happens (if neccessary)"
		Call Subroutine(GEResetHeroCarrierStats);
	}
}

rule("Make sure Rider is being carried (Piggyback)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 22;
		Is In Spawn Room(Event Player) == False;
		Event Player.IsWinner == False;
		Event Player.GEIsHeroCarrier == True;
		Event Player.GEHeroRider != Null;
		Distance Between(Position Of(Event Player), Position Of(Event Player.GEHeroRider)) > 1.200;
	}

	actions
	{
		"Count the number of times something happens (if neccessary)"
		Attach Players(Event Player.GEHeroRider, Event Player, Vector(0, 0.900, -0.425));
		Start Scaling Player(Event Player.GEHeroRider, 0.400, False);
		Set Status(Event Player.GEHeroRider, Null, Unkillable, 9999);
	}
}

rule("Init players (Guardian Angel) (GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 23;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEHUDID == Null;
		(Event Player.GEGuardianAngel != Null || Event Player.GEHumanProtect != Null) == True;
	}

	actions
	{
		If(Event Player.GEHumanProtect != Null);
			Create HUD Text(Event Player, Custom String("Status: Guardian Angel"), Null, Null, Right, 0, Color(Yellow), Color(White), Color(
				White), Visible To, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Array(Last Text ID);
			Create HUD Text(Event Player, Custom String("Protecting: {0}", Hero Icon String(Hero Of(Event Player.GEHumanProtect))), Null, Null,
				Right, 0, Color(Green), Color(White), Color(White), Visible To and String, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Modify Player Variable(Event Player, GEHUDID, Append To Array, Last Text ID);
			Start Forcing Player Outlines(Event Player, Event Player.GEHumanProtect, True, Color(Yellow), Always);
		Else If(Event Player.GEGuardianAngel != Null);
			Create HUD Text(Event Player, Custom String("Status: Human"), Null, Null, Right, 0, Color(Yellow), Color(White), Color(White),
				Visible To, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Event Player.GEHUDID = Array(Last Text ID);
			Create HUD Text(Event Player, Custom String("Guardian Angel: {0}", Hero Icon String(Hero Of(Event Player.GEGuardianAngel))), Null,
				Null, Right, 0, Color(Green), Color(White), Color(White), Visible To and String, Default Visibility);
			"Save IDs of something for the player(if needed)"
			Modify Player Variable(Event Player, GEHUDID, Append To Array, Last Text ID);
			Start Forcing Player Outlines(Event Player, Event Player.GEGuardianAngel, True, Color(Yellow), Always);
			Set Status(Event Player, Null, Unkillable, 9999);
	}
}

rule("Human about to die (Guardian Angel)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 23;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEGuardianAngel != Null;
		Health(Event Player) == 1;
	}

	actions
	{
		"Completely kill D.va in mech"
		If(Hero Of(Event Player.GEGuardianAngel) == Hero(D.Va) && !Is In Alternate Form(Event Player.GEGuardianAngel));
			Kill(Event Player.GEGuardianAngel, Closest Player To(Position Of(Event Player), Team 2));
			Wait(1, Ignore Condition);
			Kill(Event Player.GEGuardianAngel, Closest Player To(Position Of(Event Player), Team 2));
		Else;
			Kill(Event Player.GEGuardianAngel, Closest Player To(Position Of(Event Player), Team 2));
		End;
		Destroy HUD Text(Event Player.GEHUDID[0]);
		Destroy HUD Text(Event Player.GEHUDID[1]);
		Destroy HUD Text(Event Player.GEGuardianAngel.GEHUDID[0]);
		Destroy HUD Text(Event Player.GEGuardianAngel.GEHUDID[1]);
		Event Player.GEHUDID = Null;
		Event Player.GEGuardianAngel.GEHUDID = Null;
		Stop Forcing Player Outlines(Event Player, All Players(Team 1));
		Stop Forcing Player Outlines(Event Player.GEGuardianAngel, All Players(Team 1));
		Event Player.GEGuardianAngel.GEHumanProtect = Null;
		Event Player.GEGuardianAngel = Null;
		Wait(3, Ignore Condition);
		Clear Status(Event Player, Unkillable);
	}
}

rule("Promote wingman when player reaches goal (Wingman)(GE)[SR]")
{
	event
	{
		Subroutine;
		GEPromoteWingman;
	}

	actions
	{
		If(Global.GEChoice == 24 && Event Player.GEPartner != Null && !Event Player.GEIsAffectedPlayer);
			Event Player.GEIsAffectedPlayer = True;
			If(!Event Player.GEPartner.GEIsAffectedPlayer);
				Teleport(Event Player.GEPartner, Global.EndPosition + Vector(0, 5, 0));
			End;
			If(Event Player.GEPartner.GEIsAffectedPlayer && Event Player.GEIsAffectedPlayer);
				Event Player.GEPartner.GEIsAffectedPlayer = False;
				Event Player.GEIsAffectedPlayer = False;
			End;
	}
}

rule("Init wingman (Wingman)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 24;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEPartner == Null;
	}

	actions
	{
		Event Player.GEPartner = Random Value In Array(Filtered Array(All Players(Team 1),
			Current Array Element.GEPartner == Null && !Current Array Element.IsWinner && Current Array Element != Event Player));
		Abort If(Event Player.GEPartner == Null);
		Event Player.GEPartner.GEPartner = Event Player;
		"Self Initialization"
		Start Forcing Player Outlines(Event Player, Event Player.GEPartner, True, Color(Yellow), Always);
		Create HUD Text(Event Player, Custom String("Wingman: {0}", Event Player.GEPartner), Null, Null, Right, 0, Color(Yellow), Color(
			White), Color(White), Visible To and String, Default Visibility);
		Event Player.GEHUDID = Last Text ID;
		Create Beam Effect(Event Player, Good Beam, Event Player, Event Player.GEPartner, Distance Between(Position Of(Event Player),
			Position Of(Event Player.GEPartner)) <= Global.GERadius ? Color(Green) : Color(Orange), Visible To Position Radius and Color);
		Event Player.GEID = Last Created Entity;
		"Wingman Initialization"
		Start Forcing Player Outlines(Event Player.GEPartner, Event Player, True, Color(Yellow), Always);
		Create HUD Text(Event Player.GEPartner, Custom String("Wingman: {0}", Event Player.GEPartner.GEPartner), Null, Null, Right, 0,
			Color(Yellow), Color(White), Color(White), Visible To and String, Default Visibility);
		Event Player.GEPartner.GEHUDID = Last Text ID;
		Create Beam Effect(Event Player.GEPartner, Good Beam, Event Player.GEPartner, Event Player, Distance Between(Position Of(
			Event Player.GEPartner), Position Of(Event Player)) <= Global.GERadius ? Color(Green) : Color(Orange),
			Visible To Position Radius and Color);
		Event Player.GEPartner.GEID = Last Created Entity;
	}
}

rule("Player is far from wingman (Wingman)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 24;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEPartner != Null;
		Distance Between(Position Of(Event Player), Position Of(Event Player.GEPartner)) > Global.GERadius + 2;
	}

	actions
	{
		Respawn(Event Player);
		Call Subroutine(SpawnAtAltLoc);
		Respawn(Event Player.GEPartner);
		If(Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter));
			Teleport(Event Player.GEPartner, Global.BlizzWorldSpawnLoc);
			Set Facing(Event Player.GEPartner, Forward + Left, To World);
		Else If(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween));
			Teleport(Event Player.GEPartner, Global.HollywoodSpawns[0]);
			Set Facing(Event Player.GEPartner, Right, To World);
		End;
		Small Message(Event Player, Custom String("Stay close to your wingman!"));
		Small Message(Event Player.GEPartner, Custom String("Stay close to your wingman!"));
	}
}

rule("Player dies (Wingman)(GE)")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 24;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEPartner != Null;
	}

	actions
	{
		"D.va has two forms. This is used to completely kill D.va"
		If(Hero Of(Event Player.GEPartner) == Hero(D.Va) && !Is In Alternate Form(Event Player.GEPartner));
			Kill(Event Player.GEPartner, Closest Player To(Position Of(Event Player.GEPartner), Team 2));
			Wait(1, Ignore Condition);
			Kill(Event Player.GEPartner, Closest Player To(Position Of(Event Player.GEPartner), Team 2));
		Else;
			Kill(Event Player.GEPartner, Closest Player To(Position Of(Event Player.GEPartner), Team 2));
	}
}

rule("Init (Staring Contest)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 25;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
	}

	actions
	{
		Wait Until(Event Player.GEPartner == Null, Random Real(10, 30));
		Abort If Condition Is False;
		Stop Facing(Event Player);
		Event Player.GEPartner = Random Value In Array(Filtered Array(All Players(All Teams),
			Event Player != Current Array Element && Event Player.GEPartner != Current Array Element && !Current Array Element.IsWinner));
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.GEPartner)), 100, To World,
			Direction and Turn Rate);
		Wait(0.016, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Init Tagger outline(World Tag)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 26;
		Global.IsGETimerStart == True;
		Event Player.GEIsTagger == True;
		Event Player.IsWinner == False;
	}

	actions
	{
		Start Forcing Player Outlines(Event Player, All Players(Team 1), True, Color(Yellow), Always);
	}
}

rule("Tagger tags a player (World Tag)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 26;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEIsTagger == True;
		Is Button Held(Event Player, Button(Melee)) == True;
		Is True For Any(Players in View Angle(Event Player, Team 1, Global.GEViewAngle), Distance Between(Position Of(Event Player),
			Position Of(Current Array Element)) < Global.GEMeleeDistance && Is In Line of Sight(Position Of(Event Player), Position Of(
			Current Array Element), Barriers Do Not Block LOS) && !Current Array Element.IsWinner && !Current Array Element.GEIsTagged)
			== True;
	}

	actions
	{
		"Save IDs of something for the player(if needed)"
		Global.TempVar = First Of(Filtered Array(Players in View Angle(Event Player, Team 1, Global.GEViewAngle), Distance Between(
			Position Of(Event Player), Position Of(Current Array Element)) < Global.GEMeleeDistance && Is In Line of Sight(Position Of(
			Event Player), Position Of(Current Array Element), Barriers Do Not Block LOS)
			&& !Current Array Element.IsWinner && !Current Array Element.GEIsTagged));
		"Count the number of times something happens (if neccessary)"
		Global.TempVar.GEIsTagger = True;
		"Count the number of times something happens (if neccessary)"
		Global.TempVar.GEIsTagged = True;
		Start Forcing Player Outlines(Global.TempVar, All Players(Team 1), True, Color(Yellow), Always);
		Event Player.GEIsTagger = False;
		Global.GECurReqNum += 1;
		Play Effect(All Players(Team 1), Good Pickup Effect, Color(Yellow), Event Player, 4);
		Play Effect(All Players(Team 1), Buff Explosion Sound, Color(White), Event Player, 80);
		Start Forcing Player Outlines(Event Player, All Players(Team 1), True, Color(Orange), Always);
	}
}

rule("Player is going to be squished (Bugs & Growth Spurt)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		(Global.GEChoice == 27 || Global.GEChoice == 46) == True;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.IsInSpawnRoom == False;
		Event Player.GEIsAffectedPlayer == True;
		Is True For Any(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Surfaces),
			!Current Array Element.GEIsAffectedPlayer) == True;
	}

	actions
	{
		Play Effect(All Players(Team 1), Brigitte Repair Pack Armor Sound, Color(White), Event Player, 90);
		If(Global.GEChoice == 27);
			If(Hero Of(Event Player) == Hero(D.Va) && !Is In Alternate Form(Event Player));
				Kill(Event Player, Closest Player To(Position Of(Event Player), Team 2));
				Wait(1, Ignore Condition);
				Kill(Event Player, Closest Player To(Position Of(Event Player), Team 2));
			Else;
				Kill(Event Player, Closest Player To(Position Of(Event Player), Team 2));
			End;
			Communicate(Event Player, Thanks);
			Communicate(First Of(Filtered Array(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Surfaces),
				!Current Array Element.GEIsAffectedPlayer)), Sorry);
		Else;
			If(Hero Of(Event Player) == Hero(D.Va) && !Is In Alternate Form(Event Player));
				Kill(Closest Player To(Event Player, Team 1), Closest Player To(Position Of(Event Player), Team 2));
				Wait(1, Ignore Condition);
				Kill(Closest Player To(Event Player, Team 1), Closest Player To(Position Of(Event Player), Team 2));
			Else;
				Kill(Closest Player To(Event Player, Team 1), Closest Player To(Position Of(Event Player), Team 2));
			End;
			Communicate(First Of(Filtered Array(Players Within Radius(Position Of(Event Player), Global.GERadius, Team 1, Surfaces),
				!Current Array Element.GEIsAffectedPlayer)), Thanks);
			Communicate(Event Player, Sorry);
		End;
	}
}

rule("Choose a new President (President)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 29;
		Global.IsGETimerStart == True;
		Is True For All(All Players(Team 1), !Current Array Element.GEIsAffectedPlayer) == True;
	}

	actions
	{
		Global.TempVar = Random Value In Array(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
		Global.TempVar.GEIsAffectedPlayer = True;
		Set Max Health(Global.TempVar, 10);
		Start Forcing Player Outlines(Global.TempVar, All Players(Team 1), True, Color(Yellow), Always);
	}
}

rule("Init Bodyguards (President)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 29;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEIsAffectedPlayer == False;
	}

	actions
	{
		Set Max Health(Event Player, 150);
	}
}

rule("Set move speed of Ball (Extreme Pong)(GE)[SR]")
{
	event
	{
		Subroutine;
		GESetPongBallSpeed;
	}

	actions
	{
		If(Distance Between(Eye Position(Global.GETarget) - Vector(0, 0.500, 0), Global.GEBallPosition) <= 7);
			Global.GEBallSpeed = 6;
		Else;
			Global.GEBallSpeed = 30;
	}
}

rule("Init Extreme Pong game (Extreme Pong)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 30;
		Global.IsGETimerStart == True;
		Global.GETarget == Null;
	}

	actions
	{
		Global.GETarget = Random Value In Array(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner));
		If(Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter));
			Global.GEBallPosition = Global.BlizzWorldSpawnLoc + Vector(0, 3, 0);
		Else If(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween));
			Global.GEBallPosition = Global.HollywoodSpawns[0] + Vector(0, 3, 0);
		Else;
			Global.GEBallPosition = Random Value In Array(Spawn Points(Team 1)) + Vector(0, 3, 0);
		End;
		Wait(2.500, Ignore Condition);
		Chase Global Variable At Rate(GEBallPosition, Eye Position(Global.GETarget) - Vector(0, 0.500, 0), Global.GEBallSpeed,
			Destination and Rate);
		Loop If Condition Is True;
	}
}

rule("Target hits Ball (Extreme Pong)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 30;
		Global.IsGETimerStart == True;
		Global.GETarget == Event Player;
		Is Button Held(Event Player, Button(Melee)) == True;
		Distance Between(Eye Position(Event Player) - Vector(0, 0.500, 0), Global.GEBallPosition) < Global.GEMeleeDistance;
	}

	actions
	{
		Stop Chasing Global Variable(GEBallPosition);
		Play Effect(All Players(Team 1), Buff Explosion Sound, Color(White), Event Player, 90);
		Global.GETarget = Random Value In Array(Filtered Array(All Players(Team 1),
			Current Array Element != Event Player && !Current Array Element.IsWinner));
		Chase Global Variable At Rate(GEBallPosition, Eye Position(Global.GETarget) - Vector(0, 0.500, 0), Global.GEBallSpeed,
			Destination and Rate);
	}
}

rule("Ball chases Target (Extreme Pong)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 30;
		Global.IsGETimerStart == True;
		Global.GETarget != Null;
	}

	actions
	{
		If(Distance Between(Eye Position(Global.GETarget) - Vector(0, 0.500, 0), Global.GEBallPosition) <= 1);
			Stop Chasing Global Variable(GEBallPosition);
			Kill(Global.GETarget, Closest Player To(Global.GETarget, Team 2));
			Play Effect(All Players(Team 1), Junkrat Concussion Mine Explosion Sound, Color(White), Global.GETarget, 90);
			Play Effect(All Players(Team 1), Bad Explosion, Color(Red), Global.GETarget, 4);
			Global.GETarget = Null;
		End;
		Call Subroutine(GESetPongBallSpeed);
		Wait(0.150, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Lag player (I'm Lagging)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 31;
		Global.IsGETimerStart == True;
	}

	actions
	{
		"Lag intervals"
		Wait(Random Real(2, 20), Abort When False);
		Event Player.GELagType = Random Integer(0, 25);
		Event Player.GELagDistance = Random Real(1, 20);
		If(Event Player.GELagType == 0);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + Forward * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 1);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Forward + Right) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 2);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + Right * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 3);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Backward + Right) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 4);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + Backward * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 5);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Backward + Left) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 6);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + Left * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 7);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Forward + Left) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 8);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Forward + Down) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 9);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Forward + Up) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 10);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Right + Up) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 11);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Right + Down) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 12);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Backward + Down) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 13);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Backward + Up) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 14);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Left + Up) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 15);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Left + Down) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 16);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Forward + Right + Up) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 17);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Forward + Right + Down)
				* Event Player.GELagDistance);
		Else If(Event Player.GELagType == 18);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Backward + Right + Down)
				* Event Player.GELagDistance);
		Else If(Event Player.GELagType == 19);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Backward + Right + Up)
				* Event Player.GELagDistance);
		Else If(Event Player.GELagType == 20);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Forward + Left + Up) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 21);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Forward + Left + Down)
				* Event Player.GELagDistance);
		Else If(Event Player.GELagType == 22);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Backward + Left + Down)
				* Event Player.GELagDistance);
		Else If(Event Player.GELagType == 23);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + (Backward + Left + Up) * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 24);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + Up * Event Player.GELagDistance);
		Else If(Event Player.GELagType == 25);
			Event Player.GELagPos = Nearest Walkable Position(Position Of(Event Player) + Down * Event Player.GELagDistance);
		End;
		Set Status(Event Player, Null, Invincible, Random Real(2, 3));
		Teleport(Event Player, Event Player.GELagPos);
		Play Effect(Event Player, Buff Explosion Sound, Color(White), Event Player, 80);
		Loop If Condition Is True;
	}
}

rule("Select a Bastion Bullet Upgrade (BU)[Bullet][SR]")
{
	event
	{
		Subroutine;
		SelectBastionBulletUpgrade;
	}

	actions
	{
		Global.TempVar4 = Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Bastion));
		"Knockback Bullets"
		If(Global.BUChoices[0] == 1);
			Global.BastionDamages[1] = 50;
		"Flame Bullets"
		Else If(Global.BUChoices[0] == 2);
			Global.BastionDamages[1] = 0.500;
		"Tank Shells"
		Else If(Global.BUChoices[0] == 4);
			Call Subroutine(ApplyTankForm);
		"Concussion Bullets"
		Else If(Global.BUChoices[0] == 5);
			Global.BastionDamages[1] = 100;
		"None"
		Else;
			Global.BastionDamages[1] = Global.BastionDamages[0];
		End;
		Call Subroutine(SetGEBastionDamage);
	}
}

rule("Player took damage (BU)[Bullet]")
{
	event
	{
		Player Took Damage;
		Team 1;
		All;
	}

	conditions
	{
		Attacker != Event Player;
		Hero Of(Attacker) == Hero(Bastion);
		(Global.BUChoices[0] == 2 || Global.BUChoices[0] == 1 || Global.BUChoices[0] == 5 || Global.BUChoices[0] == 6 || (
			Global.BUChoices[0] == 4 && (
			Global.BUChoices[2] == 1 || Global.BUChoices[2] == 2 || Global.BUChoices[2] == 3 || Global.BUChoices[2] == 4))) == True;
	}

	actions
	{
		"Flame Bullets"
		If(Global.BUChoices[0] == 2);
			Set Status(Event Player, Null, Burning, 10);
			Start Damage Over Time(Event Player, Null, 10, Random Real(0.500, 5.100));
		"Flame Shells"
		Else If(Global.BUChoices[0] == 4 && Global.BUChoices[2] == 1);
			Set Status(Event Player, Null, Burning, 10);
			Start Damage Over Time(Event Player, Null, 10, Random Real(1, 10.200));
		"Knockback Bullets"
		Else If(Global.BUChoices[0] == 1);
			Apply Impulse(Event Player, Event Direction, Random Real(5, 8.350), To World, Cancel Contrary Motion);
		"Knockback Shells"
		Else If(Global.BUChoices[0] == 4 && Global.BUChoices[2] == 2);
			Apply Impulse(Event Player, Event Direction, Random Real(6, 10), To World, Cancel Contrary Motion);
		"Concussion Bullets"
		Else If(Global.BUChoices[0] == 5 && Random Integer(0, 19) == 6);
			Set Status(Event Player, Null, Stunned, 0.700);
		"Knockdown Shells"
		Else If(Global.BUChoices[0] == 4 && Global.BUChoices[2] == 3 && Random Integer(0, 10) == 6);
			Set Status(Event Player, Null, Knocked Down, 1);
		"Shock Bullets/Shells"
		Else If(Global.BUChoices[0] == 6 || (Global.BUChoices[0] == 4 && Global.BUChoices[2] == 4));
			Event Player.BUPlayersNearby = Players Within Radius(Event Player, Global.BUChoices[0] == 6 ? 10 : 12, Team 1, Off);
			For Player Variable(Event Player, BUIndex, 0, Count Of(Event Player.BUPlayersNearby), 1);
				Damage(Event Player.BUPlayersNearby[Event Player.BUIndex], Closest Player To(Event Player, Team 2), Event Damage * 0.500);
				Create Beam Effect(All Players(Team 1), Bad Beam, Event Player, Event Player.BUPlayersNearby[Event Player.BUIndex], Color(Aqua),
					Visible To Position and Radius);
				Event Player.BUBulletEffectIDs[0] = Last Created Entity;
				Create Effect(All Players(Team 1), Energy Sound, Color(White), Event Player.BUPlayersNearby[Event Player.BUIndex], 80,
					Visible To Position and Radius);
				Event Player.BUBulletEffectIDs[1] = Last Created Entity;
				Wait(1, Abort When False);
				Destroy Effect(Event Player.BUBulletEffectIDs);
			End;
	}
}

rule("Bastion kills player (BU)[Bullet]")
{
	event
	{
		Player Dealt Final Blow;
		Team 2;
		Bastion;
	}

	conditions
	{
		Global.BUChoices[0] == 3;
		Is Hero Being Played(Hero(Mercy), Team 1) == False;
	}

	actions
	{
		"Teleport Bullets"
		If(Global.BUChoices[0] == 3);
			"Teleport Position"
			Victim.BUTeleStats[0] = Position Of(Victim);
			Wait(0.150, Ignore Condition);
			"Teleportation Type"
			Victim.BUTeleStats[1] = Random Integer(0, 25);
			"Teleportation distance away from player death"
			Victim.BUTeleStats[2] = Random Real(3, 28);
			If(Victim.BUTeleStats[1] == 0);
				Victim.BUTeleStats[0] = Victim.BUTeleStats[0] + Forward * Victim.BUTeleStats[2];
			Else If(Victim.BUTeleStats[1] == 1);
				Victim.BUTeleStats[0] = Victim.BUTeleStats[0] + (Forward + Right) * Victim.BUTeleStats[2];
			Else If(Victim.BUTeleStats[1] == 2);
				Victim.BUTeleStats[0] = Victim.BUTeleStats[0] + Right * Victim.BUTeleStats[2];
			Else If(Victim.BUTeleStats[1] == 3);
				Victim.BUTeleStats[0] = Victim.BUTeleStats[0] + (Backward + Right) * Victim.BUTeleStats[2];
			Else If(Victim.BUTeleStats[1] == 4);
				Victim.BUTeleStats[0] = Victim.BUTeleStats[0] + Backward * Victim.BUTeleStats[2];
			Else If(Victim.BUTeleStats[1] == 5);
				Victim.BUTeleStats[0] = Victim.BUTeleStats[0] + (Backward + Left) * Victim.BUTeleStats[2];
			Else If(Victim.BUTeleStats[1] == 6);
				Victim.BUTeleStats[0] = Victim.BUTeleStats[0] + Left * Victim.BUTeleStats[2];
			Else If(Victim.BUTeleStats[1] == 7);
				Victim.BUTeleStats[0] = Victim.BUTeleStats[0] + (Forward + Left) * Victim.BUTeleStats[2];
			Else If(Victim.BUTeleStats[1] == 8);
				Victim.BUTeleStats[0] = Nearest Walkable Position(Victim.BUTeleStats[0] + (Forward + Down) * Victim.BUTeleStats[2]);
			Else If(Victim.BUTeleStats[1] == 9);
				Victim.BUTeleStats[0] = Victim.BUTeleStats[0] + (Forward + Up) * Victim.BUTeleStats[2];
			Else If(Victim.BUTeleStats[1] == 10);
				Victim.BUTeleStats[0] = Victim.BUTeleStats[0] + (Right + Up) * Victim.BUTeleStats[2];
			Else If(Victim.BUTeleStats[1] == 11);
				Victim.BUTeleStats[0] = Nearest Walkable Position(Victim.BUTeleStats[0] + (Right + Down) * Victim.BUTeleStats[2]);
			Else If(Victim.BUTeleStats[1] == 12);
				Victim.BUTeleStats[0] = Nearest Walkable Position(Victim.BUTeleStats[0] + (Backward + Down) * Victim.BUTeleStats[2]);
			Else If(Victim.BUTeleStats[1] == 13);
				Victim.BUTeleStats[0] = Victim.BUTeleStats[0] + (Backward + Up) * Victim.BUTeleStats[2];
			Else If(Victim.BUTeleStats[1] == 14);
				Victim.BUTeleStats[0] = Victim.BUTeleStats[0] + (Left + Up) * Victim.BUTeleStats[2];
			Else If(Victim.BUTeleStats[1] == 15);
				Victim.BUTeleStats[0] = Nearest Walkable Position(Victim.BUTeleStats[0] + (Left + Down) * Victim.BUTeleStats[2]);
			Else If(Victim.BUTeleStats[1] == 16);
				Victim.BUTeleStats[0] = Victim.BUTeleStats[0] + (Forward + Right + Up) * Victim.BUTeleStats[2];
			Else If(Victim.BUTeleStats[1] == 17);
				Victim.BUTeleStats[0] = Nearest Walkable Position(Victim.BUTeleStats[0] + (Forward + Right + Down) * Victim.BUTeleStats[2]);
			Else If(Victim.BUTeleStats[1] == 18);
				Victim.BUTeleStats[0] = Nearest Walkable Position(Victim.BUTeleStats[0] + (Backward + Right + Down) * Victim.BUTeleStats[2]);
			Else If(Victim.BUTeleStats[1] == 19);
				Victim.BUTeleStats[0] = Victim.BUTeleStats[0] + (Backward + Right + Up) * Victim.BUTeleStats[2];
			Else If(Victim.BUTeleStats[1] == 20);
				Victim.BUTeleStats[0] = Victim.BUTeleStats[0] + (Forward + Left + Up) * Victim.BUTeleStats[2];
			Else If(Victim.BUTeleStats[1] == 21);
				Victim.BUTeleStats[0] = Nearest Walkable Position(Victim.BUTeleStats[0] + (Forward + Left + Down) * Victim.BUTeleStats[2]);
			Else If(Victim.BUTeleStats[1] == 22);
				Victim.BUTeleStats[0] = Nearest Walkable Position(Victim.BUTeleStats[0] + (Backward + Left + Down) * Victim.BUTeleStats[2]);
			Else If(Victim.BUTeleStats[1] == 23);
				Victim.BUTeleStats[0] = Victim.BUTeleStats[0] + (Backward + Left + Up) * Victim.BUTeleStats[2];
			Else If(Victim.BUTeleStats[1] == 24);
				Victim.BUTeleStats[0] = Victim.BUTeleStats[0] + Up * Victim.BUTeleStats[2];
			Else If(Victim.BUTeleStats[1] == 25);
				If(Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter));
					Victim.BUTeleStats[0] = Global.BlizzWorldSpawnLoc;
				Else If(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween));
					Victim.BUTeleStats[0] = Global.HollywoodSpawns[0];
				Else;
					Victim.BUTeleStats[0] = Random Value In Array(Spawn Points(Team 1));
				End;
			End;
			Wait Until(Is Alive(Victim), 5);
			Teleport(Victim, Victim.BUTeleStats[0]);
			Play Effect(Event Player, Moira Fade Reappear Sound, Color(White), Event Player, 90);
			Set Status(Victim, Null, Invincible, 1.400);
	}
}

rule("Before New Bastion Upgrade Choice (BU)[Bullet][SR]")
{
	event
	{
		Subroutine;
		BeforeNewBastionBulletUpgrade;
	}

	actions
	{
		Global.TempVar4 = Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Bastion));
		Set Projectile Speed(Global.TempVar4, Global.BUChoices[3] == 1 ? 200 : 100);
		If(Global.BUChoices[0] == 4);
			Clear Status(Global.TempVar4, Unkillable);
			Kill(Global.TempVar4, Null);
			Set Status(Global.TempVar4, Null, Unkillable, 999999);
			Set Projectile Speed(Global.TempVar4, Global.BUChoices[3] == 1 ? 200 : 135);
	}
}

rule("Player Dies during Bastion Upgrade (BU)")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		Global.BUChoices[0] == 2;
	}

	actions
	{
		Stop All Damage Over Time(Event Player);
		Clear Status(Event Player, Burning);
		Call Subroutine(AddBacktrackDeath);
	}
}

rule("Select Tank Shell Type (BU)[Bullet][SR]")
{
	event
	{
		Subroutine;
		SelectTankShellType;
	}

	actions
	{
		"Knockdown"
		If(Global.BUChoices[2] == 3);
			Global.BastionDamages[1] = 80;
		"Flame & Knockback"
		Else If(Global.BUChoices[2] == 1 || Global.BUChoices[2] == 2);
			Global.BastionDamages[1] = 100;
		End;
	}
}

rule("Transform Bastions into tank form (BU)[Bullet][SR]")
{
	event
	{
		Subroutine;
		ApplyTankForm;
	}

	actions
	{
		Global.TempVar4 = Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Bastion));
		Allow Button(Global.TempVar4, Button(Ultimate));
		Set Ultimate Ability Enabled(Global.TempVar4, True);
		Set Ultimate Charge(Global.TempVar4, 100);
		Press Button(Global.TempVar4, Button(Ultimate));
		Disallow Button(Global.TempVar4, Button(Ultimate));
		Set Ultimate Ability Enabled(Global.TempVar4, False);
		Set Projectile Speed(Global.TempVar4, Global.BUChoices[3] == 1 ? 200 : 135);
		Global.BastionDamages[1] = Global.BastionDamages[0];
		Call Subroutine(SelectTankShellType);
	}
}

rule("Make sure Bastion stays in tank form _if selected_ (BU)[Bullet]")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.BUChoices[0] == 4;
		Is True For Any(All Players(Team 2), Hero Of(Current Array Element) == Hero(Bastion) && (!Is Using Ultimate(Current Array Element)
			|| !Is In Alternate Form(Current Array Element))) == True;
	}

	actions
	{
		Wait(5, Abort When False);
		Call Subroutine(SelectBastionBulletUpgrade);
	}
}

rule("Player picks up key (Lockdown)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.IsGETimerStart == True;
		Global.GEChoice == 36;
		Global.GEAffectedPlayer == Null;
		Is True For Any(Players Within Radius(Global.GEBallPosition, Global.GERadius + 1, Team 1, Off), Is Alive(Current Array Element)
			&& !Current Array Element.IsWinner) == True;
	}

	actions
	{
		Global.GEAffectedPlayer = Closest Player To(Global.GEBallPosition, Team 1);
		Start Forcing Player Outlines(Global.GEAffectedPlayer, All Players(Team 1), True, Color(Yellow), Always);
		Global.GEBallPosition = Vector(0, -1111, 0);
	}
}

rule("Relocate key (Lockdown)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.GEChoice == 36;
		Global.IsGETimerStart == True;
		Global.GEAffectedPlayer == Null;
	}

	actions
	{
		If(Distance Between(Random Value In Array(Spawn Points(Team 2)), Global.GEBallPosition) <= 30);
			Wait(0.100, Abort When False);
		Else;
			Wait(Random Real(40, 120), Abort When False);
		End;
		Call Subroutine(SelectLocFromAllDirs);
		Loop If Condition Is True;
	}
}

rule("Player with the key is no longer in the game (Lockdown)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.GEChoice == 36;
		Global.IsGETimerStart == True;
		Global.GEAffectedPlayer != Null;
		Is True For Any(All Players(Team 1), Current Array Element == Global.GEAffectedPlayer) == False;
	}

	actions
	{
		Call Subroutine(SelectLocFromAllDirs);
	}
}

rule("Change game speed (Warped Slo-mo)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.GEChoice == 37;
		Global.IsGETimerStart == True;
	}

	actions
	{
		Set Slow Motion(Random Integer(10, 50));
		Set Move Speed(All Players(Team 1), 100);
		Wait(Random Real(1, 3), Abort When False);
		Set Slow Motion(90);
		Set Move Speed(All Players(Team 1), Random Integer(120, 180));
		Wait(Random Real(7, 12), Abort When False);
		Loop If Condition Is True;
	}
}

rule("Player is in (Spotlight)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 38;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.IsInSpawnRoom == False;
		Y Component Of(Position Of(Event Player)) >= Y Component Of(Global.GEBallPosition);
		Distance Between(Position Of(Event Player), Vector(X Component Of(Global.GEBallPosition), Y Component Of(Position Of(
			Event Player)), Z Component Of(Global.GEBallPosition))) <= Global.GERadius;
	}

	actions
	{
		Set Status(Event Player, Null, Frozen, 2);
		Stop Chasing Global Variable(GEBallPosition);
		Wait(1, Ignore Condition);
		Play Effect(Event Player, Debuff Impact Sound, Color(White), Event Player, 90);
		Teleport(Event Player, Position Of(Random Value In Array(All Players(Team 2))));
		Global.GETarget = Null;
	}
}

rule("Choose a Target (Spotlight)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 38;
		Global.IsGETimerStart == True;
	}

	actions
	{
		Wait Until(Global.GETarget == Null || Is In Spawn Room(Global.GETarget) || Position Of(Global.GETarget) == Global.GEBallPosition,
			Random Real(15, 30));
		Stop Chasing Global Variable(GEBallPosition);
		Global.GETarget = Random Value In Array(Filtered Array(All Players(Team 1), !Current Array Element.IsWinner && !Is In Spawn Room(
			Current Array Element)));
		Chase Global Variable At Rate(GEBallPosition, Position Of(Global.GETarget) - Vector(0, 2, 0), Global.GEBallSpeed,
			Destination and Rate);
		Wait(0.100, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Init wind (Strong Winds)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.GEChoice == 39;
		Global.IsGETimerStart == True;
	}

	actions
	{
		Wait(Random Integer(18, 22), Abort When False);
		Stop Chasing Global Variable(GEBallSpeed);
		Global.GEBallSpeed = 0;
		Global.GEBallPosition = Vector(0, 0, 0);
		Global.GEText = Custom String("None");
		Wait(5, Abort When False);
		Call Subroutine(SelectWindDir);
		Call Subroutine(SetWindSpeedRate);
		Loop If Condition Is True;
	}
}

rule("Exhale (Strong Winds)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEChoice == 39;
		Global.IsGETimerStart == True;
	}

	actions
	{
		Apply Impulse(Event Player, Global.GEBallPosition, Global.GEBallSpeed, To World, Cancel Contrary Motion);
		Wait(0.100, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Select wind direction (Strong Winds)(GE)[SR]")
{
	event
	{
		Subroutine;
		SelectWindDir;
	}

	actions
	{
		Global.GEMultiChoice = Random Integer(0, 25);
		If(Global.GEMultiChoice == 0);
			Global.GEBallPosition = Forward;
			Global.GEText = Custom String("{0}|{1}", Icon String(Asterisk), Icon String(Arrow: Up));
		Else If(Global.GEMultiChoice == 1);
			Global.GEBallPosition = Forward + Right;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Asterisk), Icon String(Arrow: Up), Icon String(Arrow: Right));
		Else If(Global.GEMultiChoice == 2);
			Global.GEBallPosition = Right;
			Global.GEText = Custom String("{0}|{1}", Icon String(Asterisk), Icon String(Arrow: Right));
		Else If(Global.GEMultiChoice == 3);
			Global.GEBallPosition = Right + Backward;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Asterisk), Icon String(Arrow: Down), Icon String(Arrow: Right));
		Else If(Global.GEMultiChoice == 4);
			Global.GEBallPosition = Backward;
			Global.GEText = Custom String("{0}|{1}", Icon String(Asterisk), Icon String(Arrow: Down));
		Else If(Global.GEMultiChoice == 5);
			Global.GEBallPosition = Left + Backward;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Asterisk), Icon String(Arrow: Down), Icon String(Arrow: Left));
		Else If(Global.GEMultiChoice == 6);
			Global.GEBallPosition = Left;
			Global.GEText = Custom String("{0}|{1}", Icon String(Asterisk), Icon String(Arrow: Left));
		Else If(Global.GEMultiChoice == 7);
			Global.GEBallPosition = Left + Forward;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Asterisk), Icon String(Arrow: Up), Icon String(Arrow: Left));
		Else If(Global.GEMultiChoice == 8);
			Global.GEBallPosition = Forward + Up;
			Global.GEText = Custom String("{0}|{1}", Icon String(Arrow: Up), Icon String(Arrow: Up));
		Else If(Global.GEMultiChoice == 9);
			Global.GEBallPosition = Forward + Down;
			Global.GEText = Custom String("{0}|{1}", Icon String(Arrow: Down), Icon String(Arrow: Up));
		Else If(Global.GEMultiChoice == 10);
			Global.GEBallPosition = Left + Up;
			Global.GEText = Custom String("{0}|{1}", Icon String(Arrow: Up), Icon String(Arrow: Left));
		Else If(Global.GEMultiChoice == 11);
			Global.GEBallPosition = Left + Down;
			Global.GEText = Custom String("{0}|{1}", Icon String(Arrow: Down), Icon String(Arrow: Left));
		Else If(Global.GEMultiChoice == 12);
			Global.GEBallPosition = Right + Up;
			Global.GEText = Custom String("{0}|{1}", Icon String(Arrow: Up), Icon String(Arrow: Right));
		Else If(Global.GEMultiChoice == 13);
			Global.GEBallPosition = Right + Down;
			Global.GEText = Custom String("{0}|{1}", Icon String(Arrow: Down), Icon String(Arrow: Right));
		Else If(Global.GEMultiChoice == 14);
			Global.GEBallPosition = Backward + Up;
			Global.GEText = Custom String("{0}|{1}", Icon String(Arrow: Up), Icon String(Arrow: Down));
		Else If(Global.GEMultiChoice == 15);
			Global.GEBallPosition = Backward + Down;
			Global.GEText = Custom String("{0}|{1}", Icon String(Arrow: Down), Icon String(Arrow: Down));
		Else If(Global.GEMultiChoice == 16);
			Global.GEBallPosition = Forward + Left + Up;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Arrow: Up), Icon String(Arrow: Up), Icon String(Arrow: Left));
		Else If(Global.GEMultiChoice == 17);
			Global.GEBallPosition = Forward + Left + Down;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Arrow: Down), Icon String(Arrow: Up), Icon String(Arrow: Left));
		Else If(Global.GEMultiChoice == 18);
			Global.GEBallPosition = Forward + Right + Up;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Arrow: Up), Icon String(Arrow: Up), Icon String(Arrow: Right));
		Else If(Global.GEMultiChoice == 19);
			Global.GEBallPosition = Forward + Right + Down;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Arrow: Down), Icon String(Arrow: Up), Icon String(Arrow: Right));
		Else If(Global.GEMultiChoice == 20);
			Global.GEBallPosition = Backward + Left + Up;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Arrow: Up), Icon String(Arrow: Down), Icon String(Arrow: Left));
		Else If(Global.GEMultiChoice == 21);
			Global.GEBallPosition = Backward + Left + Down;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Arrow: Down), Icon String(Arrow: Down), Icon String(Arrow: Left));
		Else If(Global.GEMultiChoice == 22);
			Global.GEBallPosition = Backward + Right + Up;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Arrow: Up), Icon String(Arrow: Down), Icon String(Arrow: Right));
		Else If(Global.GEMultiChoice == 23);
			Global.GEBallPosition = Backward + Right + Down;
			Global.GEText = Custom String("{0}|{1}{2}", Icon String(Arrow: Down), Icon String(Arrow: Down), Icon String(Arrow: Right));
		Else If(Global.GEMultiChoice == 24);
			Global.GEBallPosition = Up;
			Global.GEText = Custom String("{0}", Icon String(Arrow: Up));
		Else If(Global.GEMultiChoice == 25);
			Global.GEBallPosition = Down;
			Global.GEText = Custom String("{0}", Icon String(Arrow: Down));
		End;
	}
}

rule("Set wind speed rate (Strong Winds)(GE)[SR]")
{
	event
	{
		Subroutine;
		SetWindSpeedRate;
	}

	actions
	{
		Chase Global Variable At Rate(GEBallSpeed, Random Integer(8, 16), 1 / 27 * Global.GEBallSpeed + 1, Destination and Rate);
	}
}

rule("Init camera (Wacky Camera)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEChoice == 40;
		Global.IsGETimerStart == True;
	}

	actions
	{
		"3rd-person view"
		Call Subroutine(SetCameraView);
	}
}

rule("Set camera view (Wacky Camera)(GE)[SR]")
{
	event
	{
		Subroutine;
		SetCameraView;
	}

	actions
	{
		"3rd-person view"
		If(Global.GECameraChoice == 0);
			"0 = Camera Distance; 1 = Camera Origin Y-Axis"
			Event Player.GECameraStats = Array(5, 3);
			Start Camera(Event Player, Ray Cast Hit Position(Eye Position(Event Player), Facing Direction Of(Event Player)
				* -1 * Event Player.GECameraStats[0] + Eye Position(Event Player) + Vector(0, Event Player.GECameraStats[1], 0), All Players(
				All Teams), Event Player, False), Eye Position(Event Player), 15);
		"Top-down view"
		Else If(Global.GECameraChoice == 1);
			"Camera Distance"
			Event Player.GECameraStats = Vector(0, 20, 0);
			Start Camera(Event Player, Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + Facing Direction Of(
				Event Player) * -1 + Event Player.GECameraStats, All Players(All Teams), Event Player, False), Eye Position(Event Player)
				+ Facing Direction Of(Event Player), 15);
		"Selfie view"
		Else If(Global.GECameraChoice == 2);
			"0 = Camera Distance; 1 = Camera Origin Y-Axis"
			Event Player.GECameraStats = Array(5, 3);
			Start Camera(Event Player, Ray Cast Hit Position(Eye Position(Event Player), Facing Direction Of(Event Player)
				* Event Player.GECameraStats[0] + Eye Position(Event Player) + Vector(0, Event Player.GECameraStats[1], 0), All Players(
				All Teams), Event Player, False), Eye Position(Event Player), 15);
		"Cinematic"
		Else If(Global.GECameraChoice == 3);
			Call Subroutine(SetCineCameraStat);
			Start Camera(Event Player, Event Player.GECameraStats, Eye Position(Event Player), 15);
	}
}

rule("Set cinematic camera stats (Wacky Camera)(GE)[SR]")
{
	event
	{
		Subroutine;
		SetCineCameraStat;
	}

	actions
	{
		"Camera Distance"
		Event Player.GECameraStats = Ray Cast Hit Position(Eye Position(Event Player), Local Vector Of(Up + Backward, Event Player,
			Rotation) * 5 + Eye Position(Event Player) + Vector(0, 3, 0), All Players(All Teams), Event Player, False);
	}
}

rule("Move cinematic camera (Wacky Camera)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEChoice == 40;
		Global.IsGETimerStart == True;
		Global.GECameraChoice == 3;
		Is In Line of Sight(Event Player.GECameraStats, Eye Position(Event Player), Barriers Do Not Block LOS) == False;
	}

	actions
	{
		Wait(0.600, Abort When False);
		"Camera Distance"
		Call Subroutine(SetCineCameraStat);
		Loop If Condition Is True;
	}
}

rule("Init (Space Propulsion)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 41;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
	}

	actions
	{
		Set Gravity(Event Player, 0);
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Disallow Button(Event Player, Button(Primary Fire));
		Disallow Button(Event Player, Button(Secondary Fire));
	}
}

rule("Use heavy propulsion (Space Propulsion)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 41;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Is Button Held(Event Player, Button(Primary Fire)) == True;
	}

	actions
	{
		Apply Impulse(Event Player, Facing Direction Of(Event Player) * -1, 10, To World, Cancel Contrary Motion);
	}
}

rule("Use light propulsion (Space Propulsion)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Change the ID # from -1 to a positive number"
		Global.GEChoice == 41;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
	}

	actions
	{
		Apply Impulse(Event Player, Facing Direction Of(Event Player) * -1, 5, To World, Cancel Contrary Motion);
	}
}

rule("Set Bastion Upgrade Damage (BU)[SR]")
{
	event
	{
		Subroutine;
		SetGEBastionDamage;
	}

	actions
	{
		Set Damage Dealt(Global.TempVar4, Global.BastionDamages[1] + Global.BastionDamages[2]);
	}
}

rule("Select extra Bastion Upgrade (BU)[Extra][SR]")
{
	event
	{
		Subroutine;
		SelectBastionExtraUpgrade;
	}

	actions
	{
		Call Subroutine(BastionExtraUpgradeReset);
		"Camo"
		If(Global.BUChoices[1] == 1);
			Set Invisible(Global.TempVar4, All);
		"Bastion Jr."
		Else If(Global.BUChoices[1] == 2);
			Global.BUExtraScale = 0.300;
			Start Scaling Player(Global.TempVar4, Global.BUExtraScale, False);
		"Bastion Sr."
		Else If(Global.BUChoices[1] == 3);
			Global.BUExtraScale = Random Real(2, 2.500);
			Start Scaling Player(Global.TempVar4, Global.BUExtraScale, False);
			Disable Movement Collision With Environment(Global.TempVar4, False);
		End;
		Call Subroutine(SetGEBastionDamage);
	}
}

rule("Reset extra Bastion Upgrade (BU)[Extra][SR]")
{
	event
	{
		Subroutine;
		BastionExtraUpgradeReset;
	}

	actions
	{
		Global.TempVar4 = Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Bastion));
		Set Invisible(Global.TempVar4, None);
		Stop Forcing Player Outlines(Global.TempVar4, All Players(Team 1));
		Stop Scaling Player(Global.TempVar4);
		Enable Movement Collision With Environment(Global.TempVar4);
		Global.BastionDamages[2] = 0;
		Global.TempVar4 = All Players(All Teams);
		For Global Variable(TempVar2, 0, Count Of(Global.TempVar4), 1);
			Destroy Effect(Global.TempVar4[Global.TempVar2].BUExtraEffectIDs);
			Global.TempVar4[Global.TempVar2].BUExtraEffectIDs = Null;
		End;
		Global.TempVar4 = Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Bastion));
	}
}

rule("Bastion passives (GE)(BU)[Extra]")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Global.BUChoices[1] == 2 || Global.BUChoices[1] == 3) == True;
	}

	actions
	{
		Wait(Random Integer(20, 30), Abort When False);
		Stop Scaling Player(Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Bastion)));
		Start Scaling Player(Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Bastion)), Global.BUExtraScale,
			False);
		Loop If Condition Is True;
	}
}

rule("Bastion is shooting (Camo)(GE)(BU)[Extra]")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		"Clandestine Toggle"
		Global.BUChoices[1] == 1;
		Is Firing Primary(Event Player) == True;
	}

	actions
	{
		Wait(0.300, Abort When False);
		Set Invisible(Event Player, None);
		Start Forcing Player Outlines(Event Player, All Players(Team 1), True, Color(Red), Always);
		If(Event Player.BUExtraEffectIDs != Null);
			Destroy Effect(Event Player.BUExtraEffectIDs[0]);
			Event Player.BUExtraEffectIDs = Null;
	}
}

rule("Bastion is hiding (Camo)(GE)(BU)[Extra]")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		"Clandestine Toggle"
		Global.BUChoices[1] == 1;
		Is Firing Primary(Event Player) == False;
	}

	actions
	{
		Wait(1, Abort When False);
		Set Invisible(Event Player, Enemies);
		Stop Forcing Player Outlines(Event Player, All Players(Team 1));
		If(Event Player.BUExtraEffectIDs == Null);
			Create Effect(All Players(Team 1), Bad Aura Sound, Color(White), Event Player, 80, Visible To Position and Radius);
			Event Player.BUExtraEffectIDs[0] = Last Created Entity;
	}
}

rule("Player is looking at Bastion (Shining Armor)(GE)(BU)[Extra]")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Clandestine Toggle"
		Global.BUChoices[1] == 4;
		Event Player.IsWinner == False;
		Event Player.BUExtraEffectIDs == Null;
		Is True For Any(Players in View Angle(Event Player, Team 2, 45), Is In Line of Sight(Eye Position(Event Player), Eye Position(
			Current Array Element), All Barriers Block LOS)) == True;
	}

	actions
	{
		Event Player.BlindChanceNum = Random Integer(0, 2);
		Abort If(Event Player.BlindChanceNum != 1);
		Create Effect(Event Player, Sphere, Color(Yellow), Event Player, 50, Visible To Position and Radius);
		Event Player.BUExtraEffectIDs[0] = Last Created Entity;
		Create Effect(Event Player, Sphere, Color(White), Event Player, 5, Visible To Position and Radius);
		Event Player.BUExtraEffectIDs[1] = Last Created Entity;
	}
}

rule("Player is not looking at Bastion (Shining Armor)(GE)(BU)[Extra]")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		"Clandestine Toggle"
		Global.BUChoices[1] == 4;
		Event Player.BUExtraEffectIDs != Null;
		Is True For Any(Players in View Angle(Event Player, Team 2, 45), Is In Line of Sight(Eye Position(Event Player), Eye Position(
			Current Array Element), All Barriers Block LOS)) == False;
	}

	actions
	{
		Wait(5, Abort When False);
		Destroy Effect(Event Player.BUExtraEffectIDs);
		Event Player.BUExtraEffectIDs = Null;
		Loop If Condition Is True;
	}
}

rule("Assign new body (One-For-All)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.GEChoice == 44;
		Global.IsGETimerStart == True;
	}

	actions
	{
		Wait Until(Global.GEAffectedPlayer == Null, Random Real(5, 30));
		Abort If Condition Is False;
		Global.GETarget = Global.GEAffectedPlayer;
		Global.GEAffectedPlayer = Random Value In Array(Filtered Array(All Players(Team 1),
			Current Array Element != Global.GETarget && !Current Array Element.IsWinner));
		If(Global.GETarget != Null);
			Teleport(Global.GEAffectedPlayer, Position Of(Global.GETarget));
			Respawn(Global.GETarget);
			If(Current Map == Map(Blizzard World) || Current Map == Map(Blizzard World Winter));
				Teleport(Global.GETarget, Global.BlizzWorldSpawnLoc);
			Else If(Current Map == Map(Hollywood) || Current Map == Map(Hollywood Halloween));
				Teleport(Global.GETarget, Global.HollywoodSpawns[0]);
			Else If(Hero Of(Global.GETarget) == Hero(D.Va));
				Teleport(Global.GETarget, Position Of(Random Value In Array(Spawn Points(Team 1))));
			End;
			Play Effect(All Players(Team 1), Buff Impact Sound, Color(White), Global.GETarget, 80);
			Play Effect(All Players(Team 1), Good Pickup Effect, Color(Yellow), Global.GETarget, 8);
		End;
		Stop Camera(Global.GEAffectedPlayer);
		Call Subroutine(EnablePlayer);
		Play Effect(All Players(Team 1), Buff Impact Sound, Color(White), Global.GEAffectedPlayer, 80);
		Play Effect(All Players(Team 1), Good Pickup Effect, Color(Yellow), Global.GEAffectedPlayer, 8);
		Wait(0.500, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Assign minds to the body (One-For-All)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEChoice == 44;
		Global.IsGETimerStart == True;
		Event Player != Global.GEAffectedPlayer;
		Event Player.IsWinner == False;
	}

	actions
	{
		Event Player.GECameraStats = Array(5, 3);
		Start Camera(Event Player, Ray Cast Hit Position(Eye Position(Global.GEAffectedPlayer), (Throttle Of(Event Player) == Vector(0, 0,
			0) ? Facing Direction Of(Global.GEAffectedPlayer) * -1 : Throttle Of(Event Player))
			* Event Player.GECameraStats[0] + Eye Position(Global.GEAffectedPlayer) + Vector(0, Event Player.GECameraStats[1], 0),
			All Players(All Teams), Global.GEAffectedPlayer, False), Eye Position(Global.GEAffectedPlayer), 15);
		Call Subroutine(DisablePlayer);
	}
}

rule("Disable Player (One-For-All)(GE)[SR]")
{
	event
	{
		Subroutine;
		DisablePlayer;
	}

	actions
	{
		Disallow Button(Event Player, Button(Primary Fire));
		Disallow Button(Event Player, Button(Secondary Fire));
		Disallow Button(Event Player, Button(Ability 1));
		Disallow Button(Event Player, Button(Ability 2));
		Disallow Button(Event Player, Button(Interact));
		Disallow Button(Event Player, Button(Jump));
		Disallow Button(Event Player, Button(Melee));
		Disallow Button(Event Player, Button(Reload));
		Disallow Button(Event Player, Button(Crouch));
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
	}
}

rule("Enable Player (One-For-All)(GE)[SR]")
{
	event
	{
		Subroutine;
		EnablePlayer;
	}

	actions
	{
		Allow Button(Global.GEAffectedPlayer, Button(Primary Fire));
		Allow Button(Global.GEAffectedPlayer, Button(Secondary Fire));
		Allow Button(Global.GEAffectedPlayer, Button(Ability 1));
		Allow Button(Global.GEAffectedPlayer, Button(Ability 2));
		Allow Button(Global.GEAffectedPlayer, Button(Interact));
		Allow Button(Global.GEAffectedPlayer, Button(Jump));
		Allow Button(Global.GEAffectedPlayer, Button(Melee));
		Allow Button(Global.GEAffectedPlayer, Button(Reload));
		Allow Button(Global.GEAffectedPlayer, Button(Crouch));
		Stop Forcing Throttle(Global.GEAffectedPlayer);
	}
}

rule("Body reaches goal (One-For-All)(GE)[SR]")
{
	event
	{
		Subroutine;
		OneForAllGoal;
	}

	actions
	{
		If(Global.GEChoice == 44 && Global.GEAffectedPlayer == Event Player);
			Global.TempVar = Filtered Array(All Players(Team 1),
				Global.GEAffectedPlayer != Current Array Element && !Current Array Element.IsWinner);
			For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
				If((Global.HeroListTypeWS != 2 && Global.TempVar[Global.TempVar2].CurrentHero == Count Of(Global.HeroList) - 1) || (
					Global.HeroListTypeWS == 2 && Global.TempVar[Global.TempVar2].CurrentHero == Count Of(
					Global.TempVar[Global.TempVar2].IndieHeroList) - 1));
					Teleport(Global.TempVar[Global.TempVar2], Global.EndPosition + Vector(0, 5, 0));
				Else;
					Global.TempVar[Global.TempVar2].CurrentHero += 1;
					Global.TempVar[Global.TempVar2].TargetHero = Global.TempVar[Global.TempVar2].CurrentHero;
				End;
			End;
		End;
	}
}

rule("Init marching motion (Forward March)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEChoice == 45;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Event Player.GEID == Null;
	}

	actions
	{
		Set Move Speed(Event Player, 300);
		Create Effect(All Players(Team 1), Cloud, Color(White), Event Player, 1, Visible To Position and Radius);
		Event Player.GEID = Last Created Entity;
		Start Throttle In Direction(Event Player, Facing Direction Of(Event Player), 1, To World, Replace existing throttle,
			Direction and Magnitude);
	}
}

rule("Player emotes (Forward March)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEChoice == 45;
		Global.IsGETimerStart == True;
		Event Player.IsWinner == False;
		Is Communicating Any Emote(Event Player) == True;
	}

	actions
	{
		Kill(Event Player, Closest Player To(Event Player, Team 2));
	}
}

rule("Player touches sphere (Kill Sphere)(GE)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.GEChoice == 47;
		Global.IsGETimerStart == True;
		Is True For Any(Players Within Radius(Global.GEBallPosition, Global.GERadius, Team 1, Off),
			!Current Array Element.IsInSpawnRoom && !Current Array Element.IsWinner) == True;
	}

	actions
	{
		Kill(Filtered Array(Players Within Radius(Global.GEBallPosition, Global.GERadius, Team 1, Off),
			!Current Array Element.IsInSpawnRoom && !Current Array Element.IsWinner), Closest Player To(Global.GEBallPosition, Team 2));
	}
}

rule("Set boop direction (Boop)(GE)[SR]")
{
	event
	{
		Subroutine;
		SetBoopDirection;
	}

	actions
	{
		Global.TempVar2 = Random Integer(0, 16);
		If(Global.TempVar2 == 0);
			Global.GEBallPosition = Forward;
		Else If(Global.TempVar2 == 1);
			Global.GEBallPosition = Forward + Right;
		Else If(Global.TempVar2 == 2);
			Global.GEBallPosition = Right;
		Else If(Global.TempVar2 == 3);
			Global.GEBallPosition = Backward + Right;
		Else If(Global.TempVar2 == 4);
			Global.GEBallPosition = Backward;
		Else If(Global.TempVar2 == 5);
			Global.GEBallPosition = Backward + Left;
		Else If(Global.TempVar2 == 6);
			Global.GEBallPosition = Left;
		Else If(Global.TempVar2 == 7);
			Global.GEBallPosition = Forward + Left;
		Else If(Global.TempVar2 == 8);
			Global.GEBallPosition = Forward + Up;
		Else If(Global.TempVar2 == 9);
			Global.GEBallPosition = Right + Up;
		Else If(Global.TempVar2 == 10);
			Global.GEBallPosition = Backward + Up;
		Else If(Global.TempVar2 == 11);
			Global.GEBallPosition = Left + Up;
		Else If(Global.TempVar2 == 12);
			Global.GEBallPosition = Forward + Right + Up;
		Else If(Global.TempVar2 == 13);
			Global.GEBallPosition = Backward + Right + Up;
		Else If(Global.TempVar2 == 14);
			Global.GEBallPosition = Forward + Left + Up;
		Else If(Global.TempVar2 == 15);
			Global.GEBallPosition = Backward + Left + Up;
		Else If(Global.TempVar2 == 16);
			Global.GEBallPosition = Up;
		End;
	}
}

rule("Set trap location (Trap Zones)(GE)[SR]")
{
	event
	{
		Subroutine;
		SetTrapZoneLoc;
	}

	actions
	{
		"Trap Location"
		Event Player.TrapZoneStats[0] = Random Integer(0, 25);
		"Trap Spawn Distance"
		Event Player.TrapZoneStats[1] = Random Real(20, 75);
		If(Event Player.TrapZoneStats[0] == 0);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + Forward * Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 1);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Forward + Right)
				* Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 2);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + Right * Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 3);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Backward + Right)
				* Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 4);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + Backward * Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 5);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Backward + Left)
				* Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 6);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + Left * Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 7);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Forward + Left)
				* Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 8);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Forward + Down)
				* Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 9);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Forward + Up)
				* Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 10);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Right + Up)
				* Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 11);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Right + Down)
				* Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 12);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Backward + Down)
				* Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 13);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Backward + Up)
				* Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 14);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Left + Up) * Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 15);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Left + Down)
				* Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 16);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Forward + Right + Up)
				* Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 17);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Forward + Right + Down)
				* Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 18);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Backward + Right + Down)
				* Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 19);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Backward + Right + Up)
				* Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 20);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Forward + Left + Up)
				* Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 21);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Forward + Left + Down)
				* Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 22);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Backward + Left + Down)
				* Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 23);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + (Backward + Left + Up)
				* Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 24);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + Up * Event Player.TrapZoneStats[1]);
		Else If(Event Player.TrapZoneStats[0] == 25);
			Event Player.TrapZoneStats[0] = Nearest Walkable Position(Position Of(Event Player) + Down * Event Player.TrapZoneStats[1]);
		End;
	}
}

rule("Clean up all traps and stats (Trap Zones)(GE)[SR]")
{
	event
	{
		Subroutine;
		CleanUpAllTrapsAndStats;
	}

	actions
	{
		Global.TempVar = Filtered Array(All Players(Team 2), Hero Of(Current Array Element) == Hero(Bastion));
		For Global Variable(TempVar2, 0, Count Of(Global.TempVar), 1);
			Destroy Effect(Global.TempVar[Global.TempVar2].TrapIDs);
			Global.TempVar[Global.TempVar2].TrapIDs = Null;
			Stop Chasing Player Variable(Global.TempVar[Global.TempVar2], FirstLazerPos);
			Global.TempVar[Global.TempVar2].FirstLazerPos = Null;
			Stop Chasing Player Variable(Global.TempVar[Global.TempVar2], SecondLazerPos);
			Global.TempVar[Global.TempVar2].SecondLazerPos = Null;
			Stop Chasing Player Variable(Global.TempVar[Global.TempVar2], ThirdLazerPos);
			Global.TempVar[Global.TempVar2].ThirdLazerPos = Null;
		End;
		Stop Accelerating(All Players(Team 1));
		Stop Forcing Throttle(All Players(Team 1));
		Clear Status(All Players(Team 1), Knocked Down);
		Clear Status(All Players(Team 1), Rooted);
		Enable Movement Collision With Environment(All Players(Team 1));
	}
}

rule("Init (Trap Zones)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Global.GEToggles[1] == True;
		Event Player.TrapIDs == Null;
	}

	actions
	{
		Call Subroutine(SetTrapZoneLoc);
		Event Player.TrapZoneChoice = Random Integer(0, 6);
		"Toxic Clouds"
		If(Event Player.TrapZoneChoice == 0);
			"Trap Radius"
			Event Player.TrapZoneStats[2] = 5;
			Create Effect(All Players(Team 1), Cloud, Color(Green), Event Player.TrapZoneStats[0] + Vector(0, 1.500, 0),
				Event Player.TrapZoneStats[2], Visible To Position and Radius);
			Event Player.TrapIDs[0] = Last Created Entity;
			Create Effect(All Players(Team 1), Smoke Sound, Color(White), Event Player.TrapZoneStats[0], 90, Visible To Position and Radius);
			Event Player.TrapIDs[1] = Last Created Entity;
			Create Effect(All Players(Team 1), Cloud, Color(Green), Event Player.TrapZoneStats[0] - Vector(0, 1.500, 0),
				Event Player.TrapZoneStats[2], Visible To Position and Radius);
			Event Player.TrapIDs[2] = Last Created Entity;
		"Pitfall"
		Else If(Event Player.TrapZoneChoice == 1);
			"Trap Radius"
			Event Player.TrapZoneStats[2] = 10;
			Create Effect(All Players(Team 1), Ring, Color(Gray), Event Player.TrapZoneStats[0], Event Player.TrapZoneStats[2],
				Visible To Position and Radius);
			Event Player.TrapIDs[0] = Last Created Entity;
		"Blue hole"
		Else If(Event Player.TrapZoneChoice == 2);
			"Trap Location"
			Event Player.TrapZoneStats[0] += Vector(0, 3, 0);
			"Trap Radius"
			Event Player.TrapZoneStats[2] = 11;
			Create Effect(All Players(Team 1), Sparkles, Color(Aqua), Event Player.TrapZoneStats[0], Event Player.TrapZoneStats[2],
				Visible To Position and Radius);
			Event Player.TrapIDs[0] = Last Created Entity;
			Create Effect(All Players(Team 1), Bad Aura, Color(Aqua), Event Player.TrapZoneStats[0], Event Player.TrapZoneStats[2] / 2,
				Visible To Position and Radius);
			Event Player.TrapIDs[1] = Last Created Entity;
		"Rooted"
		Else If(Event Player.TrapZoneChoice == 3);
			"Trap Radius"
			Event Player.TrapZoneStats[2] = 12;
			Event Player.TrapIDs[0] = -1;
		"Spring"
		Else If(Event Player.TrapZoneChoice == 4);
			"Trap Radius"
			Event Player.TrapZoneStats[2] = Random Integer(4, 8);
			Event Player.TrapIDs[0] = -1;
		"Lazer Field"
		Else If(Event Player.TrapZoneChoice == 5);
			Call Subroutine(SetLazerPositions);
			"Lazer length"
			Event Player.TrapZoneStats[2] = 15;
			"1st Lazer (Bottom)"
			Create Beam Effect(All Players(Team 1), Bad Beam, Event Player.FirstLazerPos,
				Event Player.FirstLazerPos + Right * Event Player.TrapZoneStats[2], Color(Red), Visible To Position and Radius);
			Event Player.TrapIDs[0] = Last Created Entity;
			"2nd Lazer (Top)"
			Create Beam Effect(All Players(Team 1), Bad Beam, Event Player.SecondLazerPos,
				Event Player.SecondLazerPos + Right * Event Player.TrapZoneStats[2], Color(Red), Visible To Position and Radius);
			Event Player.TrapIDs[1] = Last Created Entity;
			"3rd Lazer (Middle)"
			Create Beam Effect(All Players(Team 1), Bad Beam, Event Player.ThirdLazerPos,
				Event Player.ThirdLazerPos + Right * Event Player.TrapZoneStats[2], Color(Red), Visible To Position and Radius);
			Event Player.TrapIDs[2] = Last Created Entity;
		"Nullify Zone"
		Else If(Event Player.TrapZoneChoice == 6);
			"Trap Radius"
			Event Player.TrapZoneStats[2] = Random Real(8, 10);
			Create Effect(All Players(Team 1), Ring, Color(Purple), Event Player.TrapZoneStats[0], Event Player.TrapZoneStats[2],
				Visible To Position and Radius);
			Event Player.TrapIDs[0] = Last Created Entity;
	}
}

rule("Relocate trap zone (Trap Zone)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Global.GEToggles[1] == True;
		Event Player.TrapIDs != Null;
	}

	actions
	{
		Call Subroutine(SetTrapZoneLoc);
		Call Subroutine(SetLazerPositions);
		Wait(Random Integer(40, 160), Abort When False);
		Loop If Condition Is True;
	}
}

rule("Player touches cloud (Trap Zones)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Global.GEToggles[1] == True;
		Event Player.TrapIDs != Null;
		Event Player.TrapZoneChoice == 0;
		Is True For Any(Players Within Radius(Event Player.TrapZoneStats[0], Event Player.TrapZoneStats[2] - 1, Team 1, Off),
			!Current Array Element.IsWinner && !Current Array Element.IsInSpawnRoom) == True;
	}

	actions
	{
		Event Player.PlayersInTrapZone = Filtered Array(Players Within Radius(Event Player.TrapZoneStats[0],
			Event Player.TrapZoneStats[2] - 1, Team 1, Off), !Current Array Element.IsWinner && !Current Array Element.IsInSpawnRoom);
		Start Damage Over Time(Event Player.PlayersInTrapZone, Event Player, 5, Random Real(16, 32));
		Wait(5, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Player touches pitfall (Trap Zones)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Global.GEToggles[1] == True;
		Event Player.TrapIDs != Null;
		Event Player.TrapZoneChoice == 1;
		Is True For Any(Players Within Radius(Event Player.TrapZoneStats[0], Event Player.TrapZoneStats[2] - 1, Team 1, Off),
			!Current Array Element.IsWinner && !Current Array Element.IsInSpawnRoom && Is On Ground(Current Array Element)) == True;
	}

	actions
	{
		Event Player.PlayersInTrapZone = Filtered Array(Players Within Radius(Event Player.TrapZoneStats[0],
			Event Player.TrapZoneStats[2] - 1, Team 1, Off),
			!Current Array Element.IsWinner && !Current Array Element.IsInSpawnRoom && Is On Ground(Current Array Element));
		Set Status(Event Player.PlayersInTrapZone, Null, Knocked Down, 9999);
		Wait(0.500, Ignore Condition);
		Disable Movement Collision With Environment(Event Player.PlayersInTrapZone, True);
		Wait(1, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Player is inside a trap (Trap Zones)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Global.GEToggles[1] == True;
		Event Player.TrapIDs != Null;
		(Event Player.TrapZoneChoice == 2 || Event Player.TrapZoneChoice == 3) == True;
		Is True For Any(Players Within Radius(Event Player.TrapZoneStats[0], Event Player.TrapZoneStats[2] - 1, Team 1, Off),
			!Current Array Element.IsWinner && !Current Array Element.IsInSpawnRoom && Current Array Element.EnemyTrapEntity == Null)
			== True;
	}

	actions
	{
		Event Player.PlayersInTrapZone = Filtered Array(Players Within Radius(Event Player.TrapZoneStats[0],
			Event Player.TrapZoneStats[2] - 1, Team 1, Off),
			!Current Array Element.IsWinner && !Current Array Element.IsInSpawnRoom && Current Array Element.EnemyTrapEntity == Null);
		For Player Variable(Event Player, TrapIndex, 0, Count Of(Event Player.PlayersInTrapZone), 1);
			Event Player.PlayersInTrapZone[Event Player.TrapIndex].EnemyTrapEntity = Event Player;
		End;
		Wait(0.500, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Pull Player to blue hole (Trap Zones)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEToggles[1] == True;
		Event Player.EnemyTrapEntity != Null;
		Event Player.EnemyTrapEntity.TrapZoneChoice == 2;
	}

	actions
	{
		Start Accelerating(Event Player, Direction Towards(Position Of(Event Player), Event Player.EnemyTrapEntity.TrapZoneStats[0]), 100,
			20, To World, Direction Rate and Max Speed);
		Disable Movement Collision With Environment(Event Player, True);
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
	}
}

rule("Player is in spawn room (Trap Zones)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEToggles[1] == True;
		Event Player.IsWinner == False;
		Event Player.IsInSpawnRoom == True;
	}

	actions
	{
		Event Player.EnemyTrapEntity = Null;
		"For Pitfall Trap"
		If(Global.GEChoice == 20);
			Disable Movement Collision With Environment(Event Player, False);
		Else;
			Enable Movement Collision With Environment(Event Player);
		End;
		Clear Status(Event Player, Knocked Down);
		"For Blue Hole Trap"
		If(Global.GEChoice != 41 && Global.GEChoice != 44);
			Stop Accelerating(Event Player);
		End;
		Stop Forcing Throttle(Event Player);
		"For Rooted Trap"
		Clear Status(Event Player, Rooted);
	}
}

rule("Root Player in place (Trap Zones)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.GEToggles[1] == True;
		Event Player.EnemyTrapEntity != Null;
		Event Player.EnemyTrapEntity.TrapZoneChoice == 3;
	}

	actions
	{
		Set Status(Event Player, Null, Rooted, 5);
		Small Message(Event Player, Custom String("Rooted!"));
		Wait Until(!Has Status(Event Player, Rooted), 99999);
		Wait(3, Ignore Condition);
		Loop If(Array Contains(Filtered Array(Players Within Radius(Event Player.EnemyTrapEntity[0], Event Player.EnemyTrapEntity[2],
			Team 1, Off), !Current Array Element.IsWinner && !Current Array Element.IsInSpawnRoom), Event Player));
		Event Player.EnemyTrapEntity = Null;
	}
}

rule("Select spring direction (Trap Zones)(GE)[SR]")
{
	event
	{
		Subroutine;
		SelectSpringDir;
	}

	actions
	{
		"Direction to catapult players"
		Event Player.TrapZoneStats[3] = Random Integer(0, 8);
		If(Event Player.TrapZoneStats[3] == 0);
			Event Player.TrapZoneStats[3] = Forward + Up;
		Else If(Event Player.TrapZoneStats[3] == 1);
			Event Player.TrapZoneStats[3] = Right + Up;
		Else If(Event Player.TrapZoneStats[3] == 2);
			Event Player.TrapZoneStats[3] = Backward + Up;
		Else If(Event Player.TrapZoneStats[3] == 3);
			Event Player.TrapZoneStats[3] = Left + Up;
		Else If(Event Player.TrapZoneStats[3] == 4);
			Event Player.TrapZoneStats[3] = Forward + Right + Up;
		Else If(Event Player.TrapZoneStats[3] == 5);
			Event Player.TrapZoneStats[3] = Backward + Right + Up;
		Else If(Event Player.TrapZoneStats[3] == 6);
			Event Player.TrapZoneStats[3] = Forward + Left + Up;
		Else If(Event Player.TrapZoneStats[3] == 7);
			Event Player.TrapZoneStats[3] = Backward + Left + Up;
		Else If(Event Player.TrapZoneStats[3] == 8);
			Event Player.TrapZoneStats[3] = Up;
		End;
	}
}

rule("Player touches spring (Trap Zones)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Global.GEToggles[1] == True;
		Event Player.TrapIDs != Null;
		Event Player.TrapZoneChoice == 4;
		Is True For Any(Players Within Radius(Event Player.TrapZoneStats[0], Event Player.TrapZoneStats[2] - 1, Team 1, Off),
			!Current Array Element.IsWinner && !Current Array Element.IsInSpawnRoom && Is On Ground(Current Array Element)) == True;
	}

	actions
	{
		Event Player.PlayersInTrapZone = Filtered Array(Players Within Radius(Event Player.TrapZoneStats[0],
			Event Player.TrapZoneStats[2] - 1, Team 1, Off),
			!Current Array Element.IsWinner && !Current Array Element.IsInSpawnRoom && Is On Ground(Current Array Element));
		Call Subroutine(SelectSpringDir);
		Apply Impulse(Event Player.PlayersInTrapZone, Event Player.TrapZoneStats[3], Random Real(8000, 12000), To World,
			Cancel Contrary Motion);
		Play Effect(All Players(Team 1), Ring Explosion, Color(Green), Event Player.TrapZoneStats[0], Event Player.TrapZoneStats[2]);
		Play Effect(All Players(Team 1), Buff Impact Sound, Color(White), Event Player.TrapZoneStats[0], 90);
		Wait(1, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Set lazer positions (Trap Zones)(GE)[SR]")
{
	event
	{
		Subroutine;
		SetLazerPositions;
	}

	actions
	{
		If(Event Player.TrapZoneChoice == 5);
			"Max height of lazers from the ground"
			Event Player.TrapZoneStats[3] = 6;
			"Current 1st lazer position"
			Event Player.FirstLazerPos = Event Player.TrapZoneStats[0];
			"1st lazer speed"
			Event Player.TrapZoneStats[5] = Random Real(2, 9);
			"Current 2nd lazer position"
			Event Player.SecondLazerPos = Event Player.TrapZoneStats[0] + Up * Event Player.TrapZoneStats[3];
			"2nd lazer speed"
			Event Player.TrapZoneStats[6] = Random Real(2, 9);
			"Max lazer position"
			Event Player.TrapZoneStats[4] = Event Player.SecondLazerPos;
			"Current 3rd lazer position"
			Event Player.ThirdLazerPos = Vector(X Component Of(Event Player.SecondLazerPos), Y Component Of(Event Player.SecondLazerPos) / 2,
				Z Component Of(Event Player.SecondLazerPos));
			"3rd lazer speed"
			Event Player.TrapZoneStats[7] = Random Real(2, 9);
	}
}

rule("Move 1st lazer (Trap Zones)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Global.GEToggles[1] == True;
		Event Player.TrapIDs != Null;
		Event Player.TrapZoneChoice == 5;
	}

	actions
	{
		Chase Player Variable Over Time(Event Player, FirstLazerPos, Event Player.TrapZoneStats[4], Event Player.TrapZoneStats[5], None);
		Wait Until(Event Player.FirstLazerPos == Event Player.TrapZoneStats[4], 15);
		Stop Chasing Player Variable(Event Player, FirstLazerPos);
		Abort If Condition Is False;
		Chase Player Variable Over Time(Event Player, FirstLazerPos, Event Player.TrapZoneStats[0], Event Player.TrapZoneStats[5], None);
		Wait Until(Event Player.FirstLazerPos == Event Player.TrapZoneStats[0], 15);
		Stop Chasing Player Variable(Event Player, FirstLazerPos);
		Abort If Condition Is False;
		Loop If Condition Is True;
	}
}

rule("Move 2nd lazer (Trap Zones)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Global.GEToggles[1] == True;
		Event Player.TrapIDs != Null;
		Event Player.TrapZoneChoice == 5;
	}

	actions
	{
		Chase Player Variable Over Time(Event Player, SecondLazerPos, Event Player.TrapZoneStats[0], Event Player.TrapZoneStats[6], None);
		Wait Until(Event Player.SecondLazerPos == Event Player.TrapZoneStats[0], 15);
		Stop Chasing Player Variable(Event Player, SecondLazerPos);
		Abort If Condition Is False;
		Chase Player Variable Over Time(Event Player, SecondLazerPos, Event Player.TrapZoneStats[4], Event Player.TrapZoneStats[6], None);
		Wait Until(Event Player.SecondLazerPos == Event Player.TrapZoneStats[4], 15);
		Stop Chasing Player Variable(Event Player, SecondLazerPos);
		Abort If Condition Is False;
		Loop If Condition Is True;
	}
}

rule("Move 3rd lazer (Trap Zones)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Global.GEToggles[1] == True;
		Event Player.TrapIDs != Null;
		Event Player.TrapZoneChoice == 5;
	}

	actions
	{
		Chase Player Variable Over Time(Event Player, ThirdLazerPos, Event Player.TrapZoneStats[0], Event Player.TrapZoneStats[7], None);
		Wait Until(Event Player.ThirdLazerPos == Event Player.TrapZoneStats[0], 15);
		Stop Chasing Player Variable(Event Player, ThirdLazerPos);
		Abort If Condition Is False;
		Chase Player Variable Over Time(Event Player, ThirdLazerPos, Event Player.TrapZoneStats[4], Event Player.TrapZoneStats[7], None);
		Wait Until(Event Player.ThirdLazerPos == Event Player.TrapZoneStats[4], 15);
		Stop Chasing Player Variable(Event Player, ThirdLazerPos);
		Abort If Condition Is False;
		Loop If Condition Is True;
	}
}

rule("Player touches lazer (Trap Zones)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Global.GEToggles[1] == True;
		Event Player.TrapIDs != Null;
		Event Player.TrapZoneChoice == 5;
		(Ray Cast Hit Player(Event Player.FirstLazerPos, Event Player.FirstLazerPos + Right * Event Player.TrapZoneStats[2], All Players(
			Team 1), Null, False) != Null || Ray Cast Hit Player(Event Player.SecondLazerPos,
			Event Player.SecondLazerPos + Right * Event Player.TrapZoneStats[2], All Players(Team 1), Null, False)
			!= Null || Ray Cast Hit Player(Event Player.ThirdLazerPos, Event Player.ThirdLazerPos + Right * Event Player.TrapZoneStats[2],
			All Players(Team 1), Null, False) != Null) == True;
	}

	actions
	{
		Event Player.PlayersInTrapZone[0] = Ray Cast Hit Player(Event Player.FirstLazerPos,
			Event Player.FirstLazerPos + Right * Event Player.TrapZoneStats[2], All Players(Team 1), Null, False);
		Event Player.PlayersInTrapZone[1] = Ray Cast Hit Player(Event Player.SecondLazerPos,
			Event Player.SecondLazerPos + Right * Event Player.TrapZoneStats[2], All Players(Team 1), Null, False);
		Event Player.PlayersInTrapZone[2] = Ray Cast Hit Player(Event Player.ThirdLazerPos,
			Event Player.ThirdLazerPos + Right * Event Player.TrapZoneStats[2], All Players(Team 1), Null, False);
		Kill(Event Player.PlayersInTrapZone, Event Player);
	}
}

rule("Player is within nullify zone (Trap Zones)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Global.GEToggles[1] == True;
		Event Player.TrapIDs != Null;
		Global.GEChoice != 12;
		Event Player.TrapZoneChoice == 6;
		Is True For Any(Players Within Radius(Event Player.TrapZoneStats[0], Event Player.TrapZoneStats[2] - 1, Team 1, Off),
			!Current Array Element.IsWinner && !Current Array Element.IsInSpawnRoom && !Has Status(Current Array Element, Hacked)) == True;
	}

	actions
	{
		Event Player.PlayersInTrapZone = Filtered Array(Players Within Radius(Event Player.TrapZoneStats[0],
			Event Player.TrapZoneStats[2] - 1, Team 1, Off),
			!Current Array Element.IsWinner && !Current Array Element.IsInSpawnRoom && !Has Status(Current Array Element, Hacked));
		Set Status(Event Player.PlayersInTrapZone, Null, Hacked, 8);
		Wait(1, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Set betting zone location (Rigged Lottery)(GE)[SR]")
{
	event
	{
		Subroutine;
		SetBetZoneLoc;
	}

	actions
	{
		Event Player.GETempVar = Random Integer(0, 25);
		Event Player.GETempVar2 = Random Real(15, 70);
		If(Event Player.GETempVar == 0);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + Forward * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 1);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Forward + Right) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 2);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + Right * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 3);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Backward + Right) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 4);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + Backward * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 5);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Backward + Left) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 6);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + Left * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 7);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Forward + Left) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 8);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Forward + Down) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 9);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Forward + Up) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 10);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Right + Up) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 11);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Right + Down) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 12);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Backward + Down) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 13);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Backward + Up) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 14);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Left + Up) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 15);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Left + Down) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 16);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Forward + Right + Up) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 17);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Forward + Right + Down) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 18);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Backward + Right + Down)
				* Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 19);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Backward + Right + Up) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 20);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Forward + Left + Up) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 21);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Forward + Left + Down) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 22);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Backward + Left + Down) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 23);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + (Backward + Left + Up) * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 24);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + Up * Event Player.GETempVar2);
		Else If(Event Player.GETempVar == 25);
			Event Player.GETempVar = Nearest Walkable Position(Position Of(Event Player) + Down * Event Player.GETempVar2);
		End;
	}
}

rule("Init betting zones (Rigged Lottery)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Global.GEChoice == 50;
		Global.IsGETimerStart == True;
		Event Player.GEID == Null;
	}

	actions
	{
		Call Subroutine(SetBetZoneLoc);
		Create Effect(All Players(Team 1), Sphere, Color(Yellow), Event Player.GETempVar, Global.GERadius, Visible To);
		Event Player.GEID[0] = Last Created Entity;
		Create Effect(All Players(Team 1), Pick-up Sound, Color(White), Event Player.GETempVar, 100, Visible To);
		Event Player.GEID[1] = Last Created Entity;
		Create In-World Text(All Players(Team 1), Custom String("{0}", Slot Of(Event Player) + 1), Event Player.GETempVar, 1.400,
			Do Not Clip, Visible To, Color(Rose), Default Visibility);
		Event Player.GEHUDID = Last Text ID;
	}
}

rule("Placing bets (Rigged Lottery)(GE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		Bastion;
	}

	conditions
	{
		Global.GEChoice == 50;
		Global.IsGETimerStart == True;
		Event Player.GEID != Null;
		Is True For Any(Players Within Radius(Event Player.GETempVar, Global.GERadius, Team 1, Off),
			!Current Array Element.IsWinner && Is Button Held(Current Array Element, Button(Reload))) == True;
	}

	actions
	{
		Event Player.GETempVar2 = Filtered Array(Players Within Radius(Event Player.GETempVar, Global.GERadius, Team 1, Off),
			!Current Array Element.IsWinner && Is Button Held(Current Array Element, Button(Reload)));
		For Player Variable(Event Player, GEIndex, 0, Count Of(Event Player.GETempVar2), 1);
			Event Player.GETempVar2[Event Player.GEIndex].LotteryChoice = Slot Of(Event Player) + 1;
			Small Message(Event Player.GETempVar2[Event Player.GEIndex], Custom String("You have placed a bet in zone {0}", Slot Of(
				Event Player) + 1));
			Wait(0.100, Ignore Condition);
		End;
		Wait(0.250, Abort When False);
		Loop If Condition Is True;
	}
}